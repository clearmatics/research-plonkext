% !TEX root = main.tex
% !TEX spellcheck = en-US



\section{Polynomial Commitment Schemes}
\label{sec:pcom}
A polynomial commitment scheme $\PCOM = (\kgen, \com, \open, \verify)$ consists of four
algorithms and allows to commit to a polynomial $\p{f}$ and later open the evaluation in a
point $z$ to some value $s=\p{f}(z)$. More formally:
\begin{description}
\item[$\kgen(1^\secpar, \maxdeg)$:] The key generation algorithm takes in a security
  parameter $\secpar$ and a parameter $\maxdeg$ which determines the maximal degree of the
  committed polynomial. It outputs a structured reference string $\srs$ (the commitment
  key). In the following we will consider $\srs$ implicitly determines $\secpar$.
\item[$\com(\srs, \p{f})$:] The commitment algorithm $\com(\srs, \p{f})$ takes
  in $\srs$ and a polynomial $\p{f}$ with maximum degree $\maxdeg$, and outputs
  a commitment $c$.
\item[$\open(\srs, z, s, \p{f})$:] The opening algorithm
  takes as input $\srs$, an evaluation point $z$, a
  value $s$ and the polynomial $\p{f}$. It outputs an opening $o$.
\item[$\verify(\srs, c, z, s, o)$:] The verification algorithm takes in $\srs$,
  a commitment $c$, an evaluation point $z$, a value $s$ and an opening $o$. It
  outputs 1 if $o$ is a valid opening for $(c, z, s)$ and 0 otherwise.
\end{description} 

A secure polynomial commitment $\PCOM$ should satisfy correctness, evaluation binding,
opening uniqueness, hiding and knowledge-binding.  Note that since we are in the updatable
setting, $\srs$ in these security definitions is the SRS that $\advse$ finalises using the
update oracle $\initU$ (See~\cref{fig:upd}).

\begin{description}
\item[Evaluation binding:] A $\ppt$ adversary $\adv$ which outputs a commitment
  $\vec{c}$ and evaluation points $\vec{z}$ has at most negligible chances to open
  the commitment to two different evaluations $\vec{s}, \vec{s'}$. That is, let
  $k \in \NN$ be the number of committed polynomials, $l \in \NN$ number of
  evaluation points, $\vec{c} \in \GRP^k$ be the commitments, $\vec{z} \in
  \FF_p^l$ be the arguments the polynomials are evaluated at, $\vec{s},\vec{s}'
  \in \FF_p^k$ the evaluations, and $\vec{o},\vec{o}' \in \FF_p^l$ be the
  commitment openings. Then for every $\ppt$ adversary $\adv$
	\[
		\condprob{
			\begin{matrix}
				  \verify(\srs, \vec{c}, \vec{z}, \vec{s}, \vec{o}) = 1,  \\ 
				  \verify(\srs, \vec{c}, \vec{z}, \vec{s}', \vec{o}') = 1, \\
				  \vec{s} \neq \vec{s}'
			\end{matrix}}
			{
			\begin{matrix}
%				& \srs \gets \kgen(\secparam, \maxdeg),\\
				 (\vec{c}, \vec{z}, \vec{s}, \vec{s}', \vec{o}, \vec{o}') \gets \adv^{\initU}(\maxdeg)
			\end{matrix}
		} \leq \negl\,.
	\]

\end{description}
	
%We say that $\PCOM$ has the unique opening property if the following holds:
To show unique response property of our schemes we require that the polynomial
commitment scheme the proof system is using has unique openings defined as follows.
\begin{description}
\item[Opening uniqueness:] Intuitively, opening uniqueness assures that there is only one
  valid opening for the committed polynomial and given evaluation point. This property is
  crucial in showing \COMMENT{forking }simulation-extractability of $\plonk$, $\sonic$ and
  $\marlin$.
  Let $k \in \NN$ be the number of committed polynomials, $l \in \NN$ number of evaluation
  points, $\vec{c} \in \GRP^k$ be the commitments, $\vec{z} \in \FF_p^l$ be the arguments
  the polynomials are evaluated at, $\vec{s} \in \FF_p^k$ the evaluations, and
  $\vec{o}, \vec{o}' \in \FF_p^l$ be the commitment openings. Then for every $\ppt$ adversary $\adv$
	\[
		\condprob{
			\begin{matrix}
				  \verify(\srs, \vec{c}, \vec{z}, \vec{s}, \vec{o}) = 1,  \\ 
				  \verify(\srs, \vec{c}, \vec{z}, \vec{s}, \vec{o'}) = 1, \\
				 \vec{o} \neq \vec{o'}
			\end{matrix}
		}{
			\begin{matrix}
%				& \srs \gets \kgen(\secparam, \maxdeg),\\
				  (\vec{c}, \vec{z}, \vec{s}, \vec{o}, \vec{o'}) \gets \adv^{\initU}(\maxdeg)
			\end{matrix}
		}\leq \negl\,.
	\]
\end{description}
We show
that $\plonk$'s, $\sonic$'s, and $\marlin$'s polynomial commitment schemes satisfy this
requirement in \cref{lem:pcomp_op} and \cref{lem:pcoms_unique_op}
respectively.


\begin{description}
\item[Hiding:] We also formalize notion of $k$-hiding property of a polynomial commitment scheme. Let $\HHH$ be a set of size $\maxdeg + 1$ and $\ZERO_\HHH$ its
  vanishing polynomial. We say that a polynomial scheme is \emph{hiding} with
  security $\epsh(\secpar)$ if for every $\ppt$ adversary $\adv$, $k \in \NN$,
  probability
  \begin{align*}
    \condprob
   { b' = b}{
    (f_0, f_1, c, k, b') \gets \adv^{\initU, \oraclec}(\maxdeg, c), f_0, f_1 \in \FF^{\maxdeg}
    [X]}
\leq \frac{1}{2} + \eps(\secpar).
  \end{align*}
  Where $c = f'_b (\chi)$, for a random bit $b$ and the polynomial
      $f'_b (X) = f_b + \ZERO_\HHH (X) (a_0 + a_1 X + \ldots a_{k - 1} X^{k -
        1})$,
and the oracle $\oraclec$ on adversary's evaluation query $x$ it adds $x$ to initially empty set
      $Q_x$ and if $|Q_x| \leq k$, it provides $f'_b (x)$.
 
  \end{description}

\begin{description}
\item[Commitment of knowledge:] Intuitively, when a commitment scheme is ``of knowledge'' then if an
adversary produces a (valid) commitment $c$, which it can open correctly in an evaluation point, then it must
know the underlying polynomial $\p{f}$ which commits to that value.  For every $\ppt$ adversary $\adv$ who produces
  commitment $c$, evaluation $s$ and opening $o$ there
  exists a $\ppt$ extractor $\ext$ such that
\[
  \condprob{
    \begin{matrix}
       \deg \p{f} \leq \maxdeg,
       c = \com(\srs, \p{f}),\\
       \verify(\srs, c, z, s, o) = 1
    \end{matrix}
        }{
    \begin{matrix}
      %
     % & \srs \gets \kgen(\secparam, \maxdeg),\\
      c \gets \adv^{\initU}(\maxdeg),
      z \sample \FF_p \\
      (s, o) \gets \adv(c, z), \\
   \p{f} = \ext_\adv(\srs, c)\\
    \end{matrix}}
  \geq 1 - \epsk(\secpar).
\]
In that case we say that $\PCOM$ is $\epsk(\secpar)$-knowledge.
\end{description}


\cref{fig:pcomp,fig:pcoms} present variants of KZG~\cite{AC:KatZavGol10} polynomial
commitment schemes used in \plonk{}, \sonic{} and \marlin{}. The key generation algorithm
$\kgen$ takes as input a security parameter $\secparam$ and a parameter $\maxdeg$ which
determines the maximal degree of the committed polynomial. We assume that $\maxdeg$ can be
read from the output SRS. While the figures only describe trusted SRS setup, it is not
hard to lift the SRS generation into the updatable setting by defining the extra
algorithms $\upd$, $\verifyCRS$ (see~\cref{def:upd-scheme}) as described in~\cref{fig:upd-scheme}.  \cite{CCS:MBKM19}
shows, using AGM, that $\PCOMs$ is a commitment of knowledge.  The same reasoning could be
used to show that property for $\PCOMp$.
 



\begin{figure}[t!]
	\centering
	\fbox{
		\begin{minipage}[t]{0.76\linewidth}
			\procedure{$\kgen(\REL)$}{
				\chi \sample \FF_p \\ [\myskip]
				\srs := 
				\left( \gone{\smallset{\chi^i}_{i = 0}^{\dconst}},
				\gtwo{\chi} \right); 
				\rho =  \left(\gone{\chi, \chi}, \gtwo{\chi}\right) \\ [\myskip]
				\pcreturn (\srs, \rho) \\ [\myskip]
			}
		%
		\\
		%
		\procedure{$\verifyCRS(\srs, \{\rho_j \}_{j=1}^n)$}{
			\text{Parse }  \srs \text{ as } \left( \gone{\smallset{A_i}_{i = 0}^{\dconst}},
			\gtwo{B} \right) \text{and } \{\rho_j \}_{j=1}^n \text{ as } \left\{\left( P_j, \bP_j, \hP_j \right)\right\}_{j=1}^n \\ [\myskip]
			\text{Verify Update proofs: } \\ [\myskip]
			\t \bP_1 = P_1 \\ [\myskip]
			\t P_j \bullet \gtwo{1} = P_{j-1} \bullet \hP_j \quad \forall j \geq 2 \\ [\myskip]
			\t \bP_n \bullet \gtwo{1} = \gone{1} \bullet \hP_n \\ [\myskip]
			\text{Verify SRS structure: } \\ [\myskip]
			\t \gone{A_i} \bullet \gtwo{1} = \gone{A_{i-1}} \bullet \gtwo{B} \text{ for all } 0 < i \leq \dconst \\ [\myskip]
		}
		%
		\\
		%
		\procedure{$\upd(\srs, \{\rho_j \}_{j=1}^n)$}{
			\text{Parse } \srs \text{ as } \left( \gone{\smallset{A_i}_{i = 0}^{\dconst}},
			\gtwo{B} \right) \\ [\myskip]
			\chi' \sample \FF_p  \\ [\myskip]
			\srs' := 
			\left( \gone{\smallset{{\chi'}^i A_i}_{i = 0}^{\dconst}},
			\gtwo{\chi' B} \right); 
			\rho' =	\left( \gone{\chi' A_1, \chi'}, \gtwo{\chi'}\right) \\ [\myskip]
			\pcreturn (\srs', \rho')
		}
		\end{minipage}}
	\caption{Updatable SRS scheme for $\PCOMp$} 
	\label{fig:upd-scheme}
\end{figure}


\begin{figure}
  \small
  \hspace*{-2cm}\fbox{
\begin{minipage}{15,5cm}
\begin{pcvstack}[]
  \begin{pchstack}
			\procedure{$\kgen(\secparam, \maxdeg)$}
			{
			\chi \sample \FF_p \\ [\myskip]
			\pcreturn \srs = \gone{1, \ldots, \chi^{\maxdeg}}, \gtwo{\chi}\\ [\myskip]
      }\\
      \michals{29.04}{adjust to $\initU$}
			
			\pchspace
			
			\procedure{$\com(\srs, \vec{\p{f}}(X))$}
			{ 
				\pcreturn \gone{\vec{c}} = \gone{\vec{\p{f}}(\chi)}\\ [\myskip]
        \fbox{$\pcreturn \vec{\p{f}} (X)$}\\
			}

      \pchspace

      \procedure{$\open(\srs, \vec{z}, \vec{s}, \vec{\p{f}}(X), \aux_0)$}
			{
      \vec{\gamma} \gets \ro (g_0( \vec{z}, \vec{s}, \gone{\vec{c}}, \aux_0))\\[\myskip]
			\pcfor i \in \range{1}{\abs{\vec{z}}} \pcdo\\ [\myskip]
      \pcind \p{o}_j(X) \gets \sum_{i \in K_j} \gamma_{j}^{i - 1}
      \frac{\p{f}_{i}(X) - \p{f}_{i}(z_j)}{X - z_j}\\ [\myskip] 
      \pcreturn \vec{o} = \gone{\vec{\p{o}}(\chi)}\\ [\myskip]
      \fbox{$\pcreturn \vec{\p{o}} (X)$}
				% \hphantom{\hspace*{5.5cm}}	
			}

    \end{pchstack}
		 \pcvspace
    
		\begin{pchstack}
			\procedure{$\verifyb(\srs, \gone{\vec{c}}, \vec{z}, \vec{s}, \gone{\p{o}(\chi)}, (\aux_0,\aux_1))$}
			{
        \vec{\gamma} \gets \ro (g_0( \vec{z}, \vec{s}, \gone{\vec{c}}, \aux_0))\\[\myskip]
				r \gets \ro (g_1(\gone{\vec{c}}, \vec{z}, \vec{s}, \gone{\p{o}(\chi)}, \aux_1))\\ [\myskip]
				% \pcfor j \in \range{1}{\abs{\vec{z}}} \pcdo \\ [\myskip]
				(*) \pcif 
          \sum_{j = 1}^{\abs{\vec{z}}} r^{j} \cdot \gone{\sum_{i \in K_j}
          \gamma_j^{i - 1} c_{i} - \sum_{i \in K_j} \gamma_j^{i - 1} s_{i_j}} \bullet \gtwo{1} + \\ [\myskip] 
          \pcind \sum_{j = 1}^{\abs{\vec{z}}} r^{j} z_j o_j
          \bullet \gtwo{1} \neq \gone{\sum_{j = 1}^{\abs{\vec{z}}} r^{j} o_j }
          \bullet \gtwo{\chi} \pcthen  \\
					\pcind \pcreturn 0\\ [\myskip]
          \fbox{
            \begin{minipage}{7cm}
            (**) $\pcif $
              $\sum_{j = 1}^{\abs{\vec{z}}} r^j \cdot (\sum_{i \in K_j}
              \gamma_j^{i - 1} \p{f}_{i} (X) - \sum_{i \in K_j} \gamma_j^{i - 1} s_{i_j}) + $\\ [\myskip] 
              $\pcind \sum_{j = 1}^{\abs{\vec{z}}} r^{j} z_j \p{o}_j (X)
               \neq \sum_{j = 1}^{\abs{\vec{z}}} r^{j} \p{o}_j (X)
              \cdot X \pcthen $ \\
              $\pcind \pcreturn 0$
            \end{minipage}
          }\\[\myskip]
					\pcreturn 1.\\
			}

      \pchspace
      
      \procedure{$\verify(\srs, \gone{\vec{c}}, \vec{z}, \vec{s}, \gone{\p{o}(\chi)},\aux_0)$}
			{
        \vec{\gamma} \gets \ro (g_0( \vec{z}, \vec{s}, \gone{\vec{c}}, \aux_0))\\[\myskip]
				\pcfor j \in \range{1}{\abs{\vec{z}}} \pcdo \\ [\myskip]
				\pcind \pcif 
          \gone{\sum_{i \in K_j}
          \gamma_j^{i - 1} c_{i} - \sum_{i \in K_j} \gamma_j^{i - i} s_{i, j}} \bullet
          \gtwo{1} + \\ [\myskip] \pcind  z_j
          o_j
          \bullet \gtwo{1} \neq \gone{o_j}
          \bullet \gtwo{\chi} \pcthen  \\
					\pcind \pcreturn 0\\ [\myskip]
        \fbox{
          \begin{minipage}{7cm}
          $\pcind \pcif $
          $\sum_{i \in K_j} \gamma_j^{i - 1} \p{f}_{i} (X) - \sum_{i \in K_j} \gamma_j^{i - i} s_{i, j} + $\\ [\myskip] 
          $\pcind  z_j \p{o}_j (X) \neq \p{o}_j (X) X \pcthen \pcreturn 0$
        \end{minipage}
        }\\ [\myskip]
					\pcreturn 1.
			}

    \end{pchstack}
	\end{pcvstack}
\end{minipage}
  }
	\caption{$\PCOM$ polynomial commitment scheme. Here $\abs{\vec{z}} = l$ is the number of evaluation points, the number of committed polynomials is $m$, $K_j$ is the set of polynomials that was evaluated at point $z_j$. Functions $g_0$ and $g_1$ are injective and specific to the context in which the polynomial commitment is used. (In our case, functions $g_0$ and $g_1$ are produce partial transcripts of the proof that utilizes the commitment scheme, $\aux$ contains all additional information that is needed by the functions.)
  In the boxes we describe values returned or equality computed in the ideal protocol where the verifier checks equalities on the polynomials instead of their evaluations. For algorithm $\pcalgostyle{Alg}$ we denote its ideal variant by $\pcalgostyle{Alg}'$.}
	\label{fig:pcomp}
  \end{figure}

% \begin{figure}[h!]
% \centering
% 	\begin{pcvstack}[center,boxed]
% 		\begin{pchstack}
% 			\procedure{$\kgen(\secparam, \maxdeg)$} {
% 				\alpha, \chi \sample \FF^2_p \\ [\myskip]
% 				\pcreturn \gone{\smallset{\chi^i}_{i = -\multconstr}^{\multconstr},
%           \smallset{\alpha \chi^i}_{i = -\multconstr, i \neq
%             0}^{\multconstr}},\\
%         \pcind \gtwo{\smallset{\chi^i, \alpha \chi^i}_{i =
%             -\multconstr}^{\multconstr}}, \gtar{\alpha}\\
% 				%\markulf{03.11.2020}{} \\
% 			%	\hphantom{\pcind \p{o}_i(X) \gets \sum_{j = 1}^{t_i} \gamma_i^{j - 1} \frac{\p{f}_{i,j}(X) - \p{f}_{i, j}(z_i)}{X - z_i}}
% 				\hphantom{\hspace*{5.5cm}}
% 		}
%
% 			\pchspace
%
% 			\procedure{$\com(\srs, \maxconst, \p{f}(X))$} {
% 				\p{c}(X) \gets \alpha \cdot X^{\dconst - \maxconst} \p{f}(X) \\ [\myskip]
% 				\pcreturn \gone{c} = \gone{\p{c}(\chi)}\\ [\myskip]
% 				\hphantom{\pcind \pcif \sum_{i = 1}^{\abs{\vec{z}}} r_i \cdot
%           \gone{\sum_{j = 1}^{t_j} \gamma_i^{j - 1} c_{i, j} - \sum_{j = 1}^{t_j}
%             s_{i, j}} \bullet \gtwo{1} + } }
% 		\end{pchstack}
% 		% \pcvspace
%
% 		\begin{pchstack}
% 			\procedure{$\open(\srs, z, s, f(X))$}
% 			{
% 				\p{o}(X) \gets \frac{\p{f}(X) - \p{f}(z)}{X - z}\\ [\myskip]
% 				\pcreturn \gone{\p{o}(\chi)}\\ [\myskip]
% 				\hphantom{\hspace*{5.5cm}}
% 			}
%
% 			\pchspace
%
% 			\procedure{$\verify(\srs, \maxconst, \gone{c}, z, s, \gone{\p{o}(\chi)})$}
%       {
%         \pcif \gone{\p{o}(\chi)} \bullet \gtwo{\alpha \chi} + \gone{s - z
%         \p{o}(\chi)} \bullet \gtwo{\alpha} = \\ [\myskip] \pcind \gone{c}
%         \bullet \gtwo{\chi^{- \dconst + \maxconst}} \pcthen  \pcreturn 1\\
%         [\myskip]
%         \rlap{\pcelse \pcreturn 0.} \hphantom{\pcind \pcif \sum_{i =
%             1}^{\abs{\vec{z}}} r_i \cdot \gone{\sum_{j = 1}^{t_j} \gamma_i^{j -
%               1} c_{i, j} - \sum{j = 1}^{t_j} s_{i, j}} \bullet \gtwo{1} + } }
% 		\end{pchstack}
% 	\end{pcvstack}
%
% 	\caption{$\PCOMs$ polynomial commitment scheme.}
% 	\label{fig:pcoms}
% \end{figure}

\subsection{Unique opening property of $\PCOM$}
Now, we show that the batched variant of the KZG polynomial
commitment scheme that is used in \plonk{} and $\marlin{}$, has the unique opening property.

\begin{lemma}
\label{lem:pcomp_op}
Let $\PCOM = (\kgen, \com, \open, \verifyb)$ be a batched version of a KZG polynomial commitment,
cf.~\cref{fig:pcomp}, that commits to $m$ polynomials of degree up to $\maxdeg$. Let $\vec{z} = (z_0, \ldots, z_{l - 1}) \in \FF_p^l$ be the points the polynomials are  evaluated at, $k_i \in \NN$ be the number of the committed polynomials to be evaluated at $z_i$, and $K_i$ be the set of indices of these polynomials. Let $\vec{s_{K_i}} \in \FF_p^{k_i}$ the evaluations of polynomials at $z_i$, and $\vec{o} = (o_0, \ldots, o_{l - 1}) \in \FF_p^l$ be the commitment openings. We show that the probability an algebraic adversary $\adv$, who can made up to $q$ random oracle queries, opens the same commitment in two different ways is at most $\epsop(\secpar)$, for $\epsop(\secpar) \leq l \cdot  \epsudlog(\secpar) + \infrac{1}{\abs{\FF_p}}$, where $\epsudlog(\secpar)$ is security of the $(\maxdeg, 1)$-$\udlog$ assumption and $\FF_p$ is the field used in $\PCOM$.
\end{lemma}
\begin{proof}
 
  The proof goes by game hops. In the first game the adversary wins if it presents two acceptable openings of a vector of polynomials. Then, we restrict the winning condition and require that the adversary also makes the idealized batched verifier to accept the proof. In the next game, we abort if the idealized verifier rejects a proof for one of the evaluation point. 

  \ncase{Game 0} In this game the adversary wins if it provides two different openings for a vector of polynomial commitments and their evaluations that are acceptable by $\verifyb$.

  \ncase{Game 1} This game is identical to Game 0 except it is additionally aborted if the commitment opening are not acceptable by $\verifyb'$.

  \ncase{Game 0 to Game 1} %
  Any discrepancy between the idealised verifier rejection and real verifier acceptance allows one to break the (updatable) discrete logarithm problem.  The reduction $\rdvdulog$ proceeds as follows. It answers $\adv$'s queries for SRS updates according to the answers it receives from its udlog update oracle. When $\adv$ finalizes an SRS, $\rdvdulog$ finalizes the corresponding udlog challenge $(\gone{1, \ldots, {\chi'}^{\maxdeg}}, \gtwo{1})$. We consider verification equation $(**)$ as a polynomial in $X$ and the verification equation $(*)$ as it's evaluation at $\chi'$. Consider an opening such that verification equation (**), cf.~\cref{fig:pcomp}, does not hold, i.e.~(**) is not a zero polynomial, but (*) does, i.e.~(**) zeroes at $\chi'$. Since $\adv$ is algebraic, all proof elements are extended by their representation as a combination of the input $\GRP_1$-elements. Therefore, all coefficients of the verification equation polynomial related to (**) are known. Now, $\rdvdulog$ computes the roots of (**), finds $\chi'$ among them, and returns $\chi'$. Hence the probability that the adversary wins in Game 1, but does not win in Game 0 is upper-bounded by $\epsudlog (\secpar)$.

  \ncase{Game 2} This game is identical to Game 1 except it is additionally aborted if one of the opening is not acceptable by an idealised verifier $\verify'$.

  \ncase{Game 1 to Game 2}
  The ideal verifier checks whether the following equality, for $\smallset{\gamma_j}_{j = 1}^{l}, r$
  picked at random, holds:
  \begin{multline}
    \label{eq:ver_eq_poly}
    \sum_{j = 0}^{l - 1} r^{j}\left(\sum_{i \in K_j} \gamma_{j}^{i - 1} \cdot \p{f}_i(X) - \sum_{i \in K_j} \gamma_{j}^{i - 1} \cdot {s_i}_j \right) 
    \equiv \sum_{j = 0}^{l - 1} r^{j} \p{o_{j}}(X)(X - z_j).
  \end{multline}
  Since $r$ has been picked as a random oracle output, probability that
  \cref{eq:ver_eq_poly} holds while for some $j \in \range{0}{l - 1}$
  \[
    r^j \left(\sum_{i \in K_j} \gamma^{i - 1} \cdot \p{f}_i(X) - \sum_{i \in K_j}
    \gamma^{i - 1} \cdot {s_i}_j \right) \not\equiv r^j \p{o_j}(X)(X - z_j)
  \]
  is $\infrac{q}{\abs{\FF_p}}$~cf.~\cite{EPRINT:GabWilCio19}. 
  When \(
    r^j \left(\sum_{i \in K_j} \gamma^{i - 1} \cdot \p{f}_i(X) - \sum_{i \in K_j}
    \gamma^{i - 1} \cdot {s_i}_j \right) = r^j \p{o_j}(X)(X - z_j)
  \)
  holds, polynomial $\p{o_j}(X)$ is uniquely determined from the uniqueness of
  polynomial composition. 

  \ncase{Conclusion} %
  We note that the idealised verifier $\vereq(X)$ does not accept two different openings of a correct evaluation. Hence the probability that the adversary wins Game 2 is $0$ and the probability that the adversary wins in Game 0 is upper-bounded by \(\epsudlog (\secpar) + \frac{q}{\abs{\FF_p}}\).
    \qed
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
