
\begin{comment}
\chaya{notes: begin}
There exist several approaches to make current zkSNARKs adequate for real-life deployment among which are \emph{simulation extractability} (SE) and \emph{updatability}.
There are zkSNARKs that are SE and zkSNARKs that are updatable universal. The question of zkSNARKs that enjoy both of these properties was recently tackled by Kohlweiss and Zajac~\cite{KZ21}
where they consider SE for \emph{universal srs} SNARKs. However, their definition does not capture the updatability property. Intuitively, the updatability of the srs allows an adversarial prover to contribute to updating, and see proofs with respect to different updated srs'es before attempting to provide a proof for a false statement (potentially output a proof wrt a srs that is different from the srs'es corresponding to all the simulated proofs seen). This capability of the adversary is not modeled in the definition of~\cite{KZ21}. In this work, we capture this by extending the definition of SE for updatable SNARKs and investigate whether existing zkSNARK constructions satisfy the new definition.


Points to mention:
\begin{itemize}
    \item cite Abdolmaleki et
al.~\cite{CCS:AbdRamSla20}: 
    \begin{itemize}
        \item the most relevant related work 
        \item was published at CCS20 (so gives credibility to our result)
        \item they show a generic compiler/lifting techniques for 
non-black-box simulation extractability 
        \item they also preserve succinctness of the
argument.
    \end{itemize}
    \item non-malleability is usually handeled by binding signatures e.g. Zerocash, Zcash, Orchard. 
    \item Working on improving the security definitions to capture real-world scenarios and powerful adversaries is an important step and makes SNARKs easier to reason about. 
    
    \item Classical definition of KS is not enough in applications: 
    More generaly, the classical definition of KS seems to be unsatisfactory in applications, as it does not provide sufficient security guarantees for SNARKs in the following sense: 
    The natural belief that seeing a valid proof only tells a verifier that the prover knew a satisfactory witness is simply not true. In the context of malleable SNARKs, seeing other valid proofs allows one to construct related proofs   whithout knowing any witness. 
    \item Allowing for malleability makes it difficult to reason about the security properties of SNARKs. Ignoring the ability of an adversary to see other valid proofs prevents from modeling a realistic definition. 
    \item Generic lifting techniques / compilers have overheads and are unnecessary to be applied to schemes for which we can directly show they satisfy our definitions. 
    
\end{itemize}

\chaya{notes: end}
\end{comment}

\section{Introduction}

\paragraph{zkSNARKs.}

\paragraph{Fiat--Shamir.}

\paragraph{Simulation extractability.}
Most zkSNARKs are shown to satisfy a standard knowledge soundness property. However, deployments of zkSNARKs in real-world applications require a stronger property -- 
\textit{simulation-extractability}(SE). 
This is because, in practice, an adversary against the zkSNARK has access to proofs provided by other parties using the same
zkSNARK. For instance, in applications of
zkSNARKs in privacy-preserving blockchains, proofs are posted on the chain for all
blockchain-participants to see. Therefore, it is necessary for
a zero-knowledge proof system to be resilient against adversaries that additionally get to see proofs generated by different parties before trying to forge.

There are many results on simulation extractability for
non-interactive zero-knowledge proofs (NIZKs). First, Groth \cite{AC:Groth07}
noticed that a (black-box) SE NIZK is
universally-composable (UC) 
\cite{EPRINT:Canetti00}. Then Dodis et al.~\cite{AC:DHLW10} introduced a
notion of (black-box) \emph{true simulation extractability} and showed that no
NIZK can be UC-secure if it does not have this property. 

In the context of zkSNARKs, the first
SE zkSNARK was proposed by Groth and Maller \cite{C:GroMal17} and SE
zkSNARK for QAP by Lipmaa \cite{EPRINT:Lipmaa19a}. 
Kosba's et
al.~\cite{EPRINT:KZMQCP15} give a general transformation from a NIZK to a
black-box SE NIZK. Although their transformation works for zkSNARKs as well,
succinctness of the proof system is not preserved by the transformation.
Recently, Abdolmaleki et al.~\cite{CCS:AbdRamSla20} showed another transformation that
obtains non-black-box simulation extractability but also preserves
succinctness of the argument. \chaya{they also give a definition for updatable setting. we should compare.}
The zkSNARK of~\cite{EC:Groth16} has been shown to be SE by introducing minor modifications to the construction and making
stronger assumptions \cite{EPRINT:BowGab18,EPRINT:AtaBag19}. Interestingly,
although such modifications hurt performance of the proof system, the resulting
zkSNARKs are still more efficient than the first SE zkSNARK of \cite{C:GroMal17},
see \cite{EPRINT:AtaBag19}. Recently, \cite{EPRINT:BKSV20} showed that the
original Groth's proof system from \cite{EC:Groth16} is weakly SE and
randomisable.  

\paragraph{The challenge in the updatable SRS setting.}
One of the downsides of efficient zkSNARKs like \cite{GGPR,PGHR} is that they rely on a \textit{trusted setup}, where the SRS is assumed to be generated by a trusted party. In practice, however, this assumption is not well founded; if the party that generates the SRS is not honest, then they can produce proofs of false statement. That is, if the trusted setup assumption does not hold, knowledge soundness breaks down.
Groth et al.\cite{} propose a setting to tackle this challenge which allows parties -- provers and verifiers-- to \emph{update} the SRS, that is, take a current SRS and contribute to it randomness in a verifiable way to obtain a new SRS. The guarantee in this \textit{updatable setting} is that knowledge soundness holds as long as one of the parties who updates the SRS is honest.
Although inefficient, as the SRS length
is quadratic to the size of the statement, \cite{C:GKMMM18} set a new
paradigm for designing zkSNARKs.

The first universal zkSNARK with updatable and linear size SRS was
$\sonic$ proposed by Maller et al.~in \cite{CCS:MBKM19}. Subsequently, Gabizon et
al.~designed $\plonk$ \cite{EPRINT:GabWilCio19} which currently is the
most efficient updatable universal zkSNARK. Independently, Chiesa et
al.~\cite{EC:CHMMVW20} proposed $\textsf{Marlin}$ with comparable efficiency to
$\plonk$.

The notion of simulation-extractability for zkSNARKs which is well motivated in practice has not been studied in this updatable setting. As it turns out, defining SE for updatable SRS zkSNARKs requires some care. Since the SRS is being continually updated, there are proofs with respect to \textit{different} SRS'es available for the adversary to see before attempting to forge a proof with respect to a current SRS. 
That is, each SRS in the update chain spawns a simulation oracle. Intuitively, the updatability of the SRS allows an adversarial prover to contribute to updating, and see proofs with respect to different updated SRS'es before attempting to provide a proof for a false statement (potentially output a proof wrt a SRS that is different from the SRS'es corresponding to all the simulated proofs seen). A definition of SE in the updatable setting should take into account this additional power of the adversary, which is not captured by existing definitions of SE.

\subsection{Our Contributions}
\begin{itemize}
    \item Definition of simulation extractability in the updatable SRS setting
    
    \item Prove that the most efficient uipdatable SRS SNARKS (Plonk/Sonic/Marlin) satisfy this definition
    
    \item
    Technical contributions along the way: new forking lemma
\end{itemize}



\subsection{Technical Overview}
unique response, forking soundness. general theorem without additional assumptions. to apply the theorem to concrete schemes like plonk, we show it satisfies unique response, forking soundness, in AGM.

\subsection{Related Work}
GT20: also about security loss incurred by FS transformation for KS from WEE. put forth a notion of state restoration. analysis in AGM.
Here: not just KS, but SE. we minimize AGM, rely on rewinding. directly capture the ``state restoration" capability of the prover in the forking lemma.
no online extraction. new technical challenges arise.

