\section{Non-malleability of \plonk{}, omitted protocol descriptions}
\label{sec:plonk_supp_mat}

\newcommand{\vql}{\vec{q_{L}}}
\newcommand{\vqr}{\vec{q_{R}}}
\newcommand{\vqm}{\vec{q_{M}}}
\newcommand{\vqo}{\vec{q_{O}}}
\newcommand{\vx}{\vec{x}}
\newcommand{\vqc}{\vec{q_{C}}}
\subsection{Plonk protocol description}
\label{sec:plonk_explained}
\oursubsub{The constrain system}
Assume $\CRKT$ is a fan-in two arithmetic circuit,
which fan-out is unlimited and has $\numberofconstrains$ gates and $\noofw$ wires
($\numberofconstrains \leq \noofw \leq 2\numberofconstrains$). \plonk's constraint
system is defined as follows:
\begin{itemize}
\item Let $\vec{V} = (\va, \vb, \vc)$, where $\va, \vb, \vc
  \in \range{1}{\noofw}^\numberofconstrains$. Entries $\va_i, \vb_i, \vc_i$ represent indices of left,
  right and output wires of circuits $i$-th gate.
\item Vectors $\vec{Q} = (\vql, \vqr, \vqo, \vqm, \vqc) \in
  (\FF^\numberofconstrains)^5$ are called \emph{selector vectors}:
  \begin{itemize}
  \item If the $i$-th gate is a multiplicative gate then $\vql_i = \vqr_i = 0$,
    $\vqm_i = 1$, and $\vqo_i = -1$. 
  \item If the $i$-th gate is an addition gate then $\vql_i = \vqr_i  = 1$, $\vqm_i =
    0$, and $\vqo_i = -1$. 
  \item $\vqc_i = 0$ always. 
  \end{itemize}
\end{itemize}

We say that vector $\vx \in \FF^\noofw$ satisfies constraint system if for all $i
\in \range{1}{\numberofconstrains}$
\[
  \vql_i \cdot \vx_{\va_i} + \vqr_i \cdot \vx_{\vb_i} + \vqo \cdot \vx_{\vc_i} +
  \vqm_i \cdot (\vx_{\va_i} \vx_{\vb_i}) + \vqc_i = 0. 
\]

\oursubsub{Algorithms rolled out}
\label{sec:plonk_explained}
\plonk{} argument system is universal. That is, it allows to verify computation
of any arithmetic circuit which has no more than $\numberofconstrains$
gates using a single SRS. However, to make computation efficient, for each
circuit there is allowed a preprocessing phase which extend the SRS with
circuit-related polynomial evaluations.

For the sake of simplicity of the security reductions presented in this paper, we
include in the SRS only these elements that cannot be computed without knowing
the secret trapdoor $\chi$. The rest of the SRS---the preprocessed input---can
be computed using these SRS elements thus we leave them to be computed by the
prover, verifier, and simulator.

\ourpar{$\plonk$ SRS generating algorithm $\kgen(\REL)$:}
The SRS generating algorithm picks at random $\chi \sample \FF_p$, computes
and outputs
\[
	\srs = \left(\gone{\smallset{\chi^i}_{i = 0}^{\numberofconstrains + 2}},
	\gtwo{\chi} \right).
\]

\ourpar{Preprocessing:}
Let $H = \smallset{\omega^i}_{i = 1}^{\numberofconstrains }$ be a
(multiplicative) $\numberofconstrains$-element subgroup of a field $\FF$
compound of $\numberofconstrains$-th roots of unity in $\FF$. Let $\lag_i(X)$ be
the $i$-th element of an $\numberofconstrains$-elements Lagrange basis. During
the preprocessing phase polynomials $\p{S_{id j}}, \p{S_{\sigma j}}$, for
$\p{j} \in \range{1}{3}$, are computed:
\begin{equation*}
  \begin{aligned}
    \p{S_{id 1}}(X) & = X,\vphantom{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),}\\
    \p{S_{id 2}}(X) & = k_1 \cdot X,\vphantom{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),}\\
    \p{S_{id 3}}(X) & = k_2 \cdot X,\vphantom{\sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),}
  \end{aligned}
  \qquad
\begin{aligned}
  \p{S_{\sigma 1}}(X) & = \sum_{i = 1}^{\noofc} \sigma(i) \lag_i(X),\\
  \p{S_{\sigma 2}}(X) & = \sum_{i = 1}^{\noofc}
  \sigma(\noofc + i) \lag_i(X),\\
  \p{S_{\sigma 3}}(X) & =\sum_{i = 1}^{\noofc} \sigma(2 \noofc + i) \lag_i(X).
\end{aligned}
\end{equation*}
Coefficients $k_1$, $k_2$ are such that $H, k_1 \cdot H, k_2 \cdot H$ are
different cosets of $\FF^*$, thus they define $3 \cdot \noofc$
different elements. \cite{EPRINT:GabWilCio19} notes that it is enough to set
$k_1$ to a quadratic residue and $k_2$ to a quadratic non-residue.

Furthermore, we define polynomials $\p{q_L}, \p{q_R}, \p{q_O}, \p{q_M}, \p{q_C}$
such that
\begin{equation*}
  \begin{aligned}
  \p{q_L}(X) & = \sum_{i = 1}^{\noofc} \vql_i \lag_i(X), \\
  \p{q_R}(X) & = \sum_{i = 1}^{\noofc} \vqr_i \lag_i(X), \\
  \p{q_M}(X) & = \sum_{i = 1}^{\noofc} \vqm_i \lag_i(X),
\end{aligned}
\qquad
\begin{aligned}
  \p{q_O}(X) & = \sum_{i = 1}^{\noofc} \vqo_i \lag_i(X), \\
  \p{q_C}(X) & = \sum_{i = 1}^{\noofc} \vqc_i \lag_i(X). \\
  \vphantom{\p{q_M}(X)  = \sum_{i = 1}^{\noofc} \vqm_i \lag_i(X),}
\end{aligned}
\end{equation*}

\ourpar{$\plonk$ prover
  $\prover(\srs, \inp, \wit = (\wit_i)_{i \in \range{1}{3 \cdot
      \noofc}})$.}
\begin{description}
\item[Round 1] Sample $b_1, \ldots, b_9 \sample \FF_p$; compute
  $\p{a}(X), \p{b}(X), \p{c}(X)$ as
	\begin{align*}
		\p{a}(X) &= (b_1 X + b_2)\p{Z_H}(X) + \sum_{i = 1}^{\noofc} \wit_i \lag_i(X) \\
		\p{b}(X) &= (b_3 X + b_4)\p{Z_H}(X) + \sum_{i = 1}^{\noofc} \wit_{\noofc + i} \lag_i(X) \\
		\p{c}(X) &= (b_5 X + b_6)\p{Z_H}(X) + \sum_{i = 1}^{\noofc} \wit_{2 \cdot \noofc + i} \lag_i(X) 
	\end{align*}
	Output polynomial commitments $\gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi)}$.
	
	\item[Round 2]
	Get challenges $\beta, \gamma \in \FF_p$
	\[
		\beta = \ro(\zkproof[0..1], 0)\,, \qquad \gamma = \ro(\zkproof[0..1], 1)\,.
	\]
	Compute permutation polynomial $\p{z}(X)$
	\begin{multline*}
		\p{z}(X) = (b_7 X^2 + b_8 X + b_9)\p{Z_H}(X) + \lag_1(X) + \\
			+ \sum_{i = 1}^{\noofc - 1} 
			\left(\lag_{i + 1} (X) \prod_{j = 1}^{i} 
			\frac{
			(\wit_j +\beta \omega^{j - 1} + \gamma)(\wit_{\noofc + j} + \beta k_1 \omega^{j - 1} + \gamma)(\wit_{2 \noofc + j} +\beta k_2 \omega^{j- 1} + \gamma)}
			{(\wit_j+\sigma(j) \beta + \gamma)(\wit_{\noofc + j} + \sigma(\noofc + j)\beta + \gamma)(\wit_{2 \noofc + j} + \sigma(2 \noofc + j)\beta + \gamma)}\right)
	\end{multline*}
	Output polynomial commitment $\gone{\p{z}(\chi)}$
		
	\item[Round 3]
	Get the challenge $\alpha = \ro(\zkproof[0..2])$, compute the quotient polynomial 
	\begin{align*}
	& \p{t}(X)  = \\
	& (\p{a}(X) \p{b}(X) \selmulti(X) + \p{a}(X) \selleft(X) + 
	\p{b}(X)\selright(X) + \p{c}(X)\seloutput(X) + \pubinppoly(X) + \selconst(X)) 
	\frac{1}{\p{Z_H}(X)} +\\
	& + ((\p{a}(X) + \beta X + \gamma) (\p{b}(X) + \beta k_1 X + \gamma)(\p{c}(X) 
	+ \beta k_2 X + \gamma)\p{z}(X)) \frac{\alpha}{\p{Z_H}(X)} \\
	& - (\p{a}(X) + \beta \p{S_{\sigma 1}}(X) + \gamma)(\p{b}(X) + \beta 
	\p{S_{\sigma 2}}(X) + \gamma)(\p{c}(X) + \beta \p{S_{\sigma 3}}(X) + 
	\gamma)\p{z}(X \omega))  \frac{\alpha}{\p{Z_H}(X)} \\
	& + (\p{z}(X) - 1) \lag_1(X) \frac{\alpha^2}{\p{Z_H}(X)}
	\end{align*}
	Split $\p{t}(X)$ into degree less then $\noofc$ polynomials $\p{t_{lo}}(X), \p{t_{mid}}(X), \p{t_{hi}}(X)$, such that
	\[
		\p{t}(X) = \p{t_{lo}}(X) + X^{\noofc} \p{t_{mid}}(X) + X^{2 \noofc} \p{t_{hi}}(X)\,.
	\]
	Output $\gone{\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)}$.
	
	\item[Round 4]
	Get the challenge $\chz \in \FF_p$, $\chz = \ro(\zkproof[0..3])$.
	Compute opening evaluations
	\begin{align*}
      \p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega),
	\end{align*}
	Compute the linearisation polynomial
	\[
		\p{r}(X) = 
		\begin{aligned}
      & \p{a}(\chz) \p{b}(\chz) \selmulti(X) + \p{a}(\chz) \selleft(X) + \p{b}(\chz) \selright(X) + \p{c}(\chz) \seloutput(X) + \selconst(X) \\
      & + \alpha \cdot \left( (\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma)(\p{c}(\chz) + \beta k_2 \chz + \gamma) \cdot \p{z}(X)\right) \\
      & - \alpha \cdot \left( (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma)\beta \p{z}(\chz\omega) \cdot \p{S_{\sigma 3}}(X)\right) \\
      & + \alpha^2 \cdot \lag_1(\chz) \cdot \p{z}(X)
		\end{aligned}
	\]
	Output $\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega), \p{r}(\chz).$
	
	\item[Round 5]
	Compute the opening challenge $v \in \FF_p$, $v = \ro(\zkproof[0..4])$.
	Compute the openings for the polynomial commitment scheme 
	\begin{align*}
	& \p{W_\chz}(X) = \frac{1}{X - \chz} \left(
	\begin{aligned}
		& \p{t_{lo}}(X) + \chz^\noofc \p{t_{mid}}(X) + \chz^{2 \noofc} \p{t_{hi}}(X) - \p{t}(\chz)\\
		& + v(\p{r}(X) - \p{r}(\chz)) \\
		& + v^2 (\p{a}(X) - \p{a}(\chz))\\
		& + v^3 (\p{b}(X) - \p{b}(\chz))\\
		& + v^4 (\p{c}(X) - \p{c}(\chz))\\
		& + v^5 (\p{S_{\sigma 1}}(X) - \p{S_{\sigma 1}}(\chz))\\
		& + v^6 (\p{S_{\sigma 2}}(X) - \p{S_{\sigma 2}}(\chz))
	\end{aligned}
	\right)\\
	& \p{W_{\chz \omega}}(X) = \frac{\p{z}(X) - \p{z}(\chz \omega)}{X - \chz \omega}
\end{align*}
	Output $\gone{\p{W_{\chz}}(\chi), \p{W_{\chz \omega}}(\chi)}$.
\end{description}

\ncase{$\plonk$ verifier $\verifier(\srs, \inp, \zkproof)$}\ \newline
The \plonk{} verifier works as follows
\begin{description}
	\item[Step 1] Validate all obtained group elements.
	\item[Step 2] Validate all obtained field elements.
	\item[Step 3] Validate the instance
      $\inp = \smallset{\wit_i}_{i = 1}^\instsize$.
	\item[Step 4] Compute challenges $\beta, \gamma, \alpha, \chz, v,
      u$ from the transcript.
	\item[Step 5] Compute zero polynomial evaluation
      $\p{Z_H} (\chz) =\chz^\noofc - 1$.
	\item[Step 6] Compute Lagrange polynomial evaluation
      $\lag_1 (\chz) = \frac{\chz^\noofc -1}{\noofc (\chz - 1)}$.
	\item[Step 7] Compute public input polynomial evaluation
      $\pubinppoly (\chz) = \sum_{i \in \range{1}{\instsize}} \wit_i
      \lag_i(\chz)$.
	\item[Step 8] Compute quotient polynomials evaluations
	\begin{multline*}
    \p{t} (\chz) = \frac{1}{\p{Z_H}(\chz)} \Big(
    \p{r} (\chz) + \pubinppoly(\chz) - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \\
    (\p{c}(\chz) + \gamma)\p{z}(\chz \omega) \alpha - \lag_1 (\chz) \alpha^2
    \Big) \,.
	\end{multline*}
	\item[Step 9] Compute batched polynomial commitment
	$\gone{D} = v \gone{r} + u \gone {z}$ that is
	\begin{align*}
		\gone{D} & = v
		\left(
		\begin{aligned}
          & \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}  \gone{\selright} + \p{c}  \gone{\seloutput} + \\
          & + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
			% &   \\
          & - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz)
          + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha \beta \p{z}(\chz
          \omega) \gone{\p{S_{\sigma 3}}(\chi)})
		\end{aligned}
		\right) + \\
		& + u \gone{\p{z}(\chi)}\,.
	\end{align*}
	\item[Step 10] Computes full batched polynomial commitment $\gone{F}$:
	\begin{align*}
      \gone{F} & = \left(\gone{\p{t_{lo}}(\chi)} + \chz^\noofc \gone{\p{t_{mid}}(\chi)} + \chz^{2 \noofc} \gone{\p{t_{hi}}(\chi)}\right) + u \gone{\p{z}(\chi)} + \\
               & + v
                 \left(
		\begin{aligned}
			& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}(\chz)   \gone{\selright} + \p{c}(\chz)  \gone{\seloutput} + \\
			& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c}(\chz)  + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
			% &   \\
			& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha  \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)})
		\end{aligned}
		\right) \\
		& + v^2 \gone{\p{a}(\chi)} + v^3 \gone{\p{b}(\chi)} + v^4 \gone{\p{c}(\chi)} + v^5 \gone{\p{S_{\sigma 1}(\chi)}} + v^6 \gone{\p{S_{\sigma 2}}(\chi)}\,.
	\end{align*}
	\item[Step 11] Compute group-encoded batch evaluation $\gone{E}$
	\begin{align*}
		\gone{E}  = \frac{1}{\p{Z_H}(\chz)} & \gone{
		\begin{aligned}
			& \p{r}(\chz) + \pubinppoly(\chz) +  \alpha^2  \lag_1 (\chz) + \\
			& - \alpha \left( (\p{a}(\chz) + \beta \p{S_{\sigma 1}} (\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}} (\chz) + \gamma) (\p{c}(\chz) + \gamma) \p{z}(\chz \omega) \right)
		\end{aligned}
           }\\
      + & \gone{v \p{r}(\chz) + v^2 \p{a}(\chz) + v^3 \p{b}(\chz) + v^4 \p{c}(\chz) + v^5 \p{S_{\sigma 1}}(\chz) + v^6 \p{S_{\sigma 2}}(\chz) + u \p{z}(\chz \omega) }\,.
	\end{align*}
\item[Step 12] Check whether the verification
 % $\vereq_\zkproof(\chi)$
  equation holds
	\begin{multline}
		\label{eq:ver_eq}
		\left( \gone{\p{W_{\chz}}(\chi)} + u \cdot \gone{\p{W_{\chz
                \omega}}(\chi)} \right) \bullet
		\gtwo{\chi} - %\\
		\left( \chz \cdot \gone{\p{W_{\chz}}(\chi)} + u \chz \omega \cdot
          \gone{\p{W_{\chz \omega}}(\chi)} + \gone{F} - \gone{E} \right) \bullet
        \gtwo{1} = 0\,.
	\end{multline}
  The verification equation is a batched version of the verification equation
  from \cite{AC:KatZavGol10} which allows the verifier to check openings of
  multiple polynomials in two points (instead of checking an opening of a single
  polynomial at one point).
\end{description}

\ncase{$\plonk$ simulator $\simulator_\chi(\srs, \td= \chi, \inp)$}\ \newline
The \plonk{} simulator proceeds as an honest prover would, except:
\begin{enumerate}
  \item In the first round, it sets $\wit = (\wit_i)_{i \in \range{1}{3 \noofc}}
    = \vec{0}$, and at random picks $b_1, \ldots, b_9$. Then it proceeds with
    that all-zero witness.
  \item In Round 3, it computes polynomial $\pt(X)$ honestly, however uses
    trapdoor $\chi$ to compute commitments
    $\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)$.
  \end{enumerate}

  \subsection{Trapdoor-less simulatability of Plonk}
\label{sec:plonk-tls-proof}
\begin{proof}
  As noted in \cref{def:upd-scheme}, subvertible zero knowledge implies updatable zero
  knowledge. Hence, here we show that Plonk is TLS even against algebraic adversaries who picks
  the SRS on its own.
  
  The proof goes by game-hopping. The environment that controls the games
  provides starts the adversary who sets a SRS $\srs$, then the adversary outputs an
  instance--witness pair $(\inp, \wit)$ and, depending on the game, is provided
  with either real or simulated proof for it. In the end of the game the
  adversary outputs either $0$ if it believes that the proof it saw was provided
  by the simulator and $1$ in the other case.

  \ngame{0} In this game $\adv(\secparam)$ picks an SRS $\srs$ and instance--witness pair
  $(\inp, \wit)$ and gets a real proof $\zkproof$ for it.

  \ngame{1} In this game for $\adv(\secparam)$ picks an SRS $\srs$ and an instance--witness pair
  $(\inp, \wit)$ and gets a proof $\zkproof$ that is simulated by a simulator
  $\simulator_\chi$ which utilises for the simulation the SRS trapdoor and
  proceeds as described in \cref{sec:plonk_explained}.

  \ncase{Game 0 to Game 1} Since $\plonk$ is (subvertible) zero-knowledge,
  probability that $\adv$ outputs a different bit in both games is negligible.
  Hence
  \(
	\abs{\prob{\game{0}} - \prob{\game{1}}} \leq \epszk(\secpar).
\)

\ngame{2} In this game $\adv(\secparam)$ picks an SRS $\srs$ and instance--witness pair
$(\inp, \wit)$ and gets a proof $\zkproof$ simulated by the simulator
$\simulator$ which proceeds as follows.

In Round 1 the simulator  picks randomly both the randomisers $b_1, \ldots, b_6$ and
sets $\wit_i = 0$ for $i \in \range{1}{3\noofc}$. Then $\simulator$
outputs $\gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi)}$. For the first round
challenge, the simulator picks permutation argument challenges $\beta, \gamma$
randomly.

In Round 2, the simulator computes $\p{z}(X)$ from
the newly picked randomisers $b_7, b_8, b_9$ and coefficients of polynomials
$\p{a}(X), \p{b}(X), \p{c}(X)$. Then it evaluates $\p{z}(X)$ honestly and outputs
$\gone{\p{z}(\chi)}$. Challenge $\alpha$ that should be sent by the verifier
after Round 2 is picked by the simulator at random.

In Round 3 the simulator starts by picking at random a challenge $\chz$, which
in the real proof comes as a challenge from the verifier sent \emph{after} Round
3. Then $\simulator$ computes evaluations
\(\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma
    2}}(\chz), \pubinppoly(\chz), \lag_1(\chz), \p{Z_H}(\chz),\allowbreak
\p{z}(\chz\omega)\) and computes $\p{t}(X)$ honestly. Since for a random
$\p{a}(X), \p{b}(X), \p{c}(X), \p{z}(X)$ the constraint system is (with
overwhelming probability) not satisfied and the constraints-related polynomials
are not divisible by $\p{Z_H}(X)$, hence $\p{t}(X)$ is a rational function
rather than a polynomial. Then, the simulator evaluates $\p{t}(X)$ at $\chz$ and
picks randomly a degree-$(3 \noofc - 1)$ polynomial $\p{\tilde{t}}(X)$ such that
$\p{t}(\chz) = \p{\tilde{t}}(\chz)$ and publishes a commitment
$\gone{\p{\tilde{t}_{lo}}(\chi), \p{\tilde{t}_{mid}}(\chi),
  \p{\tilde{t}_{hi}}(\chi)}$. After this round the simulator outputs $\chz$ as a
challenge.

In the next round, the simulator computes polynomial $\p{r}(X)$ as an honest
prover would, cf.~\cref{sec:plonk_explained} and evaluates $\p{r}(X)$ at $\chz$.

The rest of the evaluations are already computed, thus $\simulator$ simply
outputs
\(
  \p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma
      2}}(\chz), \p{t}(\chz), \p{z}(\chz \omega)\,.
\)
After that it picks randomly the challenge $v$, proceeds in the last round as an
honest prover would proceed and outputs the final challenge, $u$, by picking it
at random as well.

\ncase{Game 1 to Game 2} We now describe the reduction $\rdv$ which
relies on the $(\pR, \pS, \pT, \pF, 1)$-uber assumption, cf.~\cref{sec:uber_assumption}
where $\pR, \pS, \pT, \pF$ are polynomials over variables
$\vB = B_1, \ldots, B_9$ and are defined as follows. Let
$E = \smallset{\smallset{2}, \smallset{3, 4}, \smallset{5, 6}, \smallset{7, 8,
    9}}$ and $E' = E \setminus \smallset{2}$. Let
\begin{align}
\label{eq:uber}
\pF(\vB) & = \smallset{B_1} \cup \smallset{B_1B_i \mid i \in A,\ A \in E'} \cup
             \smallset{B_1B_iB_j \mid i \in A, j \in B,\ A, B \in E', B
             \neq A} \cup \notag\\
           & \smallset{B_1B_iB_jB_k \mid i \in A, j \in
             B, k \in C,\ A, B, C \in E', A \neq B \neq C \neq A}\notag\,,\\
  \pR(\vB) & = \smallset{B_i \mid i \in A,\ A \in E} \cup \smallset{B_i B_j \mid i \in
             A, j \in B,\ A \neq B, A, B \in E} \cup \\ 
           & \smallset{B_i B_j B_k \mid i \in A,\ j \in
             B,\ k \in C,\
             A, B, C \text{ all different and in } E} \cup \notag \\
           & \smallset{B_i B_j B_k B_l \mid i \in A,\ j \in B,\ k \in C,\ l \in D,\
             A, B, C, D \text{ all different and in } E} \notag \\
           & \setminus \pF(\vB)\,,\notag \\
  \pS(\vB) & = \emptyset, \qquad \pT(\vB) = \emptyset.
\end{align}
That is, the elements of $\pR$ are all singletons, pairs, triplets and
quadruplets of $B_i$ variables that occur in polynomial $\pt(\vB)$ except the
challenge element $\pf(\vB)$ which are all elements that depends on a variable
$B_1$. Variables $\vB$ are evaluated to randomly picked
$\vb = b_1, \ldots, b_9$.

The reduction $\rdv$ learns $\gone{\pR}$ and challenge
$\gone{\vec{w}} = \gone{w_1, \ldots, w_{12}}$ where $\vec{w}$ is either a vector
of evaluations $\pF(\vb)$ or a sequence of random values $y_1, \ldots, y_{12}$,
for the sake of concreteness we state $w_1 = b_1$ or $w_1 = y_1$ (depending on
the chosen random bit).

Then it starts $\adv$ and learns $\srs$, since $\adv$ is algebraic, the reduction also learns trapdoor $\chi$. Then $\rdv$ picks $\chz$. Elements $b_i$ are interpreted as polynomials in $X$ that are
evaluated at $\chi$, i.e. $b_i = b_i(\chi)$. Next, $\rdv$ sets for
$\xi_i, \zeta_i \sample \FF_p$
\(
  \gone{\p{\tb}_1(X)} =
(X - \chz)(X - \ochz) \gone{w_1}(X) + \xi_i (X - \chz) \gone{1} +
\zeta_i (X - \ochz) \gone{1}, % \text{ for } i \in % \range{1}{9}, u_1
\),
and
\(
  \gone{\p{\tb}_i(X)} =
(X - \chz)(X - \ochz) \gone{b_i}(X) + \xi_i (X - \chz) \gone{1} +
\zeta_i (X - \ochz) \gone{1}, % \text{ for } i \in % \range{1}{9}, u_1
\) 
for $i \in \range{2}{9}$.

Denote by $\tb_i$ evaluations of $\p{\tb}_i$ at $\chi$.  The reduction computes
all
$\gone{\tb_i \tb_j}, \gone{\tb_i \tb_j \tb_k}, \gone{\tb_i \tb_j \tb_k \tb_l}$
such that $\gone{B_i B_j, B_i B_j B_k, B_i B_j B_k B_l} \in \pR$.  This is
possible since $\rdv$ knows all singletons $\gone{w_1, b_2, \ldots, b_9}$ and pairs
$\gone{b_i b_j} \in \pR$ which can be used to compute all required pairs
$\gone{\tb_i \tb_j}$:
\begin{align*}
\gone{\tb_i \tb_j} 
& = ((\chi - \chz)(\chi - \ochz)\gone{b_i} + \xi_i (\chi - \chz)\gone{1} +
\zeta_i (\chi - \ochz) \gone{1}) 
\cdot \\
 & ((\chi - \chz)(\chi - \ochz)\gone{b_j} + \xi_j (\chi - \chz)\gone{1} +
\zeta_j (\chi - \ochz) \gone{1}) = \\
 & ((\chi - \chz)(\chi - \ochz))^2 \gone{b_i b_j} +  ((\chi - \chz)(\chi -
 \ochz)\gone{b_i} (\xi_j (\chi - \chz) \gone{1} + \zeta_j (\chi - \ochz)
 \gone{1}) + \\
 & ((\chi - \chz)(\chi -
 \ochz)\gone{b_j} (\xi_i (\chi - \chz) \gone{1} + \zeta_i (\chi - \ochz)
 \gone{1}) + \psi,
\end{align*}
where $\psi$ compounds of $\xi_i, \xi_j, \zeta_i, \zeta_j, \chz, \ochz, \chi$ which
are all known by $\rdv$ and no $b_i$ nor $b_j$.
Analogously for the triplets and quadruplets and elements dependent on~$\vec{w}$. 

Next the reduction obtains from $\adv$ an instance--witness pair $(\inp, \wit)$.  $\rdv$ now
prepares a simulated proof as follows:
\begin{compactdesc} 
\item[Round 1] $\rdv$ computes $\gone{\pa(\chi)}$ using as
randomisers $\gone{\tb_1}, \gone{\tb_2}$ and setting $\wit_i = 0$, for $i
\in \range{1}{3 \noofc}$. Similarly it computes
$\gone{\pb(\chi)}, \gone{\pc(\chi)}$.  $\rdv$ publishes the obtained values
and picks a Round 1 challenge $\beta, \gamma$ at random.  Note that regardless
$w_1 = b_1$ or a random element, $\gone{a(\chi)}$ is random. Thus $\rdv$'s
output has the same distribution as output of a real prover.  
\item[Round 2]
$\rdv$ computes $\gone{\pz(\chi)}$ using $\tb_7, \tb_8, \tb_9$ and publishes
it. Then it picks randomly the challenge $\alpha$. This round output is
independent on $b_1$ thus $\rdv$'s output is indistinguishable from the prover's. 
\item[Round 3] The reduction computes
  $\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)$, which all depend on
  $b_1$. To that end $\gone{\tb_1}$ is used. Note that if $\vec{w}$ is a vector
  of $\pF(b_1, \ldots, b_9)$ evaluations then
  $\gone{\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)}$ is the same as
  the real prover's. Alternatively, if $\vec{w}$ is a vector of random values,
  then $\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)$ are all random
  polynomials which evaluates at $\chz$ to the same value as the polynomials
  computed by the real prover. That is, in that case
  $\p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi)$ are as the simulator
  $\simulator$ would compute. Eventually, $\rdv$ outputs $\chz$.
\item[Round 4] The reduction outputs
  $\pa(\chz), \pb(\chz), \pc(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}
    (\chz)}, \pt(\chz), \pz(\ochz)$.  For the sake of concreteness, denote by
  $S = \smallset{\pa, \pb, \pc, \pt, \pz}$. Although for a polynomial
  $\p{p} \in S$, reduction $\rdv$ does not know $\p{p}(\chi)$ or even do not
  know all the coefficients of $\p{p}$, the polynomials in $S$ was computed such
  that the reduction always knows their evaluation at $\chz$ and $\ochz$.
\item[Round 5] $\rdv$ computes the openings of the polynomial commitments
assuring that evaluations at $\chz$ it provided were computed honestly.
\end{compactdesc}

If the adversary $\adv$'s output distribution differ in Game $\game{1}$ and
$\game{2}$ then the reduction uses it to distinguish between
$\vec{w} = \pF(b_1, \ldots, b_9)$ and $\vec{w}$ being random, thus
\( \abs{\prob{\game{1}} - \prob{\game{2}}} \leq \epsuber(\secpar).  \) Eventually,
\(
\abs{\prob{\game{0}} - \prob{\game{2}}} \leq \epszk(\secpar) + \epsuber(\secpar).  \) \qed
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
