\documentclass[aspectratio=169,handout]{beamer}
\usetheme{boxes}
\usefonttheme{professionalfonts,structurebold}
\usecolortheme{dove}

\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}
\usepackage[capitalise]{cleveref}
\usepackage{scrextend}
\changefontsizes{9pt}

\usepackage{tikz}
\usetikzlibrary{positioning,arrows}

\title{Non malleability of the Fiat-Shamir transformation}
\author{\scriptsize{Michal Zajac \inst{1} \and Markulf Kohlweiss \inst{2}}}
\institute{\inst{1} Clearmatics \inst{2}IOHK}
\date{}

\include{macros}
\renewcommand{\emph}[1]{\textbf{#1}}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
  % \frametitle{Prior our work}
  \begin{block}{Some background}
    Most efficient \emph{universal} or \emph{updatable} zkSNARKs use random-oracle
  \end{block}\pause  

  \begin{block}{Prior state-of-the-art}
    %\begin{itemize}
    %\item
    Proven security of the \emph{interactive} proof system
    % \item

    Security of the \emph{non-interactive} variant conjectured
      relying on Fiat--Shamir transformation
    %\end{itemize}
  \end{block}\pause

  \begin{block}{Problems}
    Fiat--Shamir transformation relies on \emph{forking lemma}

    Forking lemma shown secure only for a narrow class of protocols
    that \emph{requires only a single rewinding}

    Not a case for any known zkSNARK
  \end{block}\pause

  \begin{block}{The result}
    Generalized Fiat--Shamir transformation to work with wider class of protocols
    
     Shown that a wide class of RO-based zkSNARKs are
     simulation-extractable \emph{out-of-the-box}
     
     This includes: Plonk, Sonic, some variants of Marlin
  \end{block}
\end{frame}

\section{Fiat--Shamir transformation}
\begin{frame}
  \frametitle{$\Sigma$-protocols}
  \begin{columns}
    \begin{column}{.3\linewidth}
      \begin{tikzpicture}
        \draw (0, 0) node (prover) {$\prover(\inp, \wit)$}; \draw (2, 0) node
        (verifier) {$\verifier(\inp)$}; \draw[thick,->] (0, -1) --
        node[anchor=south] {$a$} (2, -1); \draw[thick,->] (2, -2) --
        node[anchor=south] {$b$} (0, -2); \draw[thick,->] (0, -3) --
        node[anchor=south] {$c$} (2, -3);
      \end{tikzpicture}
    \end{column}
    \begin{column}{.6\linewidth}
      \begin{block}{Completeness}
        Honest verifier accepts proof from an honest prover.
      \end{block}
      \begin{block}{Special soundness}
        Given two transcripts for instance $(\inp, a, b, c)$ and
        $(\inp, a, b', c')$ one can compute witness $\wit$.
      \end{block}
      \begin{block}{Honest verifier zero knowledge}
        The protocol is zero-knowledge if the verifier picks its challenges randomly.
      \end{block}
      \begin{block}{Public coin}
        The verifier's challenges are public function of its randomness.
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{$\Sigma$-protocols -- Fiat--Shamir transformation}
  \begin{columns}
    \begin{column}{.3\linewidth}
      \begin{tikzpicture}
        \draw (0, 0) node (prover) {$\prover(\inp, \wit)$}; \draw (2, 0) node
        (verifier) {$\verifier(\inp)$};
        \draw[thick,->] (0, -1) -- node[anchor=south] {$a$} (2, -1);
        \draw[thick,->] (2, -2) -- node[anchor=south] {$\ro(\inp, a)$} (0, -2);
        \draw[thick,->] (0, -3) -- node[anchor=south] {$c$} (2, -3);
      \end{tikzpicture}
    \end{column}
    \begin{column}{.6\linewidth}
      \begin{block}{Completeness}
        Honest verifier accepts proof from an honest prover.
      \end{block}
      \begin{block}{Special soundness}
        Given two transcripts for instance $(\inp, a, b, c)$ and $(\inp, a, b',
        c')$ one can compute witness $\wit$.
      \end{block}
      \begin{block}{Honest verifier zero knowledge}
        The protocol is zero-knowledge if the verifier picks its challenges randomly.
      \end{block}
      \fbox{\parbox{5cm}{
      \begin{block}{Public coin}
        The verifier's challenges are public function of its randomness.
      \end{block}
    }}
    \end{column}
  \end{columns}
\end{frame}

\newcommand{\advfs}{\adv_\fs}
\renewcommand{\myskip}{0.5\baselineskip}

\begin{frame}[t]
  \frametitle{Soundness of the Fiat--Shamir transformation}
  \begin{columns}
    \begin{column}{0.7\linewidth}
  \begin{block}{How to get two transcripts from $\advfs$}
    Get one transcript $(\inp, a, b = \ro(\inp, a), c)$.\\
    Rewind $\advfs$ after it sent $a$.\\
    Pick new $\ro$ response for $\ro(\inp, a)$
  \end{block}
  \begin{block}{Problem}
    $\adv$ has \emph{one shot} to convince the verifier $\verifier$.

    If $\advfs$ does not like $\verifier$'s challenge, it may pick \emph{another}
    instance $\inp$ or $a$ and try again.\\[\myskip]
    The reduction needs to \emph{guess} which random oracle call is going to be
    used in the final proof.\\
    If $\advfs$ makes $Q$ querties, this probability is $\frac{1}{Q}$.
  \end{block}

  \begin{block}{Proof overview}
    Assume $\PS$ is sound. We show that $\PS_\fs$ is sound as well.\\[\myskip]
    Reduction $\rdv$ internally runs $\advfs$ and talks to $\PS.\verifier$.\\
    If $\advfs$ is successful in breaking soundness of $\PS_\fs$, then $\rdv$ is
    successful in breaking soundness of $\PS$.
  \end{block}
\end{column}
\begin{column}{0.3\linewidth}
  \begin{tikzpicture}
    \draw (0, 0) node (reduction) {$\rdv$};
    \draw (2, 0) node 
    (verifier) {$\verifier(\inp)$}; \draw[thick,->] (0, -1) --
    node[anchor=south] {$a$} (2, -1); \draw[thick,->] (2, -2) --
    node[anchor=south] {$b$} (0, -2); \draw[thick,->] (0, -3) --
    node[anchor=south] {$c$} (2, -3);
  \end{tikzpicture}
\end{column}
\end{columns}
\end{frame}

\iffalse
\begin{frame}[t]
  \frametitle{Security of the Fiat--Shamir transformation}
  \begin{block}{}
    \begin{columns}
      \begin{column}{.4\linewidth}
        Let $\ps = (\prover, \verifier)$ be a $\Sigma$-protocol which
        transcript consists of
        \begin{itemize}
        \item instance $\inp$
        \item prover's message $a$
        \item \fbox{verifier's challenge $b$}
        \item prover's answer $c$
        \end{itemize}
      \end{column}\pause
      \begin{column}{.4\linewidth}
        Let $\psfs$ be a variant of $\ps$ which transcript consists of
        \begin{itemize}
        \item instance $\inp$
        \item prover's message $a$
        \item \fbox{\parbox{3cm}{verifier's challenge $b = \ro(\inp, a)$}}
        \item prover's answer $c$
        \end{itemize}
      \end{column}
    \end{columns}\pause
    
    Then $\psfs$ is sound and zero-knowledge.
  \end{block}

  \begin{block}{}
    \centering
    \fbox{The above says nothing about \emph{multiround} protocols!}
  \end{block}
\end{frame}
\fi
\begin{frame}
  \frametitle{Security of FS transformation---forking lemma}
  \begin{lemma}[General forking lemma, cf.~\cite{INDOCRYPT:FKMV12,CCS:BelNev06}]
    \label{lem:forking_lemma}
    \begin{columns}
      \begin{column}{.5\linewidth}
	Fix $q \in \ZZ$ and a set $H$ of size $h > 2$. Let $\zdv$ be a $\ppt$
  algorithm that on input $y, h_1, \ldots, h_q$ returns $(i, s)$, where $i
  \in\range{0}{q}$ and $s$ is called a \emph{side output}. Denote by $\ig$ a
  randomised instance generator. We denote by $\accProb$ the probability
	\[
		\condprob{i > 0}{y \gets \ig; h_1, \ldots, h_q \sample H; (i, s) \gets
		\zdv(y, h_1, \ldots, h_q)}\,.
	\]
	Let $\forking_\zdv(y)$ denote the algorithm described in
  \cref{fig:forking_lemma}, then the probability $\frkProb$ defined as $
  \frkProb := \condprob{b = 1}{y \gets \ig; (b, s, s') \gets \forking_{\zdv}(y)}
  $ holds
	\[
		\frkProb \geq \accProb \brak{\frac{\accProb}{q} - \frac{1}{h}}\,.
	\]
      \end{column}
      \begin{column}{.4\linewidth}
	\begin{figure}
		\centering
		\fbox{
		\procedure{$\forking_\zdv (y)$}
		{
			\rho \sample \RND{\zdv}\\
			h_1, \ldots, h_q \sample H\\
			(i, s) \gets \zdv(y, h_1, \ldots, h_q; \rho)\\
			\pcif i = 0\ \pcreturn (0, \bot, \bot)\\
			h'_{i}, \ldots, h'_{q} \sample H\\
			(i', s') \gets \zdv(y, h_1, \ldots, h_{i - 1}, h'_{i}, \ldots,  h'_{q};
			\rho)\\
			\pcif (i = i') \land (h_{i} \neq h'_{i})\ \pcreturn (1, s, s')\\
			\pcind \pcelse \pcreturn (0, \bot, \bot)
		}}
		\caption{Forking algorithm $\forking_\zdv$}
		\label{fig:forking_lemma}
              \end{figure}
            \end{column}
            \end{columns}
\end{lemma}

\end{frame}

\end{document}