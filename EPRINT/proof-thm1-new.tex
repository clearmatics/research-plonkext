%!TEX root=main.tex

\begin{theorem}[Simulation-extractable multi-message protocols]
	\label{thm:se}
	Let $\psfs = (\SRScer, \prover, \verifier, \simulator)$ be a NIZK proof system with an updateable SRS setup compiled via the $(2\mu + 1)$-message Fiat--Shamir transformation. Let $\ro$ be the random oracle. If $\psfs$ has the
	$k$-\emph{updatable unique response property} with security loss $\epsur(\secpar)$, 
	\emph{updatable $k$-programmable trapdoor-less zero knowledge}, and $(1, \ldots, 1, n_{k}, \ldots, n_\mu)$-\emph{updatable rewinding-based knowledge soundness} with security loss $\epscss(\secpar)$. 
	
	Then $\psfs$ is \emph{updatable simulation-extractable} with security loss $\epsse(\secpar,\accProb,q) \leq \epscss(\secpar,\accProb - \epsur,q)$ against any $\ppt$ adversary $\advse$ who makes up to $q$ random oracle queries and returns an acceptable proof with probability at least $\accProb$.
\end{theorem}

\begin{proof}	
	Let $(\srs, \inp, \wit) \gets \advse^{\initU, \simOH, \simOP'}(r_{\advse})$ be the USE adversary. We construct an extractor $\extse (\srs, \advse, r_{\advse}, \Qro, \Qsrs, \Qsim)$ that outputs a witness $\wit$, such that $\REL(\inp, \wit)$ holds with high probability. To that end we define an algorithm $\advcss^{\initU,\ro}(r)$ against rewinding-based knowledge soundness of $\psfs$ that runs internally $\advse^{\initU, \simOH, \simOP'}(r_{\advse})$. Here $r = (\rsim, r_{\advse})$. Eventually, we use the rewinding-based knowledge soundness extractor $\extcss$ on $\advcss$ to extract the witness.
	
	Since $\advcss$ runs $\advse$ internally, it needs to take care of $\advse$'s oracle queries.
	$\advse$'s queries to the update oracle $\initU$ are passed to $\advcss$ oracle $\initU$ directly. Also, the answers from $\advcss$'s oracle $\initU$ are returned to $\advse$.
	Queries to the simulator $\simOP'$ are processed by $\advcss$ who computes the proof running simulators $\simOH$ and $\simOP'$ internally using randomness $\rsim$. The latter simulator, $\simOP'$, calls $\simOH$ or $\simOHprog$, when it needs to compute a random oracle challenge. If the challenge is to be computed honestly, then $\simOH$ is called. If the challenge should be programmed, $\simOHprog$ is called, cf.~\cref{fig:real_simulator_oracles}. Importantly, all challenges in simulated proofs, up to round $k$ are computed honestly, i.e. $\zkproof_{i}.\ch = \simOH((\inp, \zkproof_1, \zkproof_1.\ch, \ldots, \zkproof_{i}))$, for $i \leq k$.
%
	$\advse$'s queries to $\simOH$ are not programmed.

	Eventually, $\advse$ outputs a proof $(\inp, \zkproof)$ which $\advcss$ outputs as well. We note that the proof output by $\advcss$ cannot contain any programmed queries as such proof is not acceptable w.r.t~$\ro$. If $\advse$ outputs a proof that does contain programmed challenges, then $\advcss$ aborts. We denote that event by $\event{E}$.
	
	\begin{lemma}
		Probability that $\event{E}$ happens is upper-bounded by $\epsur(\secpar)$. 
	\end{lemma}
	\begin{proof}
	We build an adversary $\advur^{\ro, \initU} (\secpar; r)$ that has access to the random oracle $\ro$ and update oracle $\initU$. $\advur$ uses $\advse$ to break the $\ur{k}$ property of $\ps$. Namely, for randomness $r = (r_{\advse}, \rsim)$, $\advur^{\ro, \initU} (\secpar; r)$ runs $\advse^{\initU, \simOH, \simOP'}(\secparam; r_{\advse})$ internally and answers its oracle queries as $\advcss$ did.

	When $\advse$ makes a proof $\zkproof$ for $\inp_{\advse}$ such that $\event{E}$ holds, $\advur$ looks through lists $Q$ and $Q_\ro$ until it finds $\zkproofs[0..k]$ such that $\zkproof_{\advse}[0..k] = \zkproofs[0..k]$ and a random oracle query $\zkproofs[k].\ch$ on $\zkproofs[0..k]$.	$\advur$ returns two proofs for $\inp_{\advse}$:
		\begin{align*}
		\zkproof_1 = (\zkproofs[1..k],
		\zkproofs[k].\ch, \zkproofs[k + 1..\mu + 1])\\
		\zkproof_2 = (\zkproofs[1..k],
		\zkproofs[k].\ch, \zkproof_{\advse}[k + 1..\mu + 1])
		\end{align*}

	Importantly, both proofs are acceptable w.r.t~the unique response property verifier. The first, since the unique response property definition allows any challenges after $k$. The latter, since it is an acceptable proof produced by the adversary.
	We assume that $\zkproof_1 \neq \zkproof_2$ as in the opposite case the $\advse$ would not be able to break the simulation extractability game as $\zkproof_2 \in Q$. On the other hand, if the proofs are not equal, then $\advur$ breaks $\ur{k}$-ness of $\psfs$. This happens only with  probability $\epsur(\secpar)$. 
	\qed
	\end{proof}

	We denote by $\waccProb$ the probability that $\advcss$ outputs an acceptable proof. We note that $\waccProb$ is at most $\epsur (\secpar)$ far from the probability that $\advse$ outputs an acceptable proof. By the union bound probability that $\advcss$ outputs an unacceptable proof is at most $1 - \waccProb \leq 1 - \accProb + \epsur$. Hence, $\waccProb \geq \accProb - \epsur (\secpar)$. 

	Since $\psfs$ is $\epscss (\secpar, \waccProb)$ computationally special sound, there is an extractor $\extcss$ that rewinds $\advcss$ to obtain a tree of acceptable transcripts $\tree$ and extracts witness with probability at least $1 - \epscss (\secpar, \waccProb)$. Hence, the extractor $\extse$ outputs the witness with the same probability.
%
	Thus $\epsse(\secpar,\accProb,q) \leq \epscss(\secpar,\accProb - \epsur,q)$.
	\qed
	\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

