%!TEX root=main.tex

\begin{theorem}[Simulation-extractable multi-message protocols]
	\label{thm:se}
	Let $\ps = (\kgen, \prover, \verifier, \simulator)$ be an interactive
	$(2 \mu + 1)$-message HVZK proof system for $\RELGEN(\secparam)$. Let
	$\ro \colon \bin^{*} \to \bin^{\secpar}$ be a random oracle. If $\psfs$ has the
	$k$-\emph{updatable unique response property} with security loss $\epsur(\secpar)$, 
	\emph{updatable $k'$-programmable trapdoor-less zero knowledge}, and $(1, \ldots, 1, n_{k''}, \ldots, n_\mu)$-\emph{updatable computational special soundness} with security loss $\epscss(\secpar)$, where $k \leq k' \leq k''$. Then $\psfs$ is \emph{updatable simulation-extractable} against any $\ppt$ adversary $\advse$ who return an acceptable proof with probability at least $\accProb$ with 	extraction probability $\extProb$ is at least
	$\extProb \geq 1 - \epscss(\secpar, \accProb)\,$.
\end{theorem}

\begin{proof}	
	\michals{22.04}{Started writting draft of the proof. Feel free to write your own proof.}
	Let $(\srs, \inp, \wit) \gets \advse^{\initU, \simulator_1, \simulator_2}(r_{\advse})$. We show that $\extse (\srs, \advse, r_{\advse}, \Qro, \Qsrs, \Qsim)$ outputs a witness $\wit$, such that $\REL(\inp, \wit)$ holds with probability $\extProb$. To that end we define an algorithm $\advcss^{\initU,\ro}(r)$ against the computational special soundness of $\ps$ that runs internally $\advse^{\initU, \simulator\oracleo.\ro, \simulator\oracleo.\prover'}(r_{\advse})$. Here $r = (\rsim, r_{\advse})$. Eventually, we use the computational special soundness extractor $\extcss$ on $\advcss$ to extract the witness.
	
	Since $\advcss$ runs $\advse$ internally, it needs to take care of $\advse$'s oracle queries.
	$\advse$'s queries to the update oracle $\initU$ are passed to $\advcss$ oracle $\initU$ directly. Also, the answers from $\advcss$'s oracle $\initU$ are returned to $\advse$.
	Queries to the simulator $\simulator'_2$ are processed by $\advcss$ who computes the proof running simulators $\simulator_1$ and $\simulator'_2$ internally using randomness $\rsim$. The latter simulator, $\simulator'_{2}$, calls the former, $\simulator_{1}$, when it needs to compute a random oracle challenge. Such calls may either request $\simulator_{1}$ to answer the query with an honest random oracle answer, or to program the oracle, cf.~\cref{fig:simulator_oracles}. Importantly, since $k \leq k'$ , all challenges in simulated proofs, up to round $k'$ are computed honestly, i.e. $\zkproof_{i}.\ch = \simulator_{1}.\ro((\inp, \zkproof_1, \zkproof_1.\ch, \ldots, \zkproof_{i}))$, for $i \leq k'$.
	\begin{figure}
		\centering
			\begin{pcvstack}[center,boxed]
			\begin{pchstack}
				\procedure{$\simulator\oracleo.\ro (x)$}
				{
				\pcif H[x] = \bot \pcthen \\
				\pcind H[x] \gets \ro(x) \\
				\pcreturn H[x]
		  		}
				%
				\pchspace
				%
				\procedure{$\simulator\oracleo.\prog(x, h)$}
				{ 
					\pcif H[x] = \bot \pcthen \\ 
					\pcind H[x] \gets h \\
					\pcind \Qprog \gets \Qprog \cup \{x\}\\
					\pcreturn H[x]
				}
			\end{pchstack}
		\end{pcvstack}
		\caption{Simulating random oracle calls.}
		\label{fig:simulator_oracles}
	\end{figure}	

	$\advse$'s queries to $\simulator_1$ are processed as queries to $\simulator_1.\ro$. (That is, $\advse$ does not program the oracle.)

	Eventually, $\advse$ outputs a proof $(\inp, \zkproof)$ which $\advcss$ outputs as well. We note that the proof output by $\advcss$ cannot contain any programmed queries as such proof is not acceptable w.r.t~$\ro$. If $\advse$ outputs a proof that does contain programmed challenges, then $\advcss$ aborts. We denote that event by $\event{E}$.
	
	\begin{lemma}
		Probability that $\event{E}$ happens is upper-bounded by $\epsur(\secpar)$. 
	\end{lemma}
	\begin{proof}
	We build an adversary $\advur^{\ro, \initU} (\secpar; r)$ that has access to the random oracle $\ro$ and update oracle $\initU$. $\advur$ uses $\advse$ to break the $\ur{k}$ property of $\ps$. Namely, for randomness $r = (r_{\advse}, \rsim)$, $\advur^{\ro, \initU} (\secpar; r)$ runs $\advse^{\initU, \simulator_1, \simulator_2'}(\secparam; r_{\advse})$ internally and answers its oracle queries as $\advcss$ did.

	When $\advse$ makes a proof $\zkproof$ for $\inp_{\advse}$ such that $\event{E}$ holds, $\advur$ looks through lists $Q$ and $Q_\ro$ until it finds $\zkproofs[0..k]$ such that $\zkproof_{\advse}[0..k] = \zkproofs[0..k]$ and a random oracle query $\zkproofs[k].\ch$ on $\zkproofs[0..k]$.	$\advur$ returns two proofs for $\inp_{\advse}$:
		\begin{align*}
		\zkproof_1 = (\zkproofs[1..k],
		\zkproofs[k].\ch, \zkproofs[k + 1..\mu + 1])\\
		\zkproof_2 = (\zkproofs[1..k],
		\zkproofs[k].\ch, \zkproof_{\advse}[k + 1..\mu + 1])
		\end{align*}

	Importantly, both proofs are acceptable w.r.t~the unique response property verifier. The first, since the unique response property definition allows any challenges after $k$. The latter, since it is an acceptable proof produced by the adversary.
	We assume that $\zkproof_1 \neq \zkproof_2$ as in the opposite case the $\advse$ would not be able to break the simulation extractability game as $\zkproof_2 \in Q$. On the other hand, if the proofs are not equal, then $\advur$ breaks $\ur{k}$-ness of $\ps$. This happens only with  probability $\epsur(\secpar)$. 
	\qed
	\end{proof}

	We denote by $\waccProb$ the probability that $\advcss$ outputs an acceptable proof. We note that $\waccProb$ is at most $\epsur (\secpar)$ far from the probability that $\advse$ outputs an acceptable proof. By the union bound probability that $\advcss$ outputs an unacceptable proof is at most $1 - \waccProb \leq 1 - \accProb + \epsur$. Hence, $\waccProb \geq \accProb - \epsur (\secpar)$. 

	Since $\ps$ is $\epscss (\secpar, \waccProb)$ computationally special sound, there is an extractor $\extcss$ that rewinds $\advcss$ to obtain a tree of acceptable transcripts $\tree$ and extracts witness with probability at least $1 - \epscss (\secpar, \waccProb)$. Hence, the extractor $\extse$ outputs the witness with the same probability.

	Thus $\epsilon_{se}(\secpar,\accProb,q) \leq \epscss(\secpar,\accProb - \epsur,q)$.
	\qed
	\end{proof}

	
% 	\begin{corollary}
% 		Let $\tdv$ be a tree building algorithm that builds a tree according to \cref{fig:Attema-ext}. Then the extractor $\extse$ outputs a valid witness with probability \hamid{19.4}{The next equation should be changed. Todo: how should we compute $\epst(\secpar, \accProb)$ based on $\epst(\secpar, \waccProb)$?}\michals{21.04}{$\waccProb \geq \accProb - \epsur$}
% 		\begin{equation}
% 			\label{eq:frk}
% 			\extProb \geq \frac{\accProb - \epsur(\secpar) - (q + 1) \epsk(\secpar)}{1 - \epsk(\secpar)}.
% 			\end{equation} 
% \end{corollary}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

