%!TEX root=main.tex

\begin{theorem}[Simulation-extractable multi-message protocols]
	\label{thm:se}
	Let $\psfs = (\SRScer, \prover, \verifier, \simulator)$ be a NIZK proof system with an updateable SRS setup compiled via the $(2\mu + 1)$-message Fiat--Shamir transformation. Let $\ro$ be the random oracle. If $\psfs$ has the
	$k$-\emph{updatable unique response property} with security loss $\epsur(\secpar)$, 
	\emph{updatable $k$-programmable trapdoor-less zero knowledge}, and $(1, \ldots, 1, n_{k}, \ldots, n_\mu)$-\emph{updatable rewinding-based knowledge soundness} with security loss $\epscss(\secpar)$. 
	
	Then $\psfs$ is \emph{updatable simulation-extractable} with security loss $\epsse(\secpar,\accProb,q) \leq \epscss(\secpar,\accProb - \epsur,q)$ against any $\ppt$ adversary $\advse$ who makes up to $q$ random oracle queries and returns an acceptable proof with probability at least $\accProb$.
\end{theorem}

\begin{proof}	
	Let $(\srs, \inp, \wit) \gets \advse^{\initU, \simOH, \simOP'}(r_{\advse})$ be the USE adversary. We construct an extractor $\extse (\srs, \advse, r_{\advse}, \Qro, \Qsrs, \Qsim)$ that outputs a witness $\wit$, such that $\REL(\inp, \wit)$ holds with high probability. To that end we define an algorithm $\advcss^{\initU,\ro}(r)$ against rewinding-based knowledge soundness of $\psfs$ that runs internally $\advse^{\initU, \simOH, \simOP'}(r_{\advse})$. Here $r = (\rsim, r_{\advse})$. Eventually, we use the rewinding-based knowledge soundness extractor $\extcss$ on $\advcss$ to extract the witness.
	
	Since $\advcss$ runs $\advse$ internally, it needs to take care of $\advse$'s oracle queries.
	$\advse$'s queries to the update oracle $\initU$ are passed to $\advcss$'s oracle $\initU$ and the answers from $\advcss$'s $\initU$ oracle are returned to $\advse$.
	Queries to the simulator $\simOP'$ are simulated by $\advcss$ internally by running the $\simulator$ algorithm employing the $\rsim$ part of $\advcss$'s randomness. $\simulator$ requires access to oracles $\simOH$ and $\simOP$. To compute a challenge honestly, $\simulator$ calls $\simOH$. To program a challenge it calls $\simOHprog$. Both of these oracles are again simulated by $\advcss$ internally, cf.~\cref{fig:simulator_oracles}, this time using $\advcss$'s $\ro$ oracle. Importantly, all challenges in simulated proofs, up to round $k$ are computed honestly, i.e. $\zkproof_{i}.\ch = \simOH(\zkproof[0..i])$, for $i < k$.
	%
	$\advse$'s queries to $\simOH$ are not programmed, but passed on to $\ro$. 

	
	\begin{figure}
		\centering
			\begin{pcvstack}[center,boxed]
			\begin{pchstack}
				\procedure{$\simOH (x)$}
				{
				\pcif H[x] = \bot \pcthen \\
				\pcind H[x] \gets \ro(x) \\
				\pcreturn H[x]
		  		}
				%
				\pchspace
				%
				\procedure{$\simulator\oracleo.\prog(x, h)$}
				{ 
					\pcif H[x] = \bot \pcthen \\ 
					\pcind H[x] \gets h \\
					\pcind \Qprog \gets \Qprog \cup \{x\}\\
					\pcreturn H[x]
				}
			\end{pchstack}
		\end{pcvstack}
		\caption{Simulating random oracle calls.}
		\label{fig:simulator_oracles}
	\end{figure}	
%

	Eventually, $\advse$ outputs a proof $(\inp, \zkproof)$ which $\advcss$ outputs as well as long as $\zkproof[0..i] \notin \Qprog$, $i\in[1,\mu]$. This models that the proof output by $\advcss$ must not contain any programmed queries as such a proof is not acceptable w.r.t~$\ro$. If $\advse$ outputs a proof that does contain programmed challenges, then $\advcss$ aborts. We denote this event by $\event{E}$.
	
	\begin{lemma}
		Probability that $\event{E}$ happens is upper-bounded by $\epsur(\secpar)$. 
	\end{lemma}
	\begin{proof}
	%Denote by $\zkproof_{\advse}, \zkproof_{\simulator}$ proofs returned by the adversary and the simulator respectively.

	We build an adversary $\advur^{\ro, \initU} (\secpar; r)$ that has access to the random oracle $\ro$ and update oracle $\initU$. $\advur$ uses $\advse$ to break the $\ur{k}$ property of $\psfs$. Namely, for randomness $r = (r_{\advse}, \rsim)$, $\advur^{\ro, \initU} (\secpar; r)$ runs $\advse^{\initU, \simOH, \simOP'}(\secparam; r_{\advse})$ internally and answers its oracle queries as $\advcss$ did.

	When $\advse$ makes a proof $\zkproof$ for $\inp_{\advse}$ such that $\event{E}$ holds, $\advur$ looks through lists $Q$ and $Q_\ro$ until it finds $\zkproofs[0..k]$ such that $\zkproof_{\advse}[0..k] = \zkproofs[0..k]$ and a random oracle query $\zkproofs[k].\ch$ on $\zkproofs[0..k]$.	$\advur$ returns two proofs for $\inp_{\advse}$:
		\begin{align*}
		\zkproof_1 = (\zkproofs[1..k],
		\zkproofs[k].\ch, \zkproofs[k + 1..\mu + 1])\\
		\zkproof_2 = (\zkproofs[1..k],
		\zkproofs[k].\ch, \zkproof_{\advse}[k + 1..\mu + 1])
		\end{align*}

	Importantly, both proofs are acceptable w.r.t~the unique response property verifier. The first, since it is a correctly computed simulated proof and the unique response property definition allows any challenges at $k$. The latter, since it is an acceptable proof produced by the adversary.
	We have that $\zkproof_1 \neq \zkproof_2$ as otherwise $\advse$ does not win the simulation extractability game as $\zkproof_2 \in Q$. On the other hand, if the proofs are different, then $\advur$ breaks $\ur{k}$-ness of $\psfs$. This happens only with  probability $\epsur(\secpar)$. 
	\qed
	\end{proof}

	We denote by $\waccProb$ the probability that $\advcss$ outputs an acceptable proof. We note that $\waccProb$ is at most $\epsur (\secpar)$ far from the probability that $\advse$ outputs an acceptable proof. By the union bound the probability that $\advcss$ outputs an acceptable proof is at least $\waccProb \geq \accProb - \epsur (\secpar)$. \markulf{30.04}{I am ignorant. What is the role of the union bound here. Is this the same as up-to-bad reasoning?}

	Since $\psfs$ is $\epscss (\secpar, \waccProb,q)$ computationally special sound, there is an extractor $\extcss$ that rewinds $\advcss$ to obtain a tree of acceptable transcripts $\tree$ and fails to extract the witness with probability at most $\epscss (\secpar, \waccProb, q)$. The extractor $\extse$ outputs the witness with the same probability.
%
	Thus $\epsse(\secpar,\accProb,q) = \epscss (\secpar, \waccProb,q) \leq \epscss(\secpar,\accProb - \epsur,q)$.
	\qed
	\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

