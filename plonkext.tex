% !TeX spellcheck = en_GB
\let\accentvec\vec
\documentclass[runningheads,11pt]{llncs}
 % \documentclass[runningheads]{amsart}
\let\spvec\vec
\let\vec\accentvec
\usepackage{amssymb,amsmath}
\let\vec\spvec

\usepackage[T1]{fontenc}

\newcommand{\iflipics}[1] {}
\newcommand{\iflncs}[1] {#1}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
	{\mbox{\boldmath$\textstyle#1$}}
	{\mbox{\boldmath$\scriptstyle#1$}}
	{\mbox{\boldmath$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

% lncs size (as printed in books, with small margins):
\usepackage[paperheight=23.5cm,paperwidth=15.5cm,text={13.2cm,20.3cm},centering]{geometry}


\newcommand{\ifamsart}[1] {}
\ifamsart{
	\newtheorem{theorem}{Theorem}%[section]
	\newtheorem{proposition}[theorem]{Proposition}
	\newtheorem{lemma}[theorem]{Lemma}
	\newtheorem{corollary}[theorem]{Corollary}
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definition}
	\newtheorem{example}[theorem]{Example}
}
\usepackage{soul}
\usepackage{soulutf8}
\soulregister\cite7
\soulregister\ref7
\soulregister\pageref7
\usepackage{hyperref}
\usepackage[color=yellow]{todonotes}
\hypersetup{final}
\usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}
\usepackage[capitalise]{cleveref}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed}

\include{macros}

\title{On Simulation-Extractability of \textsc{Plonk}}
% \titlerunning{Achieving additional security in LegoSNARK}

\author{Michał Zając}
\iflncs{
  \institute{Clearmatics, London, UK\\ \email{m.p.zajac@gmail.com}}
}

\allowdisplaybreaks

\begin{document}
	\sloppy
	\maketitle

\begin{abstract}
	In this paper we prove that some most-efficient updatable universal zkSNARKs like \plonk{}~\cite{EPRINT:GabWilCio19} \comment{and Sonic~\cite{CCS:MBKM19} are} is (non black-box) simulation extractable.
	To that end, we generalise the result by Faust et al.~\cite{INDOCRYPT:FKMV12} (INDOCRYPT 2012) and show that any witness-extended emulatable is also simulation-extractable if made non-interactive by the Fiat--Shamir transform. We then explain why \plonk{} is has witness-extended emulation and conclude by showing its simulation-extractability.
	\michals{14.05}{Since Sonic is witness-extended emulation then it should be simulation extractable as well. But does it have the unique response property?}
	\task{15.05}{Check Marlin}
\end{abstract}

\section{Introduction}
\paragraph{The rise of updatable zkSNARKs.}
\cite{C:GKMMM18}
\cite{EC:CHMMVW20}
\cite{CCS:MBKM19}
\cite{EPRINT:GabWilCio19}
\cite{EPRINT:Gabizon19c}
\cite{EPRINT:Lipmaa19a}

\paragraph{On the importance of the simulation extractability.}
\cite{AC:DHLW10}
\cite{AC:Groth07}
\cite{EPRINT:AbdRamSla20}
\cite{EPRINT:KZMQCP15}
\cite{EPRINT:BagAta19}
\cite{EPRINT:Baghery20}



\subsection{Our contribution}
First of all, we prove that $\plonk$ is simulation-extractable. Although we do not change the original protocol at all, we had to solve a number of problems in order to show that. The idea of the proof goes as follows.

\paragraph{Witness-extended emulation of \plonk{}.}
First, we show that $\plonk$ has witness-extended emulation. To that end we show how from a number of accepting transcript a witness can be extracted. Unfortunately, \plonk{} does not to fit well in the standard definitions of witness-extended emulations like by Lindell \cite{JC:Lindell03} or by Groth and Ishai \cite{EC:GroIsh08}. The former does not cover arguments that utilises a CRS, the latter does, but does not consider giving the CRS trapdoor to the extractor. Thus, we had to modify the definition for the witness-extended emulation.
By this modification we bring the notion of the witness extended-emulation closer to the definition of simulation extractability, where giving the trapdoor to the extractor is a natural thing to do, cf.~\cite{AC:Groth06,AC:DHLW10,PKC:ADKNO13,DCC:DerSla19}.
We believe that our formulation would serve well in showing simulation-extractability of NIZKs.

\paragraph{From witness-extended emulation to simulation extractability.}
Second, we took the classical result by Faust et al.~\cite{INDOCRYPT:FKMV12} which shows that a special-sound $\Sigma$-protocol that has the unique response property is simulation-extractable if made non-interactive by the Fiat--Shamir transform. This result also could not be used directly, as \plonk{} is not a $3$-round $\Sigma$-protocol.
To make Faust et al.~result working in our setting we had to prove it fits multi-round protocols and show that \plonk{} in fact has the unique response property.

\paragraph{Interactive zero knowledge vs non-interactive zero knowledge.}
Another issue we tackle with is a question whether NIZK proof systems are in fact zero-knowledge, see e.g.~\cite{C:Pass03}. This problem was raised as one could observe that a NIZK proof system has a property alien to interactive proofs --- a verifier who obtains a proof $\zkproof$ for a statement $\inp \in \LANG$ inevitably learns how to prove this statement. More precisely, he can just reuse the obtained proof $\zkproof$. This makes the verifier learn undoubtedly more than simply the veracity of the proven statement. On the other hand, the verifier learns a particular proof $\zkproof$ for a concrete CRS $\crs$ only. However, the CRS generator is considered trusted, thus the proof $\zkproof$ could be considered as a proof for $\inp$ universally, regardless the CRS.

Simulation-extractable updatable NIZKs (and zkSNARKs in particular) tighten the gap between interactive zero knowledge and non-interactive zero knowledge in the CRS model.
First, simulation-extractability assures that no adversary can maul an existing proof and make a fresh one, what limits replay attacks.
Second, updatable NIZKs does not assume that there is a trusted party that provides a CRS, but rather a sequence of parties (called updaters) that modify it. The security model is radically different as now one believes in the veracity of a proof only if she trusts that there is at least one honest party between the updaters. Hence, the proof is no longer universal.

We believe that our result may be useful for designing new zkSNARKs, especially those based on a polynomial commitment schemes~\cite{AC:KatZavGol10}, as it shows that a careful protocol design may give it a strong security notion for free.

\section{Preliminaries}
Let PPT denote probabilistic polynomial-time.
Let $\secpar \in \NN$ be the security parameter.
All adversaries will be stateful.
For an algorithm $\adv$, let $\image (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), let $\RND{\adv}$ denote the random tape of $\adv$ (assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote the random choice of the randomiser $r$ from $\RND{\adv}$.
We denote by $\negl$ an arbitrary negligible function.

Distributions $X$ and $Y$ have \emph{statistical distance} $\SD$ equals $\epsilon$ if $\sum_{a \in \supp{X \cup Y}} \abs{\prob{X = a} - \prob{Y = a}} = \epsilon$.
We write $X \approx_\secpar Y$ if $\SD(X, Y) \leq \negl$, where $\SD$ is the statistical distance between the distributions.
For values $a$ and $b$ we write $a \approx_\secpar b$ if $\abs{a - b} \leq \negl$.

Denote by $\RELGEN$ a \emph{relation generator} -- a PPT algorithm that on input $\secparam$ outputs an $\npol$ relation $\REL$. We assume that if $\RELGEN$ provides any auxiliary input to $\REL$, it is benign. Directly from the description of $\REL$ one learns security parameter $\secpar$ and other necessary information like a description of a group $\GRP$, if the relation is a relation of group elements (as it usually is in case of zkSNARKs).

\paragraph{Bilinear groups.}
A bilinear group generator $\pgen (1^\secpar)$ returns $(p, \GRP_1, \GRP_2, \GRP_T, \pair, \gone{1}, \gtwo{1})$, where $\GRP_1$, $\GRP_2$, and $\GRP_T$ are additive cyclic groups of prime order $p = 2^{\Omega (\secpar)}$, $\gone{1}, \gtwo{1}$ are generators of $\GRP_1$, $\GRP_2$, resp., and $\pair: \GRP_1 \times \GRP_2 \to \GRP_T$ is a non-degenerate PPT-computable bilinear pairing.
We assume the bilinear pairing to be Type-3, i.e., that there is no efficient isomorphism from $\GRP_1$ to $\GRP_2$ or from $\GRP_2$ to $\GRP_1$.
We use the by now standard bracket notation, i.e., we write $\bmap{a}{\gi}$ to denote $a g_{\gi}$ where $g_{\gi}$ is a fixed generator of $\GRP_{\gi}$.
We denote $\pair (\gone{a}, \gtwo{b})$ as $\gone{a} \bullet \gtwo{b}$.
Thus, $\gone{a} \gtwo{b} = \gtar{a b}$.
We freely use the bracket notation with matrices, e.g., if $\vec{A} \vec{B} = \vec{C}$ then $\vec{A} \grpgi{\vec{B}} = \grpgi{\vec{C}}$ and $\gone{\vec{A}}\bullet \gtwo{\vec{B}} = \gtar{\vec{C}}$.

\subsection{Zero knowledge}
In a zero-knowledge proof or argument system, a prover convinces the verifier of the veracity of a statement without leaking any side information except that the statement is true.
Here, a proof (resp., an argument) system guarantees soundness against an unbounded (resp., a PPT) cheating prover.
The zero-knowledge property is proven by constructing a simulator that can simulate the view of a cheating verifier without knowing the secret information (witness) of the prover.

More precisely, let $\RELGEN(\secparam)$ be a relation generator that outputs an $\npol$ relation $\REL = \smallset{(\inp, \wit)}$. Denote by $\LANG_\REL$ the language determined by $\REL$.
Let $\prover$ and $\verifier$ be algorithms, the former called \emph{prover} and the latter \emph{verifier}.
We denote by $\ip{\prover(\REL, \inp, \wit)}{\verifier(\REL, \inp)}$ a transcript of conversation between a $\prover$ with input $(\REL, \inp, \wit)$ and $\verifier$ with input $(\REL, \inp)$.
We write $\ip{\prover (\REL, \inp, \wit)}{\verifier(\REL, \inp)} = 1$ if in the end of the transcript the verifier $\verifier$ returns $1$ and say that $\verifier$ accepts the transcript.

A proof system $\proofsystem = (\prover, \verifier, \simulator)$ for $\RELGEN$ is required to have three properties: completeness, soundness and zero knowledge, which are defined as follows:
\begin{description}
	\item[Completeness] An interactive proof system $\proofsystem$ is \emph{complete} if an honest prover always convinces an honest verifier, that is for all $\REL \gets \RELGEN(\secparam)$ and $(\inp, \wit) \in \REL$
	\[
		\prob{\ip{\prover (\REL, \inp, \wit)}{\verifier (\REL, \inp)} = 1} = 1\,.
	\]
	\item[Soundness] We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no PPT prover $\adv$ can convince an honest verifier $\verifier$ to accept a proof for a false statement, i.e~for $\inp \not\in\LANG$. More precisely, for all $\REL \gets \RELGEN(\secparam)$
	\[
		\condprob{\ip{\adv(\REL, \inp)}{\verifier(\REL, \inp)} = 1}{\inp \gets \adv(\REL); \inp \not\in \LANG_\REL} \leq \negl\,;
	\]
	\item[Zero knowledge] We call an interactive proof system $\proofsystem$ \emph{zero-knowledge} if for any $\REL \gets \RELGEN(\secparam)$ and adversary $\adv$ there exists a $\ppt$ simulator $\simulator$ such that
	\begin{multline*}
	  \left\{\ip{\prover(\REL, \inp, \wit)}{\adv(\REL, \inp, \wit)} \,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\} \approx_\secpar
		% \\
		\left\{\simulator^{\adv}(\REL, \inp)\,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\}\,.
	\end{multline*}
	%
	We call zero knowledge \emph{perfect} if the distributions are equal and \emph{computational} if they are indistinguishable for any NUPPT distinguisher.
\end{description}

\paragraph{NIZKs in the Random Oracle Model.}
In NIZKs in the Random Oracle Model we distinguish, for the sake of clarity, two simulators, one denoted by $\simulator_\zkproof$ that is responsible for providing simulated proofs and $\simulator_\ro$ that picks a random oracle instantiation and takes care of all parties' queries to $\ro$.
\michals{9.06}{Should we distinguish two simulators or just pack everything into a single one?}
% % \paragraph{Fiat--Shamir transformation.}
% Denote by $\rof{A}{B}$ the family of all functions mapping set $A$ to $B$ and let $\ro$ be a randomly picked function from $\rof{A}{B}$.
% In the Random Oracle Model all algorithms are given oracle access to $\ro$
% The Fiat--Shamir transforms

\paragraph{Sigma protocols.}
A sigma protocol $\sigmaprot = (\prover, \verifier, \simulator_\zkproof)$  for a relation $\REL \gets \RELGEN(\secparam)$ is a special case of an interactive proof which transcript compounds of three messages $(a, b, z)$, the middle being a challenge provided by the verifier.
Sigma protocols are specially-sound. That is, there exists an extractor $\ext$ which from two accepting transcripts $(a, b, z)$, $(a, b', z')$ for a statement $\inp$ can recreate the corresponding witness if $b \neq b'$. Formally,
\begin{description}
	\item[Special soundness] A sigma protocol $\sigmaprot$ is \emph{specially-sound} if for any adversary $\adv$ the probability
	\[
		\Pr\left[
		\begin{aligned}
				& \wit \gets \ext(\REL, \inp, (a, b, z), (a, b', z')),\\
				& \REL(\inp, \wit) = 0
		\end{aligned}
		\,\left|\,
		\begin{aligned}
			& (\inp, (a, b, z), (a, b', z')) \gets \adv(\REL), \\
			& \verifier(\REL, \inp, (a, b, z)) = \\
			& \qquad = \verifier(\REL, \inp, (a, b', z')) = 1, \\
		\end{aligned}
		\right.\right]
	\]
	is negligible in $\secpar$.
\end{description}

Furthermore sigma protocols are \emph{honest verifier zero-knowledge} (HVZK). That is the zero-knowledge property holds only for honest verifiers, what is formalized as follows:
\begin{description}
	\item[Honest verifier zero knowledge] A sigma protocol $\sigmaprot$ is \emph{honest verifier zero-knowledge} if for all adversaries $\adv$ holds
	\begin{multline*}
		\left\{\ip{\prover(\REL, \inp, \wit)}{\verifier(\REL, \inp)} \,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator_\zkproof^\adv}\right.\right\} \approx_\secpar
		\left\{\simulator_\zkproof^{\verifier}(\REL, \inp)\,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator_\zkproof^\adv}\right.\right\}\,.
	\end{multline*}
\end{description}
Although this notion is weaker than a standard zero knowledge it is often sufficient. Furthermore, a HVZK interactive proof system transformed by the Fiat--Shamir transformation is zero-knowledge.

Another property that sigma protocols sometimes have is, introduced by Fischlin \cite{C:Fischlin05}, a unique response property which states that no PPT adversary  can produce two accepting transcripts that differ only on the last element.
More precisely,
\begin{description}
	\item[Unique response property] Let $\sigmaprot = (\prover, \verifier, \simulator_\zkproof)$ be a standard-model sigma-protocol for relation $\REL \gets \RELGEN(\secparam)$ which proofs compound of three messages $(\alpha, \beta, \gamma)$. We say that $\sigmaprot$ is has a unique response property if for all PPT algorithms $\adv$ holds
	\[
	\condprob{\verifier (\alpha, \beta, \gamma) = \verifier (\alpha, \beta, \gamma')  = 1}{(\alpha, \beta, \gamma, \gamma') \gets \adv(\REL)} \leq \negl\,.
	\]
\end{description}
Later on we often call protocols that follows this notion ur-protocols.
For the sake of completeness we note that many sigma-protocols, like e.g.~Schnorr's protocol \cite{C:Schnorr89}, fulfil this requirement.

\paragraph{Zero knowledge proof system in the CRS model.}
Many proof systems additionally compounds of a setup algorithm $\kcrs$ that on input $\REL$ outputs a common reference string (CRS) $\crs$. The common reference string comes with a corresponding trapdoor $\td$ that allows the simulator to simulate a proof.

\paragraph{Witness-extended emulation.}
Interactive proofs run in a multi-protocol environment are often required to fulfil a stronger notion of soundness called \emph{witness-extended emulation}~\cite{JC:Lindell03}.
The following definition is inspired by  \cite{EC:GroIsh08} as their formulation of the witness-extended emulation considers proof systems that utilises a CRS. However, there are some changes introduced to fit better our purpose. More precisely, contrary to \cite{EC:GroIsh08,EC:BCCGP16} the extractor in \cref{def:wit_ext_em} is given the trapdoor $\td$, thus seems to be bit more powerful.
This means that a protocol that has witness-extended emulation in terms of \cite{EC:GroIsh08} has it also according to \cref{def:wit_ext_em} below.
There, for the sake of succinctness, we denote by $\trans$ a transcript of a conversation between the prover and the verifier extended with verifier's input $(\REL, \inp)$ (or $(\REL, \crs, \inp)$ in case of a proof system with a setup).
Furthermore, a proof system $\proofsystem$ is \emph{public coin} if the messages the verifier sends are chosen uniformly at random and independently of the messages send by the prover or system parameters.

\begin{definition}[Witness-extended emulation]
	\label{def:wit_ext_em}
	We say a public coin proof system $\proofsystem = (\kcrs, \prover, \verifier, \simulator)$ has \emph{witness-extended emulation} if for all $\REL \in \image(\RELGEN)$, and deterministic adversary $\adv_1$ there exists an expected polynomial time extractor $\ext$ such that for all NUPPT adversaries $\adv_0$ holds
		\begin{multline*}
		\Pr\left[\adv_0 (\trans, \inp, \aux_{\adv_1}) = 1 \,\left|\,
		\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0, \\
				& \trans \gets \ip{\adv_1(\REL, \crs, \inp, \aux_{\adv_1})}{\verifier(\REL, \crs, \inp)}
			\end{aligned}
		\right.
		\right]
		 \approx_\secpar \\
		 \Pr\left[
			\begin{aligned}
				& \adv_1 (\trans) = 1\ , \\
				& \text{if $\trans$ is accepting} \\
				& \pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}\,\left|\,
			\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0(\REL), \\
				& (\trans, \wit )\gets \ext^{\ip{\adv_1(\REL, \crs, \inp, \aux_\prover)}{\verifier(\REL, \crs, \inp)}}(\REL, \inp, \td)
			\end{aligned}
			\vphantom{\begin{aligned}
				\adv (\trans) = 1, \\
				\text{if $\trans{}$ is accepting} \\
				\pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}}\right.
			\right]\,,
\end{multline*}
where the extractor $\ext$ can rewind the conversation between the prover and the verifier to a particular round and run it again with a fresh randomness for the verifier.
\end{definition}
Although in the definition above the adversary $\adv_1$ is deterministic it obtains an auxiliary input $\aux_{\adv_1}$ that may be used by $\adv_1$ as a source of randomness. \cite{EC:GroIsh08} notes that since the protocol is public-coin, verifier's randomness is part of the transcript. Thus combining $\inp, \aux_\adv$ and an accepting transcript $\trans$ gives a view of both the prover and the verifier and thus gives a witness.

\subsection{Simulation extractable NIZKs from sigma protocols}
Real life applications often require from a NIZK proof system to be non-malleable. That is, no adversary seeing a proof $\zkproof$ for a statement $\inp$ should not be able to provide a new proof $\zkproof'$ related to $\zkproof$.
A strong version of non-malleability is formalized by simulation extractability. This notion states that no adversary can produce an acceptable proof for without knowning the corresponding witness. That holds even if the adversary is allowed to see polynomially many simulated proofs for any statements she wishes.

\begin{definition}[Simulation extractability]
	A proof system $\proofsystem$ is computationally (adaptively) \emph{strongly simulation-extractable for $\RELGEN$}, if for every NUPPT $\adv$, there exists a NUPPT extractor $\ext_\adv$, s.t.
	\[
	\condprob{
  \begin{aligned}
    &(\inp, \wit) \not\in \REL , (\inp, \zkproof) \not\in Q, \\
    & \verifier (\REL, \crs_{\verifier}, \inp, \zkproof) = 1
  \end{aligned}
  }
  {
		\begin{aligned}
		& \REL \gets \RELGEN (\secparam),
		(\crs, \td) \gets \kgen (\REL), r \sample \RND{\adv},
		\\ &
		((\inp, \zkproof)  \|  \wit) \gets (\adv^{\oracleo}  \|  \ext_\adv) (\REL, \crs; r)
		\end{aligned}
	} \leq \negl \enspace,
	\]
	where $\oracleo$ on input $\inp'$ returns $\zkproof' \gets \simulator(\REL, \crs, \td, \cdot)$ and writes $(\inp', \zkproof')$ to a list $Q$.
\end{definition}

% Faust et al.~\cite{INDOCRYPT:FKMV12} show every
Consider a sigma protocol $\sigmaprot = (\prover, \verifier, \simulator)$ that is specially sound and has a unique response property is simulation-extractable. Let $\sigmaprot_\fs = (\prover_\fs, \verifier_\fs, \simulator_\fs)$ be a NIZK obtained by applying Fiat--Shamir transform to $\sigmaprot$.
Faust et al.~\cite{INDOCRYPT:FKMV12} show that every such $\sigmaprot_\fs$ is simulation-extractable.

\begin{theorem}[Simulation extractability of the Fiat--Shamir transform \cite{INDOCRYPT:FKMV12}]
	Let $\sigmaprot = (\prover, \verifier, \simulator_\zkproof)$ be a non-trivial sigma protocol with unique responses for a language $\LANG \in \npol$.
	In the random oracle model, the NIZK proof system $\sigmaprot_\fs = (\prover_\fs^\ro, \verifier_\fs^\ro, \simulator_{\fs, \ro}, \simulator_{\fs, \zkproof})$ resulting by applying the Fiat--Shamir transform to $\sigmaprot$ is simulation extractable with extraction error $\eta = q/h$ for the simulator $\simulator$. Here, $q$ is the number of random oracle queries and $h$ is the number of elements in the range of $\ro$.
	Furthermore, the extractor $\ext_\adv$ needs to run $\adv^{\simulator_{\fs, \ro}}, \adv^{\simulator_{\fs, \zkproof}}$ twice.
\end{theorem}

The theorem relies on the following classical lemma, called \emph{General forkikng lemma} \cite{JC:PoiSte00}.
%
% The result relies on
% Let $\sigmaprot = (\prover, \verifier, \simulator)$ be a sigma protocol which transcript contains three messages $(a, b, z)$ with the middle being sent as a challenge from the verifier.
% Special soundness states that any acceptable pair of transcripts $(a, b, z)$ and $(a, b', z')$ for some statement $\inp$ can be used to extract the corresponding witness $\wit$.
% This is formalised and generalized by the so-called general forking lemma

\newcommand{\forking}{\pcalgostyle{F}}
\begin{lemma}[General forking lemma, cf.~\cite{INDOCRYPT:FKMV12}]
	\label{lem:faust_forking_lemma}
	Fix $q \in \ZZ$ and a set $H$ of size $h > 2$. Let $\pdv$ be a PPT algorithm that on input $y, h_1, \ldots, h_q$ returns $(i, s)$, where $I \in\range{0}{q}$ and $s$ is called a \emph{side output}.
	Denote by $\ig$ a randomised instance generator.
	We denote by $\accProb$ the probability
	\[
		\condprob{i > 0}{y \gets \ig; h_1, \ldots, h_1 \sample H; (i, s) \gets \pdv(y, h_1, \ldots, h_q)}\,.
	\]
	Let $\forking_\pdv(y)$ denote the algorithm described in \cref{fig:faust_forking_lemma}, then the probability $\extProb$ defined as
	$
		\extProb := \condprob{b = 1}{y \gets \ig; (b, s, s') \gets \forking_{\pdv}(y)}
	$
	holds
	\[
		\extProb \geq \accProb \brak{\frac{\accProb}{q} - \frac{1}{h}}\,.
	\]
	%
	\begin{figure}
		\centering
		\fbox{
		\procedure{$\forking_\pdv (y)$}
		{
			r \sample \RND{\pdv}\\
			h_1, \ldots, h_q \sample H\\
			(i, s) \gets \pdv(y, h_1, \ldots, h_q; r)\\
			\pcif i = 0\ \pcreturn (0, \bot, \bot)\\
			h_{i'}, \ldots, h_{q'} \sample H\\
			(i', s') \gets \pdv(y, h_1, \ldots, h_{i - 1}, h_{i'} h_{q'}; r)\\
			\pcif (i = i') \land (h_{i} \neq h_{i'})\ \pcreturn (1, s, s')\\
			\pcind \pcelse \pcreturn (0, \bot, \bot)
		}}
		\caption{Forking algorithm $\forking_\pdv$}
		\label{fig:faust_forking_lemma}
\end{figure}
\end{lemma}
%
In case of a $\Sigma$-protocol, the probability $\extProb$ can be interpreted as a lower bound for a successful witness extraction from two transcripts.
Let $\tr_1 = (\inp, a, z, \gamma)$ and $\tr_2 = (\inp, a, z', \gamma')$ be the transcripts.
Both $\tr_1$ and $\tr_2$ have to be \emph{acceptable}, i.e.~$i > 0$. Index $i$ can be interpreted as an index of $h_i$ which was sent as a challenge for $(\inp, a)$. For the sake of extractability, both transcripts have to have the same index $i$, i.e.~the same instance $\inp$ and the first message $a$, but the actual challenges $z = h_i$ and $z' = h_{i'}$ have to differ.

% Another property required by Faust et al.~\cite{INDOCRYPT:FKMV12} to show simulation extractability of a sigma protocol is the unique response property which states that no PPT adversary can provide two different transcripts $(a, b, z)$ and $(a, b, z')$ such that the verifier $\verifier$ accepts both.

% Finally \cite{INDOCRYPT:FKMV12} shows the following theorem:

% \task{14.05}{Need to make this theorem more general as currently it works only for 3-move $\Sigma$-protocols!}

%
\section{Simulation extractability for multi-round protocols}
Unfortunately, Faust et al.'s result cannot be directly applied in our case since the protocols we consider have more than three rounds of interaction.

\paragraph{Witness extended-emulation.}
First of all, although dubbed ``general'', \cref{lem:faust_forking_lemma} is not general enough for our purpose as it useful only for protocols that extract witness from two transcripts.

Fortunately, Bootle et al.~\cite{EC:BCCGP16} shown a more general version of the lemma. More precisely, they proved that each protocol that allows for a witness extraction from a bigger number of accepting transcripts has witness-extended emulation. \cite{EC:BCCGP16} defines a \emph{tree of accepting transcript}.
Let $\proofsystem$ be a $(2 \mu + 1)$-move public-coin proof system with $\mu$ challenges $h_1, \ldots, h_\mu$. Let $n_i > 1$, for $i \in \range{1}{\mu}$.
Consider $\prod_{i = 1}^{\mu} n_i$ accepting transfers with challenges as a tree with depth $\mu$ and $\prod_{i = 1}^{\mu} n_i$ leaves.	Each node of depth $i < \mu$ has exactly $n_i$ children, each labelled with a distinct value for the $i$-th challenge $h_i$. We refer to that as a $(n_1, \ldots, n_\mu)$-tree of accepting transcripts.

 % \task{15.05}{Use one forking lemma (by Bootle et al) and show that the result from Faust holds for it anyway}
\begin{lemma}[Generalised general forking lemma~\cite{EC:BCCGP16}]
	\label{lem:bootle_forking_lemma}
	Let $\proofsystem = (\prover, \verifier, \simulator)$ be a $(2\mu + 1)$-move, public coin interactive  protocol. Let $\ext$ be a PPT witness extraction algorithm that always succeeds in extracting a witness from an $(n_1, \ldots, n_\mu)$-tree of accepting transcripts. Assume that $\prod_{i = 1}^{\mu} n_i \leq \poly$.
	Then $(\prover, \verifier, \simulator)$ has witness-extended emulation.
\end{lemma}
As mentioned, any protocol that has witness-extended emulation defined as in \cite{EC:BCCGP16} is equipped with this property also in the light of \cref{def:wit_ext_em}.

\paragraph{Unique-response protocols.}
Another problem comes with another assumption required by Faust et al. That is, the unique response property of the transformed sigma protocol.
Fischlin's formulation, although perfectly fine for applications presented in \cite{C:Fischlin05}, is not enough in our case.
First of all, the property assumes that the protocol has three rounds, with the middle being the challenge from the verifier. That is not the case we consider here. Second, it is not entirely clear how to generalize the property. Should one require that after the first challenge from the verifier the responses are fixed? That could not work since if there are more challenges then they are random.
Even if we directly consider a protocol transformed by the Fiat--Shamir transform and the verifier challenges are determined by the random oracle it may be the case that the protocol contains some round (obviously, except the first one) where the prover randomises his message. In that case unique-responsiveness can not hold as well.
Last but not least, the protocol we consider here most, \plonk, is not in a standard-model, but utilises CRS. That also complicates things considerably.

We walk around these obstacles by providing two generalized notions of the unique response property, one dubbed \emph{weak} and another \emph{strong}.
More precisely, we say that a $(2\mu + 1)$-round protocol has \emph{unique responses after $i$} and is called a $\ur{i}$-protocol if
\begin{definition}[$\ur{i}$-protocol]
	\label{def:wiur}
	Let $\proofsystem$ be a multi-round proof system. 
	Denote by $a_0, b_0, \ldots, a_{\mu - 1}, b_{\mu - 1}, a_{\mu}$ the consecutive messages exchanged in the protocol, where messages $a_i$ come from the prover and $b_i$ from the verifier. 
	We say that $\proofsystem$ has \emph{unique responses after $i$}
	if after submitting his $i$-th message the prover is a deterministic function. That is, it does not use his randomness tape and deterministically answers verifier's challenges.
\end{definition}
We note that the definition above is independent on whether the proof system $\proofsystem$ utilises CRS (and compounds of the CRS-generating $\kgen$ algorithm) or not.
% Furthermore it is also blind whether $\proofsystem$ is interactive or not. 

\paragraph{Simulatability of proofs.}
We note that in the standard model protocols the simulator does not require any additional power like knowledge of a CRS trapdoor or programmability of the random oracle. This implies that every adversary can produce a simulated proof by its own.  
On the other hand, we have CRS-based zk-proofs where knowledge of trapdoor is required to make an simulated proof. 

Given a multi-round Fiat--Shamir-transformed protocol which simulation utilises trapdoor we can ask another question -- how many rounds---from the beginning of the protocol---can be simulated by the adversary unless the trapdoor is required? Note that to answer this question we shall quantify over all possible simulators. That would not be a problem though in the setting we consider.

\begin{definition}[$k$-out-of-$n$ simulatable proof system]
	Let $\proofsystem = (\kgen, \prover, \verifier, \simulator)$ for $\RELGEN$ be a $n$-round interactive proof. Let $(\inp, a_0, b_0, \ldots, b_{n - 2}, a_{n - 1})$ be a proof for a statement $\inp$ where $a_i$-s, $i \in \range{0}{n - 1}$ are messages send by the prover and $b_i$-s, $i \in \range{0}{n - 2}$ by the verifier. 
	Similarly we denote by $(\inp, a^{\simulator}_0, b^{\simulator}_0, \ldots, b^{\simulator}_{n - 2}, a^{\simulator}_{n - 1})$ a proof output by the simulator $\simulator$.
	We say that $\proofsystem$ is \emph{$k$-out-of-$n$ simulatable} if for  $\REL \in \image{\RELGEN(\secparam)}$ there exists a $\ppt$ adversary $\adv = (\adv_0, \adv_1)$ can produce a proof $(\inp, a_0, b_0, \ldots, b_{n - 2}, a_{n - 1})$ such that 
	\begin{multline*}
		\left\{(\inp, a_0, b_0, \ldots, b_{k - 1}, a_{k}) \gets \adv_1(\REL ,\crs) \,\left\vert\, 
		\begin{aligned}
			 & (\crs, \td) \gets \kgen(\REL) \\
			 & \inp \gets \adv_0(\REL, \crs)
		\end{aligned}
		\right.
		\right\} \approx_\secpar \\
		\left\{(\inp, a_0, b_0, \ldots, b_{k - 1}, a_{k}) \gets \simulator(\REL, \crs, \td) \,\left\vert\, 
		\begin{aligned}
			 & (\crs, \td) \gets \kgen(\REL) \\
			 & \inp \gets \adv_0(\REL, \crs)
		\end{aligned}
		\right.
		\right\}\,.
	\end{multline*}
	\michals{3.07.20}{Note that $\inp$ doesn't need to be in the language!}
\end{definition}

This definition will have consequences later on as in a $k$-out-of-$n$ simulatable proof system learning first $2k - 1$ messages of the simulated proof gives the adversary no additional power as it could compute these messages by its own.
\michals{03.07}{a proof for that statement would be nice.}

\paragraph
{Simulation extractability from unique responses and witness-extended emulation.}
We can now present two proofs for the Fiat--Shamir transform simulation extractability, one for the standard---weaker---version of the unique response property, one for the stronger.

In the former, we assume that the underlying interactive proof system is in the standard model. More precisely, we require that the only additional power given to the simulator is the ability of producing proof elements in any order it wants. Especially, producing a simulated proof does not require knowledge of some sort of a trapdoor.
Although we believe that this result may be of independent interest, it is not enough in our case, it is not enough to show simulation extractability of \plonk.
This is since we show our result by contradiction and build an adversary $\bdv$ that breaks the unique response property using an adversary $\adv$ that breaks simulation extractability. Thus, to make the reduction hold we need to allow $\bdv$ to make simulated proofs for $\adv$.

To make the result useful in the context of CRS-model zkSNARKs like \plonk, we need to rely on a stronger version of the unique response property presented in \cref{def:wiur} to allow the unique-response-property adversary to learn the simulated proofs as well.

% \begin{theorem}[Simulation extractability of the Fiat--Shamir transform II]
% 	\label{thm:wit_ext_em_FS}
% 	Let $\proofsystem = (\prover, \verifier, \simulator_\zkproof)$ be a standard-model interactive $\ur{i}$-protocol for a relation $\REL$.
% 	Assume there exists an extractor $\ext$ that extracts the witness from a $(1, \ldots, 1, n_{i + 1}, \ldots, n_\mu)$-tree of accepting transcripts.
% 	Then $\proofsystem_\fs$ is simulation-extractable in the random oracle model if $N =\prod_{j = i}^\mu = \poly$.
% 	Furthermore the extractor $\ext_\fs$ for $\proofsystem_\fs$ needs to run $(\simulator_\ro, \simulator_\zkproof)$ $N$ times.
% \end{theorem}
% \begin{proof}
% 	The proof goes by contradiction. Similarly to \cite{INDOCRYPT:FKMV12}
% 	let us assume that there is an adversary $\adv_{\se}$ that breaks simulation extractability with a non-negligible probability $\eta$. We use $\adv_\se$ to build two adversaries $\bdv_\ur{i}$ and $\bdv_\snd$ such that when $\adv_\se$ is successful then either $\bdv_\ur{i}$ breaks unique responses after $i$ property or $\bdv_\snd$ breaks soundness.
% 
% 	Denote by $\zkproof = (a_1, \ldots, a_\mu)$ the accepting proof for some instance $\inp$ output by $\adv_\se(\REL; r)$. We assume that $(\inp, \zkproof)$ are not on the list $Q$ and the extractor $\ext_{\adv_\se}(\REL, \inp, \zkproof; r)$ fails to output $\wit$ such that $\REL(\inp, \wit)$.
% 	Denote by $\vec{a_0} = (a_1, \ldots, a_i)$ and by $\vec{a_1} = (a_{i + 1}, \ldots, a_\mu)$.
% 	Let $\event{E}$ be an event that $\vec{a_0}$ comes from a proof simulated by $\simulator$ and let
% 	\michals{10.06}{I am not sure this line of proof could work. The problem is that we cannot build a simple reduction that breaks the soundness of $\proofsystem$ as that would require $\adv_\se$ not to ask about the simulated proofs (which cannot be delivered by $\bdv_\snd$ as he cannot produce them).}
% \end{proof}

\begin{theorem}[Simulation extractability of the Fiat--Shamir transform III]
	\michals{03.07}{The label of this theorem will probably be changed to II (from III)}
	\label{thm:wit_ext_em_FS_III}
	Let $\proofsystem = (\kgen, \prover, \verifier, \simulator)$ be an interactive $\ur{i}$ protocol for a relation $\REL$.
	Assume there exists an extractor $\ext$ that extracts the witness from a $(1, \ldots, 1, n_{i + 1}, \ldots, n_\mu)$-tree of accepting transcripts of $\proofsystem$.
	Then $\proofsystem_\fs$ is simulation-extractable in the random oracle model if $N =\prod_{j = i}^\mu = \poly$.
	% Furthermore the extractor $\ext_\fs$ for $\proofsystem_\fs$ needs to run $\simulator$ $N$ times.
\end{theorem}
\begin{proof}
	The proof goes similarly to \cite[Theorem 3]{INDOCRYPT:FKMV12}. For the sake of clarity let divide the simulator algorithm $\simulator_\fs$ of $\proofsystem_\fs$  into two subroutines:
	\begin{description}
		\item[$\simulator_{\fs, \ro}$] that takes care about random oracle queries. Assume that there is an upper bound $Q = \poly$ for the number of queries that may be submitted.
		For a query $x$ simulator $\simulator_{\fs, \ro}$ checks whether a list of queries $L$ already contains a pair $(x, y)$, for some $y$, and, if that is the case, outputs $y$.
		Otherwise, it picks an element $y'$ from the random oracle range, outputs it and adds $(x, y')$ to $L$. Importantly $y'$ is picked accordingly to the randomness tape provided to $\simulator_{\fs, \ro}$, i.e.~one may assume that $\simulator_{\fs, \ro}$ gets as input a randomness tape $r$ that provides values $y_1, \ldots, y_Q$.
		When the simulator needs to answer a fresh query $x$ it takes the successive $y_i$ from $r$.
		\item[$\simulator_{\fs, \zkproof}$] that provides simulated proofs. The simulator may also program random oracle queries. That is, it may add pair $(x, y)$ to $L$ unless there is a pair that have $x$ on the first position. In that case it aborts.
	\end{description}

	Let $\adv_\se^{\simulator_\fs}$ be a simulation-extractability adversary for $\proofsystem_\fs$, $\inp$ the instance $\adv_\se$ proves and $\zkproof = \vec{a} = (a_0, \ldots, a_\mu)$ the corresponding acceptable proof.
	W.l.o.g.~we may assume that $(\inp, \pi)$ are output after $\adv_\se$ learnt simulated proofs from $\simulator_{\fs, \zkproof}$.

	For each $j > i$, divide the adversary's proof $\zkproof$ into two parts:
	first, $\vec{a}_{[0:j]} = (a_0, \ldots, a_j)$ and second $\vec{a}_{{[j + 1:\mu]}} = (a_{j + 1}, \ldots, a_\mu)$.
	\michals{10.06}{I think this generalised idea of unique resp. may not make much sense, we should explicitly require that $i = \mu - 1$. Otherwise, the prover gets a randomised challenge from the verifier, so his answer is not unique. OTOH, we may require that for every challenge there is only one correct answer.}
	Note that $(\inp, \vec{a}^{[0:j]})$ is a query to the random oracle that is performed by the adversary.
	Otherwise, if the query was made by the simulator $\simulator_{\fs, \zkproof}$ then, since $\proofsystem$ is an $\ur{i}$-protocol and $j > i$, a proof starting with $(\inp, \vec{a}_{[0:j]})$ is in the list of simulated proofs $Q$ and cannot be used by the simulation-extractability adversary $\adv_\se$.

	Now, after $\simulator_{\fs, \ro}$ was queried with $(\inp, \vec{a}_{[0:j]})$, the adversary $\adv_\se$ is rewound and a new further queries responses for the simulator are picked. This step is repeated $n_j$ times.
	More precisely, assume that $(\inp, \vec{a}_{[0:j]})$ was $J_j$-th query to $\simulator_{\fs, \ro}$, then the sequence of responses $\vec{y} = y_1, \ldots, y_Q$ changes to $\vec{y'} = y_1, \ldots, y_{J_j}, y'_{J_j + 1}, \ldots, y'_{Q}$, for some fresh and independent $y'_{J_j + 1}, \ldots, y'_{Q}$ picked accordingly to $r$.
	W.l.o.g.~we can assume that all sequences $\vec{y}$ are registered and stored and when a new $\vec{y'}$ comes and for some $k > J_j$ holds $\vec{y_k} = \vec{y'_k}$ then the simulator $\simulator_{\fs, \ro}$ aborts. However, this happens with negligible probability only as the number of drawn $\vec{y}$-sequences is polynomially bounded and the number of possible values they pick is exponential in the security parameter.

	Since the first $J_j$ queries do not change, the adversary, whose randomness tape remains the same, submits $(\inp, \vec{a}_{[0:j]})$ as its $J_j$-th query regardless it was rewound.
	That way, for each $j$, new $\prod_{k = 1}^{j} n_k$ partial transcripts $(\inp, \vec{a}_{[0 : j]})$ is obtained, each of the previous $\prod_{k = 1}^{j - 1} n_k$ transcripts is extended in $n_j$ different ways respectively to different sequence of responses of $\simulator_{\fs, \ro}$.

	When $j$ reaches $\mu$, there are $\prod_{j}^{\mu} n_j$ transcripts that makes an $(1, \ldots, 1, n_{i + 1}, \ldots, n_\mu)$-tree of accepting transcripts. Thus, from the forking lemma (cf.~\cref{lem:bootle_forking_lemma}), there exists an extractor $\ext_\fs$ that recreates a witness $\wit$ such that $\REL(\inp, \wit)$.
	\qed
\end{proof}

\section{Simulation extractability of $\plonk$}
\newcommand{\chz}{\mathfrak{z}}
\paragraph{Simulation in \plonk.}
The simulator $\simulator$ in $\plonk$ proceeds according to the following steps:
\begin{description}
	\item[Round 1]
	Since the simulator does not know a witness $\wit$ for the proven statement $\inp$, $\simulator$ cannot compute the output of this round accordingly to the protocol. Instead, it picks randomly both the "blinders" $b_1, \ldots, b_6$ and evaluations of polynomials $\p{a}, \p{b}, \p{c}$ by picking their coefficents randomly and outputting $\gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi)}$.
	To ensure deterministic nature of the simulation from now on, the simulator also picks value $w$ which later will be output as $\p{W}_\chz(\chi)$ and determine the value of $\p{W}_{\chz \omega}(\chi)$.
	\item[Round 2]
	Although the simulator controls fully the random oracle, it takes its permutation argument challenges $\beta, \gamma$.
	Similarly as in the previous round, the simulator cannot evaluate the requested polynomial $\p{z}$ honestly as it does not know the witness, picks its coefficients randomly and outputs $\gone{\p{z}(\chi)}$.
	\item[Round 3 and 4]
	In these rounds $\simulator$ proceeds as an honest prover would using its knowledge of coefficents of polynomials $\p{a}, \p{b}, \p{c}, \p{z}$.
	More concretely, in Round 3, the simulator outputs an evaluation of the quotient polynomial $\p{t}$: $\gone{\p{t}_{lo}(\chi), \p{t}_{mid}(\chi), \p{t}_{hi}(\chi)}$ and in
	Round 4 it computes the challenge $\chz$ and outputs $\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{z}(\chz \omega), \p{t}(\chz)$ along with evaluations of permutation-related polynomials $\p{S_{\sigma 1}(\chz)}, \p{S_{\sigma 2}(\chz)}$.
	\item[Round 5]
	In this round the prover is asked to output values $\gone{\p{W}_{\chz}(\chi), \p{W}_{\chz \omega}(\chi)}$ assuring that required polynomials' evaluations are computed correctly. The simulator proceeds similarly, however it uses its knowledge of the simulation trapdoor $\chi$ since the evaluations were computed without use of the witness.
\end{description}
	We describe the output of the simulator in Round 5 in more details.
	Before that it should be explained how the \plonk's verifier works.

	Recall that an honest prover takes $v$ as a challenge and computes $\gone{\p{W}_{\chz}(\chi), \p{W}_{\chz \omega}(\chi)}$ as
	\begin{align}
		& \p{W}_{\chz}(X) = \frac{1} {X - \chz} \left(
			\begin{aligned}
				& (\p{t}_{lo}(X) + \chz^\numberofconstrains \p{t}_{mid}(X) + \chz^{2\numberofconstrains} \p{t}_{hi}(X)) \\
				+ & v (\p{r}(X) - \p{r}(\chz)) \\
				+ & v^2 (\p{a}(X) - \p{a}(\chz)) \\
				+ & v^3 (\p{b}(X) - \p{b}(\chz)) \\
				+ & v^4 (\p{c}(X) - \p{c}(\chz)) \\
				+ & v^5 (\p{S_{\sigma 1}}(X) - \p{S_{\sigma 1}}(\chz)) \\
				+ & v^6 (\p{S_{\sigma 2}}(X) - \p{S_{\sigma 2}}(\chz))
			\end{aligned}
		\right)\,,\\
		& \p{W}_{\chz \omega}(X) =  %\left(
			\begin{aligned}
				\frac{\p{z}(X) - \p{z}(\chz \omega)}{X - \chz \omega}
			\end{aligned}
		%\right)
		\,.
	\end{align}
	The simulator computes $\gone{\p{W}_{\chz}(\chi), \p{W}_{\chz \omega}(\chi)}$ such that the verification equation holds, outputs the proof
	\[
	\zkproof = \left(
		\begin{aligned}
			& \gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi), \p{z}(\chi), \p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi), \p{a}(\chi), \p{a}(\chi)}\\
			& \p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz), \p{r}(\chz), \p{z}(\chz \omega)
		\end{aligned}
	\right)
	\]
	and gets $u$ as a final challenge (which it does not reply to).\michals{15.06}{It may be better to just say that $u$ is a random picked by the verifier and not put it as an additional challenge.}

	More precisely, the verifier, following the \plonk{} paper, computes $\gone{D, E, F}$ as follows:
	$\gone{D} = v \gone{r} + u \gone {z}$ that is
	\begin{align*}
		\gone{D} & = v
		\left(
		\begin{aligned}
			& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}  \gone{\selright} + \p{c}  \gone{\seloutput} + \\
			& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
			% &   \\
			& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha  \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)})
		\end{aligned}
		\right) + \\
		& + u \gone{\p{z}(\chi)}\,.
		% \gone{D} & = \p{a}(\chz)\p{b}(\chz)v \cdot \gone{\selmulti} + \p{a}(\chz) v \gone{\selleft} + \p{b} v \gone{\selright} + \p{c} v \gone{\seloutput} + \\
		% & + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha v + \\
		% & + \lag_1(\chz) \alpha^2 v + u) \gone{\p{z}(\chi)} + \\
		% & - (\p{a}(\chz) + \beta \p{S_{\sigma 1}} + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}} + \gamma) \alpha v \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)}
	\end{align*}
	Next it computes $\gone{F}$:
	\begin{align*}
		\gone{F} & = \left(\gone{\p{t_{lo}}(\chi)} + \chz^\numberofconstrains \gone{\p{t_{mid}}(\chi)} + \chz^{2 \numberofconstrains} \gone{\p{t_{hi}}(\chi)}\right) + u \gone{\p{z}(\chi)} + \\
		& + v
		\left(
		\begin{aligned}
			& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}  \gone{\selright} + \p{c}  \gone{\seloutput} + \\
			& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
			% &   \\
			& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha  \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)})
		\end{aligned}
		\right) \\
		% & + \gone{D} +
		& + v^2 \gone{\p{a}(\chi)} + v^3 \gone{\p{b}(\chi)} + v^4 \gone{\p{c}(\chi)} + v^5 \gone{\p{S_{\sigma 1}(\chi)}} + v^6 \gone{\p{S_{\sigma 2}}(\chi)}
	\end{align*}
	Folowed by $\gone{E}$:
	\begin{align*}
		\gone{E}  = \frac{1}{\p{Z_H}(\chz)} & \gone{
		\begin{aligned}
			& \p{r}(\chz) + \pubinppoly(\chz) + \\
			& - \alpha \left( (\p{a}(\chz) + \beta \p{S_{\sigma 1}} (\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}} (\chz) + \gamma) (\p{c}(\chz) + \gamma) \p{z}(\chz \omega) \right) + \\
			& + \alpha^2  \lag_1 (\chz)
		\end{aligned}
		}\\
		 + & \gone{v \p{r}(\chz) + v^2 \p{a}(\chz) + v^3 \p{b}(\chz) + v^4 \p{c}(\chz) + v^5 \p{S_{\sigma 1}}(\chz) + v^6 \p{S_{\sigma 2}}(\chz) + u \p{z}(\chz \omega) }
	\end{align*}

	Finally, the verifier checks whether the verification equation holds:
		\begin{multline}
			\label{eq:ver_eq}
			\left(
			\gone{\p{W_{\chz}}(\chi)} + u \cdot \gone{\p{W_{\chz \omega}}(\chi)}
			\right) \bullet
			\gtwo{\chi} = \\
			\left(
				\chz \cdot \gone{\p{W_{\chz}}(\chi)} + u \chz \omega \cdot \gone{\p{W_{\chz \omega}}(\chi)} + \gone{F} - \gone{E}
			\right) \bullet
			\gtwo{1}\,.
		\end{multline}
	The verification equation is a batched version of the verification equation from \cite{AC:KatZavGol10} which allows the verifier to check openings of multiple polynomials in two points (instead of checking an opening of a single polynomial at one point).


\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto,additional_bib}

\appendix
\section{$\plonk$ protocol rolled-out}

\section{Old subsections}
\subsection{Interpolation of rational functions}
Let $F(X) = P(X) / Q(X)$ be a rational function defined over $\FF(X)$ such that $\deg P = m_a$ and $\deg Q = m_b$. We call a set $V = \smallset{(x_i, y_i)}_{i \in I}$ a \emph{support set} of $F$ if for all $i \in I$ holds $F(x_i) = y_i$.
As shown by Minsky et al.~in \cite{TIT:MinTraZip03} if $P$ and $Q$ are monic, then a support set $V$ of size at least $m_a + m_b$ unambiguously determines $F$.

\begin{lemma}[Rational function interpolation~{\cite[Theorem 4.1]{TIT:MinTraZip03}}]
	\label{lem:rational_function_interpolation}
  Let $F(X) = P(X) / Q(X)$ be a rational function and let $P(X) = X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$. Let $V_F$ be a support set of size $m = m_a + m_b$, then $V_F$ determines $F$ unambiguously.
\end{lemma}

Note that the theorem above assumes that the polynomials determining $F$ are monic and their degrees are known. In general, a rational function is not defined unambiguously and $F(X) = P(X) / Q(X) \in \FF(X)$ represents a whole equivalence class of functions
\[
	F(X) = \frac{P(X)}{Q(X)} \equiv \frac{P(X) f(X)}{Q(X) f(X)}\,,
\]
for some $P(X), Q(X), f(X) \in \FF[X]$.
However, when the degree of the denominator polynomial $Q(X)$ is known, then the function is determined up to $f(X)$ that are \emph{constant}. Any other polynomial would change the denominator degree).
Furthermore, if in $Q(X)$ there is at least one coefficient that is already known, then the whole function $F(X)$ is determined uniquely, i.e.~$f(X) \equiv 1$. Other $f$-s would affect the known coefficient $q_i$.
The following lemma can be formulated:
\begin{lemma}
	\label{lem:rational_function_interpolation_2}
	Let $F(X) = P(X) / Q(X)$ be a rational function for $P(X) = p_0 X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = q_0 X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$ such that $q_0$ is non-zero and at least one of the coefficients $q_i$ is known.
	Let $V_F$ be a support set of size $m = m_a + m_b + 1$, then $V_F$ determines $F$ unambiguously.
\end{lemma}
\begin{proof}
	The lemma has almost the same proof as \cref{lem:rational_function_interpolation}. Consider two functions $P_0 / Q_0$, $P_1 / Q_1$ that share the same values for each $x_i \in V_F$. That is,
	\[
		\frac{P_0(x_i)}{Q_0(x_i)} = \frac{P_1(x_i)}{Q_1(x_i)}\,.
	\]
	Polynomial $P_0(X) Q_1(X) - P_1(X) Q_0(X)$ has degree at most $(m_a + m_b)$ and zeroes in at least $(m_a + m_b + 1)$ points, thus is identically zero. Thus
	\[
		\frac{P_0(X)}{Q_0(X)} = \frac{P_1(X)}{Q_1(X)}\,
	\]
	and the functions determined by $P_0, Q_0$ and $P_1, Q_1$ are in the same equivalence class (i.e.~are the same function). Considering the observations above, only one function in this class exists if we specify concrete degree of the denominator polynomial and one of its coefficients.
	\qed
\end{proof}

\section{Simulation extractability of \plonk [OLD]}
The main idea behind showing that \plonk{} is simulation extractable relies on the result by Faust et al.~\cite{INDOCRYPT:FKMV12} where the authors show that a public-coin special-sound protocol made non-interactive by the Fiat--Shamir transform is simulation extractable.
Thus showing that \plonk{} is special-sound and public-coin is enough to show its simulation extractability. It is obvious that \plonk{} is public-coin, thus what remains is to show it is also special-sound.

To that end we take one of the polynomials that are computed by the prover and which contains the witness as parts of the coefficients and, by programming the random oracle and rewinding the prover, we evaluate it on many different points. This allows to recreate the coefficients of the function and therefore the witness.
%
More precisely, the polynomial $Z(X)$ computed by the prover in the second round of the protocol is used. First the polynomial is expressed as a rational function $\Gamma$ of a formal variable $X_\gamma$, which is evaluated as $\gamma$.
The variable $\gamma$ is given by the random oracle $\ro$ prior to Round 2.
By programming $\ro$ and rewinding the prover one can evaluate $\Gamma$ in various points one can recreate the coefficients of $\Gamma$ and compute the witness.

We note that the extraction procedure is not very efficient. Function $\Gamma$ has numerator and denominator polynomials of degrees linear to the size of the statement. Thus a linear number of rewinds is necessary to recreate the witness.
However, we point out that the efficiency of the extractor does not influences the efficiency of a protocol run between the prover and verifier.

\begin{theorem}[Witness-extended emulation in \plonk{}]
  \plonk{} has witness-extended emulation in the random oracle model.
\end{theorem}
\begin{proof}
In the second round of \plonk{} the prover gets from a random oracle $\beta = \ro(0, \tr)$ and $\gamma = \ro(1, \tr)$, where $\tr$ is the transcript of the previous messages exchanged in the protocol. Then he computes a polynomial
\begin{multline*}
  \label{eq:Z}
  Z(X) = (b_7 X^2 + b_8 X + b_9) (X^\instsize - 1) + L_1 (X) + \\
   + \sum_{i = 1}^{\instsize - 1}\brak{L_{i + 1}(X) \prod_{j = 1}^{i}
  \frac{(\wit_j + \beta \w^{j - 1} + \gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + \gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + \gamma)}
  {(\wit_j + \sigma(j)\beta + \gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + \gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + \gamma)}
  }\,
\end{multline*}
and makes $\gone{Z(\chi)}$ part of his proof.
Here, $L_i$ are Lagrange basis polynomials, $\smallset{1, \w, \ldots, \w^{\instsize - 1}}$ are roots of unity, $\sigma(j)$ are values determined by the permutation, which defines the circuit (i.e.~which gate is connected to which gate), and $k_1, k_2$ are other \emph{publicly known} values.

Since $\chi$ is fixed, $Z(\chi)$ can be expressed as an evaluation of a rational function $\Gamma(X_\gamma)$ at $\gamma$. We will now focus on interpolating $\Gamma$.
For the sake of readability we denote by $p_i (X_\gamma)$ a polynomial corresponding to the $i$-th product of the numerator of the big fraction in $Z$, that is
\[
  p_i(X_\gamma) = \prod_{j = 1}^{i} L_{i + 1} (\wit_j + \beta \w^{j - 1} + X_\gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + X_\gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + X_\gamma)\,.
\]
Similarly, $q_i (X_\gamma)$ denotes the $i$-th product of the denominator
\[
  q_i(X_\gamma) = \prod_{j = 1}^{i} (\wit_j + \sigma(j)\beta + X_\gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + X_\gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + X_\gamma)\,.
\]

To make the necessary summation all fractions are given a common denominator equal $q_1 (X_\gamma) \cdot \ldots \cdot q_{\instsize - 1} (X_\gamma)$. After this operation, $\Gamma(\gamma)$ can be written as
\begin{multline*}
  \Gamma(\gamma) = (b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi) + \\
   + \brak{\frac{
   p_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma) + q_1(\gamma) p_2(\gamma) q_3(\gamma) \ldots q_{\instsize - 1}(\gamma) + \ldots + q_1(\gamma) \ldots q_{\instsize - 2}(\gamma) p_{\instsize - 1}(\gamma)
   }{
   q_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma)
   }
  }\,.
\end{multline*}
Finally, let
\[
  \Gamma (X_\gamma) = \frac{N(X_\gamma)}{D(X_\gamma)}\,,
\]
where
\begin{align*}
  N(X_\gamma) & = \brak{(b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi)} \cdot q_1(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \\
   & + p_1(X_\gamma) q_2(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + q_1(X_\gamma) p_2(X_\gamma) q_3(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \ldots \\
   & + q_1(X_\gamma) \ldots q_{\instsize - 2}(X_\gamma) p_{\instsize - 1}(X_\gamma)\,,\\
  D(X_\gamma) & = q_1(X_\gamma)  \ldots q_{\instsize - 1}(X_\gamma)\,.
\end{align*}
Both $N(X_\gamma)$ and $D(X_\gamma)$ have degree $\maxdegree = 3 \frac{(\instsize - 1) \instsize}{2}$, since $\deg p_i (X_\gamma) \allowbreak = \deg q_i (X_\gamma) = 3 i$.

Observe that
\begin{inparaenum}[(i)]
	\item the degree of polynomial $D(X_\gamma)$ is known and
	\item one of its coefficients is known, more precisely, the coefficient by the highest power, $X_\gamma^{3i}$, is $1$.
\end{inparaenum}
Hence the requirements for \cref{lem:rational_function_interpolation_2} are met.

Following \cref{def:wit_ext_em} we can assume that the extractor gets as input the trapdoor corresponding to the CRS and knows $\chi$.
Thus the only unknown values in $Z$ are the values of witness elements $\smallset{\wit_{\instsize + j}}_{j = 1}^{2 \instsize}$ (note that the values $\smallset{\wit_{j}}_{j = 1}^{\instsize}$ are public, i.e.~$\smallset{\wit_{j}}_{j = 1}^{\instsize} = \inp$) and randomisers $b_7, b_8, b_9$ which are picked by the prover at the beginning of the protocol.
We need to show now that information the extractor has about the coefficients of $\Gamma(X_\gamma)$ is enough to extract the witness, even though some coefficients may depend on
\begin{inparaenum}[(i)]
	\item more than one witness element and\label{it:many_wit}
	\item randomisers $b_7, b_8, b_9$.\label{it:randomisers}
\end{inparaenum}
 %
\task{15.05}{Missing part -- show that we know enough about coefficients of $\Gamma$ to extract the witness even though (1) some coefficients may depend on many witness parts, (2) some coefficients may depend on the blinders $b_i$}
%
Again we focus on the denominator function $D(X_\gamma)$ to tackle \cref{it:many_wit,it:randomisers}.
First, we look at the coefficient by the $X_\gamma^{\maxdegree - 1}$ (i.e.~the second highest power) which is  \hl{continue}
That resolves \cref{it:many_wit}. The other issue that comes with \cref{it:randomisers} is easy since there are no randomisers used in the denominator polynomial.
\qed
\end{proof}

\end{document}
