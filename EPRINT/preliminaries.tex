% !TEX root = main.tex
% !TEX spellcheck = en-US
\section{Preliminaries}
\label{sec:preliminaries}


\paragraph{Notation.} Let $\ppt$ denote probabilistic polynomial-time and $\secpar \in \NN$ be the
security parameter. %All adversaries are stateful. 
For an algorithm $\adv$, 
%let
%$\image (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), 
let
$\RND{\adv}$ denote the set of random tapes of correct length for $\adv$
(assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote
the random choice of the randomiser $r$ from $\RND{\adv}$. We denote by $\negl$
($\poly$) an arbitrary negligible (resp.~polynomial) function.
%
%For probability ensembles $X = \smallset{X_\secpar}_\secpar$ and
%$Y = \smallset{Y_\secpar}_\secpar$, with distributions $X_\secpar, Y_\secpar$ that have
%\emph{statistical distance} $\SD(X_\secpar, Y_\secpar) = \epsilon(\secpar)$ 
%if
%$\sum_{a \in \supp{X_\secpar \cup Y_\secpar}} \abs{\prob{X_\secpar = a} -
%  \prob{Y_\secpar = a}} = \epsilon(\secpar)$. 
%we write $X \approx_\secpar Y$ if
%$\SD(X_\secpar, Y_\secpar) \leq \negl$. 
For functions $a(\secpar)$, $b(\secpar)$ and probability ensembles $X = \smallset{X_\secpar}_\secpar$,
$Y = \smallset{Y_\secpar}_\secpar$ we
write $a(\secpar) \approx_\secpar b(\secpar)$ if
$\abs{a(\secpar) - b(\secpar)} \leq \negl$ and $X \approx_\secpar Y$ if they have \emph{statistical distance} $\SD(X_\secpar, Y_\secpar) \leq \negl )$, respectively. \medskip

% For a probability space
% $(\samplespace, \eventspace, \probfunction)$ and event $\event{E} \in \eventspace$ we
% denote by $\nevent{E}$ an event that is complementary to $\event{E}$,
% i.e.~$\nevent{E} = \samplespace \setminus \event{E}$.

% \begin{lemma}[Difference lemma,~{\cite[Lemma 1]{EPRINT:Shoup04}}]
% 	\label{lem:difference_lemma}
% 	Let $\event{A}, \event{B}, \event{F}$ be events defined in some probability
% 	space, and suppose that $\event{A} \land \nevent{F} \iff \event{B}
% 		\land \nevent{F}$.  Then 
% 	$
% 		\abs{\prob{\event{A}} - \prob{\event{B}}} \leq \prob{\event{F}}\,.
% 	$
% \end{lemma}

%\subsection{Proof Systems With Updateable Setups and Random Oracles}
\noindent Let $\prover$ and $\verifier$ be $\ppt$ algorithms, the former called the \emph{prover}
and the latter the \emph{verifier} of a proof system. Both algorithms take a pre-agreed structured reference string $\srs$ as input. The structured reference strings we consider are (potentially) updatable, a notion we recall shortly.

We focus on proof systems made non-interactive via the multi-message Fiat--Shamir transform presented below where prover and
verifier are provided with a random oracle $\ro$. 
We denote by $\zkproof$ a proof created by $\prover$ on input
$(\srs, \inp, \wit)$. We say that proof is acceptable if $\verifier(\srs, \inp,
\zkproof)$ accepts it.



%The simulator
%$\simulator$ is not only given access to $\ro$, but it can also \emph{program}
%it. That is, it can require that for $(x, y)$ of its choice, $\ro (x) = y$.


  
\iffalse
\subsection{Zero-Knowledge Proof Systems}\label{prelim:nizk}
In a zero-knowledge proof system, a prover convinces the verifier of the veracity of a statement
without leaking any other information. The zero-knowledge property is proven by constructing a
simulator that can simulate the view of a cheating verifier without knowing the secret
information -- witness -- of the prover. A proof system has to be sound as well, i.e.~for a
malicious prover it should be infeasible to convince a verifier of a false statement. Here, we
focus on proof systems, so-called arguments, that guarantee soundness against $\ppt$ malicious provers. 
\markulf{24.04}{Nice text, but maybe too basic? Also we don't really have views, but really reconstruct the non-interactive proof.}
Typically, a stronger notion of soundness is required -- besides requiring that the
verifier rejects proofs of statements outside the language, we request from the
prover to know a witness corresponding to the proven statement. This property is
called \emph{knowledge soundness}. In this work we investigate an even stronger notion of soundness, \emph{simulation extractability} for non-interactive protocols obtained from interactive arguments via the \emph{Fiat--Shamir heuristic} via random oracles in a setting with an \emph{updatable common reference string.} 

We now introduce these concepts.
\fi


\subsection{Updatable SRS Setup Ceremonies}\label{def:upd-scheme}

%Let $\prover$ and $\verifier$ be $\ppt$ algorithms, the former called \emph{prover}
%and the latter \emph{verifier}. We allow our proof system to have a setup, i.e.~there is a
%$\kgen$ algorithm that takes as input the relation description $\REL$ and outputs a common
%reference string $\srs$.

The definition of updatable SRS ceremonies of~\cite{C:GKMMM18} requires the following algorithms.

\begin{itemize} 
	\item
	$(\srs,\rho) \gets \kgen(\REL)$ is a PPT algorithm that takes a relation $\REL$ and outputs a SRS $\srs$, and correctness proof $\rho$.
	\item
	$ (\srs',\rho') \gets \upd(\srs, \{\rho_j \}_{j=1}^n)$ is a PPT algorithm that takes a SRS $\srs$, a list of update proofs and outputs an updated SRS together with a proof of correct update. 
	\item
	$b \gets \verifyCRS(\srs, \{\rho_j \}_{j=1}^n)$ is a DPT algorithm that takes a SRS $\srs$, a list of update proofs, and outputs a bit indicating acceptance or not.\footnote{For instance \plonk{} and \marlin{} will use the $\kgen$, $\upd$ and $\verifyCRS$ algorithms in~\cref{fig:upd-scheme}.}
\end{itemize}



In the next section, we define security notions in the updatable setting by giving the adversary access to an SRS update oracle $\initU$, defined in~\cref{fig:upd}. The oracle allows the adversary to control the SRS generation. A trusted setup can be expressed by the updatable setup definition simply by restricting the adversary to only call the oracle on $\intent = \setup$ and $\intent = \final$. Note that a soundness adversary now has access to both the random oracle $\ro$ and $\initU$:  $(\inp, \zkproof) \gets \adv^{\initU,\ro}(1^\secpar)$. \chaya{can we move the figure to section 5? I know we talk about the oracle here, but I am wondering if there is a way to keep $\initU$ general here and give the description below specific to Plonk/Marlin later on}.

\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}% 

\begin{figure}[t!]
	\centering
	\fbox{
		\begin{minipage}[t]{0.60\linewidth}
			\procedure{$\initU(\intent, \srs_n,\{\rho_j \}_{j=1}^n)$}{
				\pcif \srs \neq \bot: \pcreturn \bot \\
				\pcif (\intent = \setup): \\
				\t (\srs',\rho') \leftarrow \kgen(\REL)\\
				\t Q_\srs \gets Q_\srs \cup \{(\srs',\rho')\}\\
				\t \pcreturn (\srs',\rho')\\
				%
				\pcif (\intent = \update): \\
				\t b \gets \verifyCRS(\srs_n, \{\rho_j \}_{j=1}^{n})\\
				\t \pcif (b=0): \pcreturn \bot \\
				\t (\srs',\rho') \leftarrow \upd (\srs_n,\{\rho_j \}_{j=1}^n)\\
				\t Q_\srs \gets Q_\srs \cup \{(\srs',\rho')\}\\
		 	\pccomment{$Q_\srs = (Q^{(1)}_\srs, Q^{(2)}_\srs) \text{ s.t. }   Q^{(2)}_\srs \text{ contains the update proofs in } Q_\srs$ } \\
				\t \pcreturn (\srs',\rho')\\
				%
				\pcif (\intent = \final): \\
				\t b \gets \verifyCRS(\srs_n,\{\rho_j \}_{j=1}^{n})\\
				\t \pcif (b=0) \vee Q^{(2)}_\srs \cap \{ \rho_j \}_i = \emptyset: \pcreturn \bot \\
				\t 
				\t \srs \gets \srs_n, \pcreturn \srs \\
				%
				\pcelse \pcreturn \bot
			}
		\end{minipage}
	}
	\caption{The oracle defines the notion of updatable SRS setup.} 
		\label{fig:upd}
\end{figure}





% \ourpar{Updatability and zero knowledge.}
% Groth et al.~\cite{C:GKMMM18} shown that if a proof system is zero-knowledge against adversaries who picks the SRS, then it is updatable zero-knowledge. We call such systems \emph{subvertible zero knowledge}, cf.~\cite{AC:BelFucSca16,AC:ABLZ17}. It was shown that Plonk, Sonic, Marlin and virtually any proof system with a SRS consisting of monomials are subvertible zero-knowledge.

\ourpar{Remark on universality of the SRS.} The proof systems we consider in this work are universal. This means that both the relation $\REL$ and the reference string $\srs$ allows to prove arithmetic constraints defined over a particular field up to some size bound. The public instance $\inp$ must determine the constraints. 
If $\REL$ comes with any auxiliary input, the latter is benign. 
%The
%description of $\REL$ fixes the security parameter $\secpar$ and the order of a
%group $\GRP$, if the relation is a relation on field elements (as usually the case for zkSNARKs). 
%We assume that the $\srs$ defines the relation, and for universal proof
%systems, such as Plonk and Sonic, we treat both the reference string and the relation as
%universal. 
We elide public preprocessing of constraint specific proving and verification keys. While important for performance, this modeling is not critical for security.
%\markulf{24.04}{Tighten the discussion of universality, one paragraph is enough!}


\subsection{Multi-Message Fiat-Shamir Compiled Provers and Verifiers}
Given interactive prover and (public coin) verifier $\prover', \verifier'$ that exchange messages $(a_1, c_1, \ldots, a_{\mu}, c_{\mu}, a_{\mu + 1})$, where $a_i$ comes from
$\prover'$ and $c_i$ comes from $\verifier'$, the $(2\mu + 1)$-message Fiat-Shamir heuristic defines non-interactive provers and verifiers $\prover, \verifier$ as follows:

\begin{compactitem}
	\item $\prover$ behaves as $\prover'$ except after sending message
	  $a_i$, $i \in \range{1}{\mu}$, the prover does not wait for
	  the message from the verifier but computes it locally setting $c_i
	  = \ro(\zkproof[0..i])$, where $\zkproof[0..j] = (\inp, a_1, c_1, \ldots,
	  a_{j - 1}, c_{j - 1}, a_j)$. (Importantly, $\zkproof[0..\mu + 1] =
	  (\inp, \zkproof)$).\footnote{For Fiat--Shamir based SoK the message signed $m$ is added to $\inp$ before hashing.}
	\item $\verifier$ behaves as $\verifier'$ but does not provide
	  challenges to the prover's proof. Instead it computes the
	  challenges locally as $\prover$ does. Then it verifies the
	  resulting transcript $\zkproof$ as the verifier $\verifier'$ would. 
	\end{compactitem}

\iffalse
\subsection{From interactive to non-interactive---the Fiat--Shamir transform}
Consider a $(2\mu + 1)$-message, public-coin, honest verifier zero-knowledge
interactive proof system
$\proofsystem = (\kgen, \prover, \verifier, \simulator)$ for
$\REL \in \RELGEN(\secparam)$.  Let $\zkproof$ be a proof performed by the
prover $\prover$ and verifier $\verifier$ compound of messages
$(a_1, b_1, \ldots, a_{\mu}, b_{\mu}, a_{\mu + 1})$, where $a_i$ comes from
$\prover$ and $b_i$ comes from $\verifier$.  Denote by $\ro$ a random oracle.
Let $\proofsystem_\fs = (\kgen_\fs, \prover_\fs, \verifier_\fs, \simulator_\fs)$
be a proof system such that
\begin{compactitem}
  \item $\kgen_\fs$ behaves as $\kgen$.
  \item $\prover_\fs$ behaves as $\prover$ except after sending message
    $a_i$, $i \in \range{1}{\mu}$, the prover does not wait for
    the message from the verifier but computes it locally setting $b_i
    = \ro(\zkproof[0..i])$, where $\zkproof[0..j] = (\inp, a_1, b_1, \ldots,
    a_{j - 1}, b_{j - 1}, a_j)$. (Importantly, $\zkproof[0..\mu + 1] =
    (\inp, \zkproof)$).\footnote{For Fiat--Shamir based SoK the message signed $m$ is added to $\inp$ before hashing.}
  \item $\verifier_\fs$ behaves as $\verifier$ but does not provide
    challenges to the prover's proof. Instead it computes the
    challenges locally as $\prover_\fs$ does. Then it verifies the
    resulting transcript $\zkproof$ as the verifier $\verifier$ would. 
  \item $\simulator_\fs$ behaves as $\simulator$, except when
    $\simulator$ picks challenge $b_i$ before computing message $\zkproof[0, i]$, $\simulator_\fs$ programs the
    random oracle to output $b_i$ on $\zkproof[0, i]$.
  \end{compactitem}

\noindent
The Fiat--Shamir heuristic states that $\proofsystem_\fs$ is a zero-knowledge
non-interactive proof system for $\REL \in \RELGEN(\secparam)$.


\markulf{24.04}{What do we ned of the below?}

Let $\prover$ and $\verifier$ be $\ppt$ algorithms, the former called \emph{prover}
and the latter \emph{verifier}. 
%We allow our proof system to have a setup, i.e.~there is a
%$\kgen$ algorithm that takes as input the relation description $\REL$ and outputs a common reference string $\srs$.
We denote by $\zkproof$ a proof created by $\prover$ with input
$(\srs, \inp, \wit)$. We say that proof is acceptable if $\verifier (\srs, \inp,
\zkproof)$ accepts it. We focus on proof systems where $\prover$ and
$\verifier$ are given oracle access to a random oracle $\ro$. The simulator
$\simulator$ is not only given access to $\ro$, but it can also \emph{program}
it. That is, it can require that for $(x, y)$ of its choice, $\ro (x) = y$.
% \changedm{This is
% formalized by dividing the simulator into two subroutines $\simulator_1,
% \simulator_2$ that share state. The first subroutine $\simulator_1$ answers random
% oracle queries, while the second one provides simulated proofs.}

A non-interactive  proof system $\proofsystem = (\kgen, \prover, \verifier, \simulator)$ for $\RELGEN$ is
required to have three properties: completeness, soundness and zero knowledge, which are
defined as follows:
%\hamid{10.2}{Should we change the definitions to the updatable setting? In that case, we should move updatable section earlier before this!}
% \begin{description}

	\markulf{22.04}{I don't think we need formal definitions for completeness and soundness}

\ourpar{Completeness.}
%\item[Completeness]
  A non-interactive proof system $\proofsystem$ is
  \emph{complete} if an honest prover always convinces an honest verifier, that
  is for all $\REL \in \RELGEN(\secparam)$ and $(\inp, \wit) \in \REL$
	\[
		\condprob{\verifier^\ro (\srs, \inp, \zkproof) = 1} {\srs \gets \kgen(\REL),
      \zkproof \gets \prover^\ro (\srs, \inp, \wit)}\,.
	\]
    % \item[Soundness]
\ourpar{Soundness.}
    We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no
  $\ppt$ prover $\adv$ can convince an honest verifier $\verifier$ to accept a
  proof for a false statement $\inp \not\in\LANG$. More precisely, for
  all $\REL \in \RELGEN(\secparam)$
	\[
    \condprob{ \verifier^\ro (\srs, \inp, \zkproof) = 1 \land \inp \not\in
      \LANG_\REL}{\srs \gets \kgen(\REL), (\inp, \zkproof) \gets \adv^\ro(\srs)} \leq
    \negl.
	\]
%\end{description}
\fi


Let $\SRScer= (\kgen,\upd, \verifyCRS)$ be the algorithm of an updatable SRS ceremony.
All our definitions and theorems are about non-interactive proof systems $\ps = (\SRScer, \prover, \verifier, \simulator)$ compiled via the $(2\mu + 1)$-message FS transform. 
%
That is $\pi = (a_1, c_1, \ldots, a_{\mu}, c_{\mu}, a_{\mu + 1})$, with $c_i
= \ro(\zkproof[0..i])$, where $\zkproof[0..j] = (\inp, a_1, c_1, \ldots,
a_{j - 1}, c_{j - 1}, a_j)$.

%\subsection{Non-malleability definitions for NIZKs}
%\label{sec:simext_def}
%Real life applications often require a NIZK proof system to be
%non-malleable. That is, no adversary seeing a proof $\zkproof$ for a statement
%$\inp$ should be able to provide a new proof $\zkproof'$ related to $\zkproof$.
%\emph{Simulation extractability} formalizes a strong version of non-malleability
%by requiring that no adversary can produce a valid proof without knowing the
%corresponding witness. This must hold even if the adversary is allowed to see
%polynomially many simulated proofs for any statements it wishes.
%
%%\chaya{remove reference to forking soundness. quantify for $\ext_\se$}
%\begin{definition}[Forking simulation-extractable NIZK, \cite{INDOCRYPT:FKMV12}]
%	\label{def:simext}
%  Let $\ps_\fs = (\kgen_\fs, \prover_\fs, \verifier_\fs, \simulator_\fs)$ be a
%  HVZK proof system\hamid{$\ps_\fs$ is the Fiat-Shamir variant of the underlying proof system. So maybe we mean the underlying proof system is HVZK?}. We say that $\ps_\fs$ is \emph{forking
%    simulation-extractable} with \emph{extraction error} $\nu$ if for any $\ppt$
%  adversary $\adv$ that is given oracle access to a random oracle $\ro$ and
%  simulator $\simulator_\fs$, and produces an accepting transcript of $\ps$ with
%  probability $\accProb$, where
%	\[
%		\accProb = \Pr \left[
%		\begin{aligned}
%			& \verifier_\fs(\srs, \inp_{\advse}, \zkproof_{\advse}) = 1,\\
%			& (\inp_{\advse}, \zkproof_{\advse}) \not\in Q
%		\end{aligned}
%		\, \left| \,
%		\begin{aligned}
%			& \srs \gets \kgen_\fs(\REL), r \sample \RND{\advse}, \\
%			& (\inp_{\advse}, \zkproof_{\advse}) \gets \advse^{\simulator_\fs,
%			\ro} (\srs; r)
%		\end{aligned}
%		\right.\right]\,,
%	\]
%	there exists an extractor $\extse$ such that
%	\[
%		\extProb = \Pr \left[
%		\begin{aligned}
%			& \verifier_\fs(\srs, \inp_{\advse}, \zkproof_{\advse}) = 1,\\
%			& (\inp_{\advse}, \zkproof_{\advse}) \not\in Q,\\
%			& \REL(\inp_{\advse}, \wit_{\advse}) = 1
%		\end{aligned}
%		\, \left| \,
%		\begin{aligned}
%			& \srs \gets \kgen_\fs(\REL), r \sample \RND{\advse},\\
%			& (\inp_{\advse}, \zkproof_{\advse}) \gets \advse^{\simulator_\fs,
%			\ro} (\srs; r) \\
%			& \wit_{\advse} \gets \ext_\se (\srs, \advse, r, \inp_{\advse}, \zkproof_{\advse},
%			Q, Q_\ro) 
%		\end{aligned}
%		\right.\right]
%	\]
%	is at at least 
%	\[
%		\extProb \geq \frac{1}{\poly} (\accProb - \nu)^d - \eps(\secpar)\,,
%	\]
%	for some polynomial $\poly$, constant $d$ and negligible $\eps(\secpar)$ whenever
%  $\accProb \geq \nu$. List $Q$ contains all $(\inp, \zkproof)$ pairs where
%  $\inp$ is an instance provided to the simulator by the adversary and
%  $\zkproof$ is the simulator's answer. List $Q_\ro$ contains all $\advse$'s
%  queries to $\ro$ and $\ro$'s answers.
%\end{definition}






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
