\section{Introduction}
% \ourpar{On the popularity and power of Fiat--Shamir.}
The Fiat--Shamir (FS) transform takes a public-coin interactive protocol and
makes it interactive by hashing the current protocol transcript to compute the
verifier's public coins. While in principle justifiable in the random oracle
model (ROM)~\cite{CCS:BelRog93}, it is theoretically
unsound~\cite{FOCS:GolKal03} and so only a heuristic that should be used with
care.
%
Nevertheless, the FS transform is a popular design tool when it comes to
constructing \emph{zero knowledge succinct arguments of knowledge}
(zkSNARKs). In recent years, zkSNARKs have seen indisputable
progress~\cite{AC:Groth10a,TCC:Lipmaa12,EC:GGPR13,SP:PHGR13,AC:Lipmaa13,AC:DFGK14,EC:Groth16,SP:BBBPWM18}.
Their succinctness make them especially useful for deployment in real
systems~\cite{REPO:Zcash20,ARXIV:RonZaj19,REPO:Zeth20,REPO:Celo20,REPO:Aztec20}. However,
many works, including \sonic{}~\cite{CCS:MBKM19}
\plonk{}~\cite{EPRINT:GabWilCio19}, and \marlin~\cite{EC:CHMMVW20} are designed
and proven secure as multi-round interactive protocols. Security is then only
\emph{conjectured} for their non-interactive variants by employing the FS
transform.

Security conjectures via the Fiat--Shamir transform are not the only Achilles
heel of zkSNARKs. While the security of the FS transform is of interest
primarily to cryptographers, other concerns are more practical: The most
efficient zkSNARKs require a trusted third party generated SRS and provide no
security if the SRS, which needs to be generated afresh for every new relation,
is subverted. This issue has been tackled, e.g., by~\plonk{} and \sonic{} which
feature an updatable and universal SRS~\cite{C:GKMMM18}. Instead of using a
single SRS-generating entity, this framework allows a universal SRS to be
generated by a set of parties with the assurance that it remains secure if at
least one of these parties is honest.


A further problem with existing security models is proof malleability.
Arguably, in the real world the adversary has access to many proofs provided by
other parties with the same zero-knowledge scheme. In fact, in the most popular
applications of zkSNARKs, like privacy-preserving blockchains, proofs made by
all blockchain-participants are (usually) public. Thus, it is only reasonable to
require a zero-knowledge proof system to be resilient to attacks that adapt
proofs generated by different parties. Indeed, the malleability of ECDSA
signatures led to transaction malleability attack against Bitcoin payments and
such issues can also affect private crypto-currencies such as Zcash.
Nevertheless, most zkSNARKs are only shown to satisfy a (standard) knowledge
soundness definition.

Unfortunately, to the best of our knowledge, there are zkSNARKs that are proven
to be
simulation-extractable~\cite{C:GroMal17,EPRINT:BowGab18,EPRINT:AtaBag19,EC:Groth16}
and zkSNARKs with a universal and updateable
SRS~\cite{C:GKMMM18,CCS:MBKM19,EPRINT:GabWilCio19,EC:CHMMVW20}. However, no
zkSNARKs are known to enjoy both of these properties out-of-the-box (even for a
weaker notion of simulation extractability). Obviously, given a universal and
updateable zkSNARK one could lift it to be simulation-extractable using
techniques described, e.g.,~in \cite{EPRINT:KZMQCP15,CCS:AbdRamSla20}, but such
a lift comes with inevitable efficiency loss.  %The same applies for updatable
%zkSNARKs. No out-of-the-box simulation-extractable updatable zkSNARKs are
%currently known and there is no transformation that could take a SE zkSNARK and
%make it updatable (even though transformations like \cite{CCS:AbdRamSla20}
%preserves updatability).

Given the proliferation of zkSNARK systems and their frequently used to secure
crypto-currency assets of immense
value~\cite{REPO:Zcash20,ARXIV:RonZaj19,REPO:Zeth20,REPO:Celo20,REPO:Aztec20}
analyzing their security is of great importance. We investigate the advanced
security properties of a class of multi-round SRS-based zkSNARK protocols. As in
the case of sigma protocols we show that it is sufficient for protocol designers
to follow certain design principles and satisfy basic security properties. Using
the Fiat-Shamir transform, these properties are then lifting to practice
relevant security notions.

\subsection{Our contribution}
We show that a class of forking sound\footnote{Forking soundness is a variant of
  special soundness, where the transcripts provided to the extractor were
  obtained through interaction with an honest verifier. We define it later.}
interactive proofs of knowledge that are (honest-verifier) zero-knowledge in the
standard model and have a unique response property \emph{are
  simulation-extractable out-of-the box} in the random oracle model when the
Fiat--Shamir transformation is applied to them. In contrast to Faust et
al.~\cite{INDOCRYPT:FKMV12} who focused on special-sound $3$-message sigma
protocols, our result can be applied to a wider class of protocols and is
applicable to zkSNARKs.

We follow Faust et al.~in their definition of simulation extractability. They
called their simulation-extractability \emph{weak} which relates to the fact
that the extractor's \COMMENT{[has oracle access to the adversary, can rewind it
  and]} probability of returning a witness depends on the adversary's
probability $\accProb$ of producing an acceptable proof. More precisely, the
extractor is not guaranteed to succeed if the adversary outputs an acceptable
proof with probability $\accProb$ smaller than knowledge error $\nu$. On the
other hand, we show that this $\nu$ can be arbitrarily small, even
negligible. However, for $\accProb$ close to $\nu$ the extractor becomes fairly
inefficient. Since our extractor is based on a \emph{forking lemma}, we call
notion \emph{forking} simulation extractability\hamid{The sentence looks unclear to me.}. This is also to avoid confusion
with weakly simulation extractable protocols,
which %provide simulation extractability given that the
% adversary cannot output a proof for a statement it saw a simulated proof
% for. Importantly, weakly simulation extractable proof systems are (often)
can be re-randomizable. Since our notion prevents proof malleability, in this
work we often simply refer to it as simulation extractability.\hamid{Here it says we refer to it as "simulation extractability", but the last sentence says we call it "forking simulation extractability"; I think better to be consistent here!}

Our extractor is non-blackbox as it needs to
rewind the adversary (to run it with different random oracle responses). On
the other hand, the extractor is non-whitebox either as it only requires oracle
access to the adversary and does not depend on the adversary's code. Moreover,
it does not rely on knowledge assumptions. Our proof, however, requires the protocols to satisfy a
number of properties, which can be proven in the algebraic group model (AGM).

We note that when the extractor rewinds the adversary, it is expected that its
success probability depends on the adversary's probability of returning a
valid proof.  Unfortunately, the extraction technique we use is quite
inefficient as the security loss is exponential in the number of transcripts
required to extract the witness. Our analysis thus also serves as a
warning---conjecturing security based on the Fiat--Shamir transformation can
result in a huge security loss.


In addition to simulation extractability we also give a proof of simulation
soundness for the same generic class of protocols.  On the upside, we show that
despite the fairly inefficient extraction we can prove a much tighter result for
simulation soundness.


To show that our result are useful and practical we prove that two of the most
efficient updatable and universal zkSNARKs---$\plonk$ and $\sonic$---are
simulation sound and forking simulation-extractable.
%
To obtain these results, despite not changing anything at all in these
protocols, we define new intermediary properties satisfied by these multi-round
computationally sound protocols and their building blocks: forking soundness,
generalized unique response property, and a generalized forking lemma. These
conceptual insights into interactive SNARK systems help us overcome a number of
challenges, as we explain next.


\subsection{Our techniques}
We note that \plonk{} and \sonic{}---as originally presented
in \cite{EPRINT:GabWilCio19} and \cite{CCS:MBKM19}---are interactive proofs of
knowledge that are made non-interactive by the Fiat--Shamir transform. In the following,
we denote the underlying interactive protocols by $\plonkprot$ (for $\plonk$)
and $\sonicprot$ (for $\sonic$) and the resulting non-interactive proof systems by
$\plonkprotfs$ and $\sonicprotfs$, respectively.

\oursubsub{Forking soundness.} 
First, following \cite{INDOCRYPT:FKMV12}, we need to show for the protocols we consider that one can extract a witness from sufficiently many valid proof transcripts with a common prefix. However many protocols
do not meet the standard definition of special soundness for sigma protocols. First of all, the
definition requires extraction of a witness from any two transcripts, each
containing three messages and sharing the first message. For $\plonkprot$ and
$\sonicprot$ that is not enough. The definition needs to be adapted to cover
protocols with more than three messages. Furthermore, the number of transcripts
required is much greater. Concretely, $(3 \noofc + 6)$---where $\noofc$ is the
number of constraints in the proven circuit---for $\plonkprot$ and
$(\multconstr + \linconstr + 1)$---where $\multconstr$ and $\linconstr$ are the
numbers of multiplicative and linear constraints---for $\sonicprot$. Hence, we
do not have a \emph{pair of transcripts}, but a \emph{tree of transcripts}.

Second, both protocols rely on structured reference strings which come with
trapdoors. If in possession of the trapdoor, an adversary can produce multiple
valid proof transcripts without knowing the witness and potentially for false
statements. Recall that the standard special soundness definition requires
witness extraction from \emph{any} tree of acceptable transcripts\hamid{the paper sometimes says "accepting transcripts" and sometimes "acceptable transcripts". I think it would be nice to make this consistent.} that share a
common root. This means that there are no such trees for incorrect
statements. In this paper we define a different, forking lemma-related, version
of soundness which we call \emph{forking soundness}. That is, we show that it is
possible to extract a witness from all but negligibly many trees of acceptable
transcripts produced by probabilistic polynomial time (PPT) adversaries, given
that the trees are generated as interactions between a (possibly malicious)
prover and an honest verifier. We show how to use an adversary from which we cannot extract the witness but that produces such a tree to break the
underlying computational assumption.

\oursubsub{Unique response property.} 
Another property we require is the unique response property which
states, as expressed in \cite{C:Fischlin05} for $3$-messages sigma
protocols, that all but the first message sent by the prover are
deterministic (intuitively, the prover can only employ fresh randomness in the
first message of the protocol). Again, we can not use this definition right out
of the box. $\plonkprotfs$ does not satisfy it---both the first and the second
prover's messages are randomised. Although $\sonicprot$ prover is deterministic
after it picks its first message, the protocol has more than $3$ rounds, hence
it also does not fulfill the definition. We thus propose a generalisation of the
definition which states that a protocol is $\ur{i}$ if the prover is
deterministic starting from its $(i + 1)$-th message. For our proof it is
sufficient that this property is met by $\plonkprot$ for $i = 2$. Since
\sonic{}'s prover is deterministic from the second message on, it is $\ur{1}$.

To be able to show the unique response property (for both of the protocols) we
also had to show that the modified KZG polynomial commitment schemes
\cite{AC:KatZavGol10} proposed in \cite{EPRINT:GabWilCio19} and
\cite{CCS:MBKM19} have a \emph{unique opening property} which requires that for a commitment to a polynomial $p(X)$ it is infeasible for
any PPT adversary to provide two different acceptable openings witnesses at point $z$ even for the consistent evaluation $p(z)$.

\oursubsub{HVZK.}
In order to show our result we also show that (interactive) $\plonkprot$ and
$\sonicprot$ are honest verifier zero-knowledge in the standard model, i.e.~the
simulator is able to produce a transcript indistinguishable from a transcript
produced by an honest prover and verifier without any additional knowledge,
esp.~without knowing the SRS trapdoor. Although both $\sonic$ and $\plonk$ are
zero-knowledge, their simulators utilise trapdoors. For our reduction to work,
we need simulators able to provide indistinguishable proofs relying only on
reordering the messages and picking suitable verifier challenges. That is, any
PPT party should be able to produce a simulated proof by its own. (Note that
this property does not necessary break soundness of the protocol as the
simulator is required only to produce a transcript and is not involved in a real
conversation with a real verifier). This property allows us to build simulators
for $\plonkprotfs$ and $\sonicprotfs$ that rely only on the programmability of
the random oracle. Note that this programmability is also only needed from some round $i$ onward.

\oursubsub{Generalising Boneh-Boyen-Goh~\cite{EC:BonBoyGoh05} uber assumption.}
To show that $\plonk$ is zero-knowledge we rely on a variant of
BBG's \emph{uber assumption}. In its original version, the
assumption assures that some polynomial evaluation (on a random, unknown point)
represented in a bilinear pairing target group $\GRP_T$ is indistinguishable
from a random element. In our variant, we modify two things.
\begin{inparaenum}[(1)]
\item Firstly, the polynomial evaluation can be represented in other groups
  than $\GRP_T$; here we use $\GRP_1$;
\item Secondly, the distinguisher is given not only a single polynomial evaluation,
  but a number of polynomials  evaluations. That is, it either gets the result of $k$ polynomial
  evaluations or $k$ random numbers.
\end{inparaenum}
We show security of the generalized uber assumption directly in the generic
group model.

\oursubsub{Generalisation of the general forking lemma.} 
Consider an interactive $3$-message special-sound protocol $\ps$ and its
non-interactive version $\ps_\fs$ obtained by the Fiat--Shamir transform. The
general forking lemma provides an instrumental lower bound for the probability
of extracting a witness from an adversary who provides two proofs for the same
statement that share the first message. Since $\plonkprot$ and $\sonicprot$ have
more than $3$ messages and are not special-sound, the forking lemma of Bellare
and Neven~\cite{CCS:BelNev06}, cannot be used directly. We thus propose a
modification that covers multi-message protocols where witness extraction
requires more transcripts than merely two.  Unfortunately, we also observe that
the security gap grows with the number of transcripts and the probability that
the extractor succeeds diminishes significantly. (That said, we have to note
that the security loss is polynomial, albeit big.)

We note that some modern zkSNARKs, like \cite{SP:BBBPWM18,CCS:MBKM19}, heavily
rely on the Fiat--Shamir transform and thus potentially the forking lemma. First, an interactive
protocol is proposed and its security and forking soundness analysed. Second,
one uses an argument that the Fiat--Shamir transform can be used to get a
protocol that is non-interactive and shares the same security properties.

We see our generalized forking lemma as contributing to a critical assessment of
this approach. The analysis of the interactive protocol is not enough and one
has to consider the security loss implied by the Fiat-Shamir transform for the target security notion. Thus one has to either rely on our generalisation of the forking
lemma or disclose a transformation that does not suffer this loss. We note that
the security loss may also apply when knowledge soundness is proven. That is the
case for the original $\sonic$ paper, whose security proof relies on so-called witness-extended
emulation. The authors of $\plonk$ and recent work on $\sonic$~\cite{cryptoeprint:2020:1351} worked around this problem by proving
knowledge soundness directly in the algebraic group model.

\oursubsub{Simulation soundness and forking simulation-extractability.} Given our modified, less
restrictive, definition for forking soundness and the unique response property,
and our generalised forking lemma we obtain our main
results---proofs for the simulation soundness and forking simulation extractability of $\plonkprotfs$ and $\sonicprotfs$. The
proofs are inspired by simulation-extractability and simulation-soundness proofs
from \cite{INDOCRYPT:FKMV12}, with major modifications, which were required as
\cite{INDOCRYPT:FKMV12} considers only sigma protocols
that are undoubtedly much simpler protocols than the considered proof systems.



% Since the proof highly relies on the (generalised) forking lemma, the security
% lost it introduces is considerable.

% \oursubsub{Efficient simulation-soundness.}
% Given that the security reduction for simulation-extractability introduces a
% security gap we also present a proof for $\plonkprot_\fs$ simulation soundness
% which utilises the algebraic group model and is tight. It remains an open
% question how to show simulation extractability tightly, e.g.~using AGM.

% \subsection{Comparison with Bootle et al.~\cite{EC:BCCGP16}}
% \newcommand{\treefinder}{\pcadvstyle{T}}
% \newcommand{\provers}{\prover^*}
% Bootle et al.~\cite{EC:BCCGP16} provides a ``forking lemma'' showing that a
% protocol which has an extractor $\ext$ able to extract a witness from a tree of
% acceptable transcripts follows also notion of witness-extended emulation.
% An interestin question is whether their version of the forking lemma could be
% used to show security of protocols which were made non-interactive by the
% Fiat--Shamir transformation. We provide a simple adversary which shows that the
% answer is---not directly. \hl{In the following part of the paper we show that
%   allowing for some efficiency loss the result of Bootle et al.~\emph{can} be
%   used for non-interactive protocols.}


% \begin{lemma}
%   Let $\proofsystem$ be an $(2\mu + 1)$ public-coin interactive proofsystem and
%   $\proofsystem_\fs$ be Fiat--Shamir transformed $\proofsystem$, $\ext$ be a
%   witness extraction algorithm which always succeeds to extract a witness from a
%   $(n_1, \ldots, n_\mu)$-tree of accepting transcripts and $\provers$ be a
%   (possibly malicious) prover for $\proofsystem_\fs$.
%   Then the tree finding algorithm $\treefinder$ presented at \cite[Lemma
%   1]{EC:BCCGP16} builds a tree of accepting transcript with probability $0$.
% \end{lemma}
% \begin{proof}
% Let $\provers$ be an prover who proceeds as follows. On input $(\inp, \wit)
% \in \REL$ it computes the first $i$ rounds of the protocol honestly, then it breaks
% and start the protocol over. With the second run, it finishes and outputs an
% honest proof for $\inp$ using $\wit$.

% Next, we analyse the probability that the tree-finder $\treefinder$ outputs a
% tree of accepting transcripts by rewinding $\provers$ and providing it with
% fresh challenges.

%   \qed
% \end{proof}


\subsection{Structure of the paper}
In the next section we present necessary
preliminaries. \cref{sec:se_definitions} gives definitions and lemmas for multi-round SRS-based protocol needed to
instantiate our framework. In \cref{sec:general}, we present our main result,
a proof of simulation-soundness and simulation-extraction \hamid{forking simulation-extraction?}for multi-round SRS-based zero-knowledge proofs systems. In \cref{sec:plonk} and \cref{sec:sonic} we show that $\plonk$ and
$\sonic$ fulfill the requirements of our framework and are in fact simulation sound and forking
simulation extractable.

\subsection{Related Work}
There are many results on simulation extractability for non-interactive
zero-knowledge proofs (NIZKs). First, Groth \cite{AC:Groth07} noticed that a
(black-box) simulation extractable NIZK is universally-composable (UC)
\cite{EPRINT:Canetti00}. Then Dodis et al.~\cite{AC:DHLW10} introduced a notion
of (black-box) \emph{true simulation extractability} and showed that no NIZK can
be UC-secure if it does not satisfy this property. In the context of zkSNARKs it is
important to mention such works as the first simulation-extractable zkSNARK by
Groth and Maller \cite{C:GroMal17} and SE zkSNARK for QAP by Lipmaa
\cite{EPRINT:Lipmaa19b}. Kosba's et al.~\cite{EPRINT:KZMQCP15} give a general
transformation from a NIZK to a black-box SE NIZK. Although their transformation
works for zkSNARKs as well, succinctness of the proof system is not preserved as
the statement's witness is encrypted. Recently, Abdolmaleki et
al.~\cite{CCS:AbdRamSla20} showed another transformation that obtains
non-black-box simulation extractability but also preserves succinctness of the
argument.

Independently, some authors focused on obtaining simulation extractability of
known zkSNARKs, like $\groth$ \cite{EC:Groth16}, by introducing minor
modifications and using stronger assumptions
\cite{EPRINT:BowGab18,EPRINT:AtaBag19}. Interestingly, although such
modifications hurt performance of the proof system, the resulting zkSNARKs are
still more efficient than the first SE zkSNARK \cite{C:GroMal17}, see
\cite{EPRINT:AtaBag19}. Recently, \cite{EPRINT:BKSV20} showed that the original
Groth's proof system from \cite{EC:Groth16} is weakly SE and randomisable.

\ourpar{Forking lemma generalizations.}
There are several task specific variants, e.g.,~\cite{INDOCRYPT:HerSae03,CCS:BagCheJar08,AC:BelDaiLi19}, of the general forking lemma~\cite{JC:PoiSte00,CCS:BelNev06} for analyzing the forking behavior of random-oracle based executions.
In \cite{EC:BCCGP16} Bootle et al.~proposed a novel inner-product argument which
security relies on, so-called, witness-extended emulation. To show that
property, the authors proposed a new version of forking lemma, which gives a
lower bound on probability that a tree finding algorithm is able to produce a 
tree of acceptable transcripts by rewinding a conversation between a
(potentially malicious) prover and verifier.

Although the result in that paper is dubbed a ``forking lemma'' it
differs from forking lemmas known from e.g.~\cite{JC:PoiSte00,CCS:BelNev06}.
First of all, the forking lemmas in these papers analyse the probability of building
a tree of acceptable transcripts for Fiat--Shamir based non-interactive proof
systems, while the protocol presented by Bootle et al.~is intended to work for
interactive proof systems.

Importantly, it is not obvious how the result of Bootle et al.~can be used to
show security of non-interactive protocols as it relies on interactive provers
whose proving strategies are more limited than proving strategies of
non-interactive provers. For example, if a challenge given by the verifier does not
suit an interactive prover, it can only try to finish a proof with it or
abort. On the other hand, a non-interactive prover has far wider scope of
possible actions---when the protocol is non-interactive the prover may
adapt its strategy based on the random oracle outputs. \iffalse For example,
seeing a response $h$ after sending $k$-th message it may decide to ``go back''
a number of steps, e.g.~prior sending $k'$-th message ($k' \leq k$), provide
different messages hoping for better suited response $h'$ on its $k$-th
message. Furthermore, the adversary may even interrupt the proof and try again
with another instance. All of these actions would make the proof unacceptable
for an interactive verifier, however they may give a perfectly fine proof for a non-interactive one.\fi

State restoration attack security~\cite{TCC:BenChiSpo16,EPRINT:Holmgren19}
defines a stronger soundness notion for interactive protocols, that allows for a
tighter reduction from interactive to non-interactive
protocols. \cite{cryptoeprint:2020:1351} combine this approach with the
algebraic group model to obtain tight security guarantees for the
non-interactive versions of Bulletproof~\cite{SP:BBBPWM18} and \sonic. A similar
approach is also taken by~\cite{cryptoeprint:2019:1177}. These works however are
focused on showing security of concrete proof systems, while we show
security of an arguably wide class of protocols. They also do not consider
simulation soundness and simulation extractability. Last, but not least, our
high-level security proof relies only on random oracle, while
\cite{cryptoeprint:2020:1351,cryptoeprint:2019:1177} make use of random oracle
\emph{and} the AGM. The AGM is only used to prove low-level properties about specific protocols.