%!TEX root=main.tex

\begin{theorem}[Simulation-extractable multi-message protocols]
	\label{thm:se}
	Let $\ps = (\kgen, \prover, \verifier, \simulator)$ be an interactive
	$(2 \mu + 1)$-message HVZK proof system for $\RELGEN(\secparam)$. Let
	$\ro \colon \bin^{*} \to \bin^{\secpar}$ be a random oracle. If $\psfs$ has the
	$k$-\emph{updatable unique response property} with security loss $\epsur(\secpar)$, is
	\emph{updatable $k'$-programmable trapdoor-less simulatable}, and $(1, \ldots, 1, n_{k''}, \ldots, n_\mu)$-\emph{updatable computational special sound} with security loss $(\epst (\secpar, \accProb) +  \epss(\secpar))$, where $k \leq k' \leq k''$. Then $\psfs$ is
	\emph{updatable simulation-extractable} against any $\ppt$ adversary who return an acceptable proof with probability at least $\accProb$.  The
	extraction probability $\extProb$ is at least
	$\extProb \geq 1 - \epst(\secpar, \accProb)
	- \epsur(\secpar) - \epss(\secpar)\,$.
\end{theorem}

\begin{proof}		
	\ngame{0} This is the simulation-extractability game played between an adversary
	$\advse$ who is given access to an oracle $\initU$ that defines an updatable SRS
	setup, and a simulation oracle $\simulator = (\simulator_1, \simulator_2')$ which provides the adversary with simulated
	proofs and random oracle functionality. We denote by $\rsim$
	randomness of $\simulator$ which is randomly sampled. Execution of $\advse$ results in
	lists of
	\begin{inparaenum}[(1)]
		\item simulated proofs $Q$,
		\item random oracle queries $Q_\ro$,
		\item SRS updates $Q_\srs$.
	\end{inparaenum}
	%
	Extractor $\extse$ takes as input a proof $\zkproof_{\advse}$ for instance
	$\inp_{\advse}$ output by the adversary and lists $Q, Q_\ro, Q_\srs$ and is tasked
	to extract a witness $\wit_{\advse}$ such that $\REL(\inp_{\advse}, \wit_{\advse})$
	holds. $\advse$ wins if it manages to produce an acceptable proof and the extractor
	fails to output a witness. In the following game hops we upper-bound the
	probability that this happens. Note that $\srs$ is with respect to the finalised
	SRS with respect to which $\adv$ is allowed to make simulation queries.
	
	\ngame{1} This is identical to $\game{0}$ except that now the game is aborted if
	there is $(\inp_\advse, \zkproof_{\simulator}) \in Q$ such that
	$\zkproof_\simulator[1..k] = \zkproof_{\advse}[1..k]$. That is, the adversary in
	its final proof reuses at least $k$ messages from a simulated proof, and the proof
	is accepting.  Denote this event by $\event{\errur}$.
	
	\ncase{Game 0 to Game 1} We have,
	\( \prob{\game{0} \land \nevent{\errur}} = \prob{\game{1} \land \nevent{\errur}} \)
	and, from the difference lemma, cf.~\cref{lem:difference_lemma},
	$ \abs{\prob{\game{0}} - \prob{\game{1}}} \leq \prob{\event{\errur}}\,$.  Thus, to
	show that the transition from one game to another introduces only minor change in
	probability of $\adv$ winning it should be shown that $\prob{\event{\errur}}$ is
	small.
	
	We assume that $\adv$ queried the simulator on the instance it wishes to
	output, i.e.~$\inp_{\adv}$. We show a reduction $\rdvur$ that has access to the random oracle $\ro$ and update oracle $\initU$, and utilises $\adv$ to break the $\ur{k}$ property of $\ps$. That is, for randomness $r = (r_\adv, \rsim)$, $\rdvur (r)$ runs $\advse^{\initU, \simulator_1, \simulator_2'}(\secparam; r_\adv)$ internally as a black-box.
%	\begin{compactitem}
	%
	%\item 
	First, the reduction answers $\adv$'s update queries by passing the queries to its own update oracle. Everntually, the reduction finalises the same SRS $\srs$ as the one $\adv$ does.
	
	%\item 
	The reduction answers both queries to the simulator $\simulator$ and to the random oracle using $\rsim$. It also keeps lists $Q$, for the simulated proofs, $Q_\ro$ for the random oracle queries, and $Q_{srs}$ for the SRS updates. To provide $\adv$ with the simulated proofs the reduction uses challenges from its random oracle $\ro$ and compute the simulated proof as an honest prover would up to challenge $k'$. For challenges after $k'$ the reduction programs when it is necessary to provide a simulated proof.
	%	\item 

	When $\adv$ makes a fake proof $\zkproof_{\adv}$ for $\inp_{\adv}$, $\rdvur$
		looks through lists $Q$ and $Q_\ro$ until it finds $\zkproof_{\simulator}[0..k]$
		such that $\zkproof_{\adv}[0..k] = \zkproof_{\simulator}[0..k]$ and a random
		oracle query $\zkproof_{\simulator}[k].\ch$ on $\zkproof_{\simulator}[0..k]$.
	%	\item 
	$\rdvur$ returns two proofs for $\inp_{\adv}$:
		\begin{align*}
		\zkproof_1 = (\zkproof_{\simulator}[1..k],
		\zkproof_{\simulator}[k].\ch, \zkproof_{\simulator}[k + 1..\mu + 1])\\
		\zkproof_2 = (\zkproof_{\simulator}[1..k],
		\zkproof_{\simulator}[k].\ch, \zkproof_{\adv}[k + 1..\mu + 1])
		\end{align*}
	%\end{compactitem}

	Importantly, both proofs are acceptable w.r.t~the unique response property verifier $\tilde{\verifier}$. The first, since the unique response property definition allows any challenges after $k$. The latter, since it is an acceptable proof produced by the adversary.
	If $\zkproof_1 = \zkproof_2$, then $\adv$ fails to break simulation soundness, as
	$\zkproof_2 \in Q$. On the other hand, if the proofs are not equal, then $\rdvur$
	breaks $\ur{k}$-ness of $\ps$. This happens only with negligible probability
	$\epsur(\secpar)$, hence \( \prob{\event{\errur}} \leq \epsur(\secpar)\,. \). We denote by $\waccProb$ the probability that $\adv$ outputs an acceptable proof and does not break the unique response property. By the union bound $\waccProb \leq \accProb - \epsur (\secpar)$.

	\iffalse
	\ngame{2} In this game the environment additionally aborts if $\extse$ fails to build a
	$(1, \ldots, 1, n_{k''}, \ldots, n_\mu)$-tree of accepting transcripts $\tree$ by rewinding
	$\adv$.
	
	\ncase{Game 1 to Game 2} Note that for every accepting proof $\zkproof_{\advse}$, we 	may assume that whenever $\advse$ outputs a $k''$-th move message $\zkproof_{\advse}[k'']$, then the $(\inp_{\advse}, \zkproof_{\advse}[1..k'])$ 	random oracle query was made by the adversary, not the simulator\footnote{\cite{INDOCRYPT:FKMV12} calls these queries \emph{fresh}.}, i.e.~there is no simulated proof $\zkproof_\simulator$ on $\inp_\simulator$ such that $(\inp_{\advse}, \zkproof_{\advse} [1..k'']) = (\inp_\simulator, \zkproof_\simulator[1..k''])$. This follows directly from the assumption that $k \leq k'$. If that was the case, the game would be already interrupted by the error event in Game $\game{1}$. As previously, we have $\abs{\prob{\game{1}} - \prob{\game{2}}} \leq \prob{\event{\errfrk}}$, where $\event{\errfrk}$ denotes the event of $\extse$ failing to build a $(1, \ldots, 1, n_{k''}, \ldots, n_\mu)$-tree of accepting transcripts. Let $\waccProb$ be the probability of $\advse$ producing an accepting transcript that does not break $\ur{k}$-ness of $\ps$. By special soundness of $\proofsystem_\fs$, \hamid{19.4}{discuss if $\epst(\secpar, \waccProb)$ here makes sense!}\michals{21.04}{Seems it does, why?}, we have 
		\begin{equation}
		\abs{\prob{\game{1}} - \prob{\game{2}}} \leq \prob{\event{\errfrk}} \leq 1 - 
		\epst(\secpar, \waccProb).
%		\frac{\waccProb - (q + 1) \epsk(\secpar)} {1 -
%			\epsk(\secpar)}.
		\end{equation}		
	\fi
	
	\ngame{\changedm{2}} This game is identical to $\game{\changedm{1}}$ except that the extractor $\extse$, runs internally a tree building algorithm $\tdv$ and extractor $\extt$. Eventually $\extse$ outputs a witness $\wit$. The environment additionally aborts this game if $\REL(\inp, \wit)$ does not hold.
	
	\ncase{Game 1 to Game 2}
	Note that for every accepting proof $\zkproof_{\advse}$, we 	may assume that whenever $\advse$ outputs a $k''$-th move message $\zkproof_{\advse}[k'']$, then the $(\inp_{\advse}, \zkproof_{\advse}[1..k'])$ 	random oracle query was made by the adversary, not the simulator\footnote{\cite{INDOCRYPT:FKMV12} calls these queries \emph{fresh}.}, i.e.~there is no simulated proof $\zkproof_\simulator$ on $\inp_\simulator$ such that $(\inp_{\advse}, \zkproof_{\advse} [1..k'']) = (\inp_\simulator, \zkproof_\simulator[1..k''])$. This follows directly from the assumption that $k \leq k'$. If that was the case, the game would be already interrupted by the error event in Game $\game{1}$.

 	To upper-bound $\abs{\prob{\game{1}} - \prob{\game{2}}}$, we build an adversary $\bdv$ against computational special soundness such that, given access to oracles $\initU$ and $\ro$, and randomness $r = (r_\adv, \rsim)$, internally runs $\advse^{\initU, \simulator_1, \simulator_2'} (1^\secpar; r_\adv)$ as follows%:
	%\begin{compactenum}
		\item
		%
		First, $\bdv$ answers $\adv$ random oracle and update queries by passing the queries to the real
		oracles $\ro$ and $\initU$. When $\adv$ finalises an SRS $\srs$, $\bdv$ does the same.

		\begin{pcvstack}[center,boxed]
			\begin{pchstack}
				\procedure{$\simulator_1.\ro(x)$}
				{
				\pcif H[x] = \bot \pcthen \\
				\quad H[x] \gets \ro(x) \\
				\pcreturn H[x]
		  		}
				
				\pchspace
				
				\procedure{$\simulator_1.\mathsf{Prog(x,h)}$}
				{ 
					\pcif H[x] = \bot \pcthen \\ 
					\quad H[x] \gets h \\
					\quad \mathsf{Prog} \gets \mathsf{Prog} \cup \{x\}
				}
			\end{pchstack}
		\end{pcvstack}
		
		$\bdv$ answers simulator queries by using coins $\rsim$. More precisely, to build a simulated proof $\bdv$ queries $\ro$ for challenges up to $k'$-th challenge. After $k'$ challenge, it picks challenges on its own. $\bdv$ maintains a
		list of instance-proof pairs $Q$ consisting of all simulation queries made by
		$\adv$, and corresponding responses.
		
		%\item 
		Eventually when $\adv$ outputs $(\inp_\advse, \zkproof_\advse)$, $\bdv$ runs the tree building algorithm $\tdv$ and outputs the resulting $(1, \ldots, 1, n_{k''}, \ldots, n_\mu)$-tree of accepting transcripts. We note that all the transcripts are acceptable w.r.t~a verifier $\verifier$ with access to a random oracle $\ro$. This is since, challenges from a programmed by $\bdv$ random oracle only occur only after $k'$-th challenge. Since $k \leq k'$ non of the adversary $\adv$'s proof in $\tree$ utilize elements of simulated proofs after challenge $k$. Otherwise, the uniqe response property would be broken, what was excluded in Game 1.
	%\end{compactenum}	
	
	If $\extse$ outputs a valid witness, then $\adv$ fails to break simulation extractability. Otherwise, in the case that $\extse$ fails, $\bdv$ breaks special soundness of $\ps$. By assumption, this happens only with probability $\epss(\secpar) + \epst(\accProb, \secpar)$, hence $\abs{\prob{\game{2}} - \prob{\game{3}}} \leq \epss(\secpar) + \epst(\accProb, \secpar)$.
	
	\ncase{Conclusion} Since Game $\game{3}$ is aborted when it is impossible to
	extract a witness from $\tree$,
	the adversary $\advse$ cannot win. Thus, by the game-hopping argument,
	\[
	\abs{\prob{\game{0}} - \prob{\game{3}}} \leq \epst(\secpar, \waccProb)
		 + \epsur(\secpar) + \epss(\secpar)\,.
	\]
	Thus the probability that extractor $\extse$ succeeds is at least
	\[
	%	\frac{\waccProb - (q + 1) \epsk(\secpar)}{1 - \epsk(\secpar)} -
	1 - \epst(\secpar, \waccProb) - 
	\epsur(\secpar)
	%- q_{\ro}^{\mu} \epss
	- \epss(\secpar)\,.
	\]
	
	\end{proof}
	
	\begin{corollary}
		Let $\tdv$ be a tree building algorithm that builds a tree according to \cref{fig:Attema-ext}. Then the extractor $\extse$ outputs a valid witness with probability \hamid{19.4}{The next equation should be changed. Todo: how should we compute $\epst(\secpar, \accProb)$ based on $\epst(\secpar, \waccProb)$?}\michals{21.04}{$\waccProb \geq \accProb - \epsur$}
		\begin{equation}
			\label{eq:frk}
			\extProb \geq \frac{\accProb - \epsur(\secpar) - (q + 1) \epsk(\secpar)}{1 - \epsk(\secpar)} 
			- \epsur(\secpar) - \epss(\secpar)\,.
			\end{equation} 
	\qed
\end{corollary}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

