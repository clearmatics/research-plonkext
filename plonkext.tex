% !TeX spellcheck = en_GB
\let\accentvec\vec
\documentclass[runningheads]{llncs}
 % \documentclass[runningheads]{amsart}
\let\spvec\vec
\let\vec\accentvec
\usepackage{amssymb,amsmath}
\let\vec\spvec

\usepackage[T1]{fontenc}

\newcommand{\iflipics}[1] {}
\newcommand{\iflncs}[1] {#1}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
	{\mbox{\boldmath$\textstyle#1$}}
	{\mbox{\boldmath$\scriptstyle#1$}}
	{\mbox{\boldmath$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

% lncs size (as printed in books, with small margins):
\usepackage[paperheight=23.5cm,paperwidth=15.5cm,text={13.2cm,20.3cm},centering]{geometry}


\newcommand{\ifamsart}[1] {}
\ifamsart{
	\newtheorem{theorem}{Theorem}%[section]
	\newtheorem{proposition}[theorem]{Proposition}
	\newtheorem{lemma}[theorem]{Lemma}
	\newtheorem{corollary}[theorem]{Corollary}
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definition}
	\newtheorem{example}[theorem]{Example}
}
\usepackage{soul}
\usepackage{soulutf8}
\soulregister\cite7
\soulregister\ref7
\soulregister\pageref7
\usepackage{hyperref}
\usepackage[color=yellow]{todonotes}
\hypersetup{final}
\usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}
\usepackage[capitalise]{cleveref}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed} 

\include{macros}

\title{On Simulation-Extractability of \textsc{Plonk}}
% \titlerunning{Achieving additional security in LegoSNARK}

\author{Michał Zając}
\iflncs{
  \institute{Clearmatics, London, UK\\ \email{m.p.zajac@gmail.com}}
}

\allowdisplaybreaks

\begin{document}
	\sloppy
	\maketitle

\begin{abstract}
	In this paper we prove that some most-efficient updatable universal zkSNARKs like \plonk{}~\cite{EPRINT:GabWilCio19} \comment{and Sonic~\cite{CCS:MBKM19} are} is (non black-box) simulation extractable. 
	To that end, we generalise the result by Faust et al.~\cite{INDOCRYPT:FKMV12} (INDOCRYPT 2012) and show that any witness-extended emulatable is also simulation-extractable if made non-interactive by the Fiat--Shamir transform. We then explain why \plonk{} is has witness-extended emulation and conclude by showing its simulation-extractability.
	\michals{14.05}{Since Sonic is witness-extended emulation then it should be simulation extractable as well. But does it have the unique response property?}
	\task{15.05}{Check Marlin}
\end{abstract}

\section{Introduction}
\paragraph{The rise of updatable zkSNARKs.}
\cite{C:GKMMM18}
\cite{EC:CHMMVW20}
\cite{CCS:MBKM19}
\cite{EPRINT:GabWilCio19}
\cite{EPRINT:Gabizon19c}
\cite{EPRINT:Lipmaa19a}

\paragraph{On the importance of the simulation extractability.}
\cite{AC:DHLW10}
\cite{AC:Groth07}
\cite{EPRINT:AbdRamSla20}
\cite{EPRINT:KZMQCP15}
\cite{EPRINT:BagAta19}
\cite{EPRINT:Baghery20}



\subsection{Our contribution}
First of all, we prove that $\plonk$ is simulation-extractable. Although we do not change the original protocol at all, we had to solve a number of problems in order to show that. The idea of the proof goes as follows. 

\paragraph{Witness-extended emulation of \plonk{}.} 
First, we show that $\plonk$ has witness-extended emulation. To that end we show how from a number of accepting transcript a witness can be extracted. Unfortunately, \plonk{} does not to fit well in the standard definitions of witness-extended emulations like by Lindell \cite{JC:Lindell03} or by Groth and Ishai \cite{EC:GroIsh08}. The former does not cover arguments that utilises a CRS, the latter does, but does not consider giving the CRS trapdoor to the extractor. Thus, we had to modify the definition for the witness-extended emulation. 
By this modification we bring the notion of the witness extended-emulation closer to the definition of simulation extractability, where giving the trapdoor to the extractor is a natural thing to do, cf.~\cite{AC:Groth06,AC:DHLW10,PKC:ADKNO13,DCC:DerSla19}.
We believe that our formulation would serve well in showing simulation-extractability of NIZKs. 

\paragraph{From witness-extended emulation to simulation extractability.}
Second, we took the classical result by Faust et al.~\cite{INDOCRYPT:FKMV12} which shows that a special-sound $\Sigma$-protocol that has the unique response property is simulation-extractable if made non-interactive by the Fiat--Shamir transform. This result also could not be used directly, as \plonk{} is not a $3$-round $\Sigma$-protocol. 
To make Faust et al.~result working in our setting we had to prove it fits multi-round protocols and show that \plonk{} in fact has the unique response property.

\paragraph{Interactive zero knowledge vs non-interactive zero knowledge.}
Another issue we tackle with is a question whether NIZK proof systems are in fact zero-knowledge, see e.g.~\cite{C:Pass03}. This problem was raised as one could observe that a NIZK proof system has a property alien to interactive proofs --- a verifier who obtains a proof $\zkproof$ for a statement $\inp \in \LANG$ inevitably learns how to prove this statement. More precisely, he can just reuse the obtained proof $\zkproof$. This makes the verifier learn undoubtedly more than simply the veracity of the proven statement. On the other hand, the verifier learns a particular proof $\zkproof$ for a concrete CRS $\crs$ only. However, the CRS generator is considered trusted, thus the proof $\zkproof$ could be considered as a proof for $\inp$ universally, regardless the CRS. 

Simulation-extractable updatable NIZKs (and zkSNARKs in particular) tighten the gap between interactive zero knowledge and non-interactive zero knowledge in the CRS model. 
First, simulation-extractability assures that no adversary can maul an existing proof and make a fresh one, what limits replay attacks.
Second, updatable NIZKs does not assume that there is a trusted party that provides a CRS, but rather a sequence of parties (called updaters) that modify it. The security model is radically different as now one believes in the veracity of a proof only if she trusts that there is at least one honest party between the updaters. Hence, the proof is no longer universal.

We believe that our result may be useful for designing new zkSNARKs, especially those based on a polynomial commitment schemes~\cite{AC:KatZavGol10}, as it shows that a careful protocol design may give it a strong security notion for free.

\section{Preliminaries}
Let PPT denote probabilistic polynomial-time.
Let $\secpar \in \NN$ be the security parameter.
All adversaries will be stateful.
For an algorithm $\adv$, let $\image (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), let $\RND{\adv}$ denote the random tape of $\adv$ (assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote the random choice of the randomiser $r$ from $\RND{\adv}$.
We denote by $\negl$ an arbitrary negligible function.

Distributions $X$ and $Y$ have \emph{statistical distance} $\SD$ equals $\epsilon$ if $\sum_{a \in \supp{X \cup Y}} \abs{\prob{X = a} - \prob{Y = a}} = \epsilon$.
We write $X \approx_\secpar Y$ if $\SD(X, Y) \leq \negl$, where $\SD$ is the statistical distance between the distributions.
For values $a$ and $b$ we write $a \approx_\secpar b$ if $\abs{a - b} \leq \negl$. 

Denote by $\RELGEN$ a \emph{relation generator} -- a PPT algorithm that on input $\secparam$ outputs an $\npol$ relation $\REL$. We assume that if $\RELGEN$ provides any auxiliary input to $\REL$, it is benign. Directly from the description of $\REL$ one learns security parameter $\secpar$ and other necessary information like a description of a group $\GRP$, if the relation is a relation of group elements (as it usually is in case of zkSNARKs).

\paragraph{Bilinear groups.}
A bilinear group generator $\pgen (1^\secpar)$ returns $(p, \GRP_1, \GRP_2, \GRP_T, \pair, \gone{1}, \gtwo{1})$, where $\GRP_1$, $\GRP_2$, and $\GRP_T$ are additive cyclic groups of prime order $p = 2^{\Omega (\secpar)}$, $\gone{1}, \gtwo{1}$ are generators of $\GRP_1$, $\GRP_2$, resp., and $\pair: \GRP_1 \times \GRP_2 \to \GRP_T$ is a non-degenerate PPT-computable bilinear pairing.
We assume the bilinear pairing to be Type-3, i.e., that there is no efficient isomorphism from $\GRP_1$ to $\GRP_2$ or from $\GRP_2$ to $\GRP_1$.
We use the by now standard bracket notation, i.e., we write $\bmap{a}{\gi}$ to denote $a g_{\gi}$ where $g_{\gi}$ is a fixed generator of $\GRP_{\gi}$.
We denote $\pair (\gone{a}, \gtwo{b})$ as $\gone{a} \bullet \gtwo{b}$.
Thus, $\gone{a} \gtwo{b} = \gtar{a b}$.
We freely use the bracket notation with matrices, e.g., if $\vec{A} \vec{B} = \vec{C}$ then $\vec{A} \grpgi{\vec{B}} = \grpgi{\vec{C}}$ and $\gone{\vec{A}}\bullet \gtwo{\vec{B}} = \gtar{\vec{C}}$.

\subsection{Zero knowledge}
In a zero-knowledge proof or argument system, a prover convinces the verifier of the veracity of a statement without leaking any side information except that the statement is true.
Here, a proof (resp., an argument) system guarantees soundness against an unbounded (resp., a PPT) cheating prover.
The zero-knowledge property is proven by constructing a simulator that can simulate the view of a cheating verifier without knowing the secret information (witness) of the prover.

More precisely, let $\RELGEN(\secparam)$ be a relation generator that outputs an $\npol$ relation $\REL = \smallset{(\inp, \wit)}$. Denote by $\LANG_\REL$ the language determined by $\REL$. 
Let $\prover$ and $\verifier$ be algorithms, the former called \emph{prover} and the latter \emph{verifier}. 
We denote by $\ip{\prover(\REL, \inp, \wit)}{\verifier(\REL, \inp)}$ a transcript of conversation between a $\prover$ with input $(\REL, \inp, \wit)$ and $\verifier$ with input $(\REL, \inp)$. 
We write $\ip{\prover (\REL, \inp, \wit)}{\verifier(\REL, \inp)} = 1$ if in the end of the transcript the verifier $\verifier$ returns $1$ and say that $\verifier$ accepts the transcript.

A proof system $\proofsystem = (\prover, \verifier, \simulator)$ for $\RELGEN$ is required to have three properties: completeness, soundness and zero knowledge, which are defined as follows:
\begin{description}
	\item[Completeness] An interactive proof system $\proofsystem$ is \emph{complete} if an hnest prover always convinces an honest verifier, that is for all $\REL \gets \RELGEN(\secparam)$ and $(\inp, \wit) \in \REL$
	\[
		\prob{\ip{\prover (\REL, \inp, \wit)}{\verifier (\REL, \inp)} = 1} = 1\,.
	\]
	\item[Soundness] We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no PPT prover $\adv$ can convince an honest verifier $\verifier$ to accept a proof for a false statement, i.e~for $\inp \not\in\LANG$. More precisely, for all $\REL \gets \RELGEN(\secparam)$
	\[
		\condprob{\ip{\adv(\REL, \inp)}{\verifier(\REL, \inp)} = 1}{\inp \gets \adv(\REL); \inp \not\in \LANG_\REL} \leq \negl\,;
	\]
	\item[Zero knowledge] We call an interactive proof system $\proofsystem$ \emph{zero-knowledge} if for any $\REL \gets \RELGEN(\secparam)$ and adversary $\adv$ there exists a $\ppt$ simulator $\simulator$ such that
	\begin{multline*}
	  \left\{\ip{\prover(\REL, \inp, \wit)}{\adv(\REL, \inp, \wit)} \,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\} \approx_\secpar \\
		\left\{\ip{\simulator^{\adv}(\REL, \inp)}{\adv(\REL, \inp, \wit)}\,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\}\,.
	\end{multline*}
	%
	We call zero knowledge \emph{perfect} if the distributions are equal and \emph{computational} if they are indistinguishable for any NUPPT distinguisher.
\end{description}

Many proof systems additionally compounds of a setup algorithm $\kcrs$ that on input $\REL$ outputs a common reference string (CRS) $\crs$. The common reference string comes with a corresponding trapdoor $\td$ that allows the simulator to simulate a 
For the sake of succinctness we denote by $\trans$ a transcript of a conversation between the prover and the verifier extended with verifier's input $(\REL, \inp)$ (or $(\REL, \crs, \inp)$ in case of a proof system with a setup).
Furthermore, a proof system $\proofsystem$ is \emph{public coin} if the messages the verifier sends are chosen uniformly at random and independently of the messages send by the prover or system parameters.

Interactive proofs run in a multiprotcol environment are often required to fulfil a stronger notion of soundness called \emph{witness-extended emulation}~\cite{JC:Lindell03}. The following definition is inspired by  \cite{EC:GroIsh08} as their formulation of the witness-extended emulation considers proof systems that utilises a CRS. However, there are some changes introduced to fit better our purpose. More precisely, contrary to \cite{EC:GroIsh08,EC:BCCGP16} the extractor in \cref{def:wit_ext_em} is given the trapdoor $\td$, thus seems to be bit more powerful. 
That means that a protocol that has witness-extended emulation in terms of \cite{EC:GroIsh08} has it also according to the definition below. 

\begin{definition}[Witness-extended emulation]
	\label{def:wit_ext_em}
	We say a public coin proof system $\proofsystem = (\kcrs, \prover, \verifier, \simulator)$ has \emph{witness-extended emulation} if for all $\REL \in \image(\RELGEN)$, and deterministic adversary $\adv_1$ there exists an expected polynomial time extractor $\ext$ such that for all NUPPT adversaries $\adv_0$ holds
		\begin{multline*}
		\Pr\left[\adv_0 (\trans, \inp, \aux_{\adv_1}) = 1 \,\left|\,
		\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0, \\
				& \trans \gets \ip{\adv_1(\REL, \crs, \inp, \aux_{\adv_1})}{\verifier(\REL, \crs, \inp)}
			\end{aligned}
		\right.
		\right]
		 \approx_\secpar \\
		 \Pr\left[
			\begin{aligned}
				& \adv_1 (\trans) = 1\ \land \\
				& \text{if $\trans$ is accepting} \\ 
				& \pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}\,\left|\,
			\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0(\REL), \\ 
				& (\trans, \wit )\gets \ext^{\ip{\adv_1(\REL, \crs, \inp, \aux_\prover)}{\verifier(\REL, \crs, \inp)}}(\REL, \inp, \td)
			\end{aligned}
			\vphantom{\begin{aligned}
				\adv (\trans) = 1 \land \\
				\text{if $\trans{}$ is accepting} \\ 
				\pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}}\right.
			\right]\,,
\end{multline*}
where the extractor $\ext$ can rewind the conversation between the prover and the verifier to a particular round and run it again with a fresh randomness for the verifier. 
\end{definition} 
Although in the definition above the adversary $\adv_1$ is deterministic it obtains an auxiliary input $\aux_{\adv_1}$ that may be used by $\adv_1$ as a source of randomness. \cite{EC:GroIsh08} notes that since the protocol is public-coin, verifier's randomness is part of the transcript. Thus combining $\inp, \aux_\adv$ and an accepting transcript $\trans$ gives a view of both the prover and the verifier and thus gives a witness.

\begin{definition}[Simulation extractability]
	A proof system $\proofsystem$ is computationally (adaptively) \emph{strongly simulation-extractable for $\RELGEN$}, if for every NUPPT $\adv$, there exists a NUPPT extractor $\ext_\adv$, s.t.
	\[
	\condprob{
  \begin{aligned}
    &(\inp, \wit) \not\in \REL \land (\inp, \zkproof) \not\in Q \\
    & \land \verifier (\REL, \crs_{\verifier}, \inp, \zkproof) = 1
  \end{aligned}
  }
  {
		\begin{aligned}
		& \REL \gets \RELGEN (\secparam),
		(\crs, \td) \gets \kgen (\REL), r \sample \RND{\adv},
		\\ &
		((\inp, \zkproof)  \|  \wit) \gets (\adv^{\oracleo}  \|  \ext_\adv) (\REL, \crs; r)
		\end{aligned}
	} \leq \negl \enspace,
	\]
	where $\oracleo$ on input $\inp'$ returns $\zkproof' \gets \simulator(\REL, \crs, \td, \cdot)$ and writes $(\inp', \zkproof')$ to a list $Q$.
\end{definition}

\subsection{Simulation extractability for sigma protocols}
Faust et al.~\cite{INDOCRYPT:FKMV12} shown that every sigma protocol that is specially sound and has a unique response property is simulation-extractable. 

Let $\sigmaprot = (\prover, \verifier, \simulator)$ be a sigma protocol which transcript contains three messages $(a, b, z)$ with the middle being sent as a challenge from the verifier. 
Special soundness states that any acceptable pair of transcripts $(a, b, z)$ and $(a, b', z')$ for some statement $\inp$ can be used to extract the corresponding witness $\wit$. 
This is formalised and generalized by the so-called general forking lemma

\newcommand{\forking}{\pcalgostyle{F}}
\begin{lemma}[General forking lemma,~\cite{INDOCRYPT:FKMV12}]
	\label{lem:faust_forking_lemma}
	Fix $q \in \ZZ$ and a set $H$ of size $h > 2$. Let $\pdv$ be a PPT algorithm that on input $y, h_1, \ldots, h_q$ returns $(i, s)$, where $I \in\range{0}{q}$ and $s$ is called a \emph{side output}. 
	Denote by $\ig$ a randomised instance generator. 
	We denote by $\accProb$ the probability 
	\[
		\condprob{i > 0}{y \gets \ig; h_1, \ldots, h_1 \sample H; (i, s) \gets \pdv(y, h_1, \ldots, h_q)}\,.
	\] 
	Let $\forking_\pdv(y)$ denote the algorithm described in \cref{fig:faust_forking_lemma}, then the probability $\extProb$ defined as 
	$
		\extProb := \condprob{b = 1}{y \gets \ig; (b, s, s') \gets \forking_{\pdv}(y)}
	$
	holds 
	\[
		\extProb \geq \accProb \brak{\frac{\accProb}{q} - \frac{1}{h}}\,.
	\]
	%
	\begin{figure}
		\centering
		\fbox{
		\procedure{$\forking_\pdv (y)$}
		{
			r \sample \RND{\pdv}\\
			h_1, \ldots, h_q \sample H\\
			(i, s) \gets \pdv(y, h_1, \ldots, h_q; r)\\
			\pcif i = 0\ \pcreturn (0, \bot, \bot)\\
			h_{i'}, \ldots, h_{q'} \sample H\\
			(i', s') \gets \pdv(y, h_1, \ldots, h_{i - 1}, h_{i'} h_{q'}; r)\\
			\pcif (i = i') \land (h_{i} \neq h_{i'})\ \pcreturn (1, s, s')\\
			\pcind \pcelse \pcreturn (0, \bot, \bot)
		}}
		\caption{Forking algorithm $\forking_\pdv$}
		\label{fig:faust_forking_lemma}
\end{figure}
\end{lemma}
%
In case of a $\Sigma$-protocol, the probability $\extProb$ can be interpreted as a lower bound for a successful witness extraction from two transcripts. 
Let $\tr_1 = (\inp, a, z, \gamma)$ and $\tr_2 = (\inp, a, z', \gamma')$ be the transcripts.
Both $\tr_1$ and $\tr_2$ have to be \emph{acceptable}, i.e.~$i > 0$. Index $i$ can be interpreted as an index of $h_i$ which was sent as a challenge for $(\inp, a)$. For the sake of extractability, both transcripts have to have the same index $i$, i.e.~the same instance $\inp$ and the first message $a$, but the actual challenges $z = h_i$ and $z' = h_{i'}$ have to differ.

Another property required by Faust et al.~\cite{INDOCRYPT:FKMV12} to show simulation extractability of a sigma protocol is the unique response property which states that no PPT adversary can provide two different transcripts $(a, b, z)$ and $(a, b, z')$ such that the verifier $\verifier$ accepts both.

Finally \cite{INDOCRYPT:FKMV12} shows the following theorem:
\begin{theorem}[Simulation extractability of the Fiat--Shamir transform \cite{INDOCRYPT:FKMV12}]
	Let $\Sigma = (\prover, \verifier, \simulator)$ be a non-trivial $\Sigma$-protocol with unique responses for a language $\LANG \in \npol$. 
	In the random oracle model, the NIZK proof system $\Sigma_{\FS} = \ip{\prover^\ro}{\verifier^{\ro}}$ 	resulting by applying the Fiat--Shamir transform to $\Sigma$ is simulation extractable with extraction error $\eta = q/h$ for the \hl{canonical} simulator $\simulator$. Here, $q$ is the number of random oracle queries and $h$ is the number of elements in the range of $\ro$. Furthermore, the extractor $\ext_\adv$ needs to run $\adv^{\simulator_1}, \adv^{\simulator_2}$ twice.
\end{theorem}
% \task{14.05}{Need to make this theorem more general as currently it works only for 3-move $\Sigma$-protocols!}

% 
\section{Simulation extractability for multiround protocols}
Unfortunately, Faust et al.'s result cannot be directly applied in our case since the protocols we consider have more than three rounds of interaction.

\paragraph{Witness extended-emulation.}
First of all, although dubbed ``general'', \cref{lem:faust_forking_lemma} is not general enough for our purpose as it useful only for protocols that extract witness from two transcripts.

Fortunately, Bootle et al.~\cite{EC:BCCGP16} shown a more general version of the lemma. More precisely, they proved that each protocol that allows for a witness extraction from a bigger number of accepting transcripts has witness-extended emulation. \cite{EC:BCCGP16} defines a \emph{tree of accepting transcript}. 
Let $\proofsystem$ be a $(2 \mu + 1)$-move public-coin proof system with $\mu$ challenges $h_1, \ldots, h_\mu$. Let $n_i > 1$, for $i \in \range{1}{\mu}$.
Consider $\prod_{i = 1}^{\mu} n_i$ accepting transfers with challenges as a tree with depth $\mu$ and $\prod_{i = 1}^{\mu} n_i$ leaves.	Each node of depth $i < \mu$ has exactly $n_i$ children, each labelled with a distinct value for the $i$-th challenge $h_i$. We refer to that as a $(n_1, \ldots, n_\mu)$-tree of accepting transcripts.

 % \task{15.05}{Use one forking lemma (by Bootle et al) and show that the result from Faust holds for it anyway}
\begin{lemma}[Generalised general forking lemma~\cite{EC:BCCGP16}]
	\label{lem:bootle_forking_lemma}
	Let $\proofsystem = (\prover, \verifier, \simulator)$ be a $(2\mu + 1)$-move, public coin interactive  protocol. Let $\ext$ be a PPT witness extraction algorithm that always succeeds in extracting a witness from an $(n_1, \ldots, n_\mu)$-tree of accepting transcripts. Assume that $\prod_{i = 1}^{\mu} n_i \leq \poly$. 
	Then $(\prover, \verifier, \simulator)$ has witness-extended emulation.
\end{lemma}
As mentioned, any protocol that has witness-extended emulation defined as in \cite{EC:BCCGP16} is equipped with this property also in the light of \cref{def:wit_ext_em}.

\paragraph{Unique-response protocols.}
We say that a sigma-protocol has unique response property (Fischlin \cite{C:Fischlin05}), or is a ur-protocol, if there is no adversary that can produce two accepting transcripts that differ only on the last element. 
More precisely, let $\sigmaprot = (\prover, \verifier, \simulator_\zkproof)$ be a standard-model sigma-protocol for relation $\REL \gets \RELGEN(\secparam)$ which proofs compound of three messages $(\alpha, \beta, \gamma)$. We say that $\sigmaprot$ is a ur-protocol if for all PPT algorithms $\adv$ holds
\[
\condprob{\verifier (\alpha, \beta, \gamma) = \verifier (\alpha, \beta, \gamma')  = 1}{(\alpha, \beta, \gamma, \gamma') \gets \adv(\REL)} \leq \negl\,.
\]
For the sake of completeness we note that many sigma-protocols, like e.g.~Schnorr's protocol \cite{C:Schnorr89}, fulfil this requirement.

Fischlin's formulation, although perfectly fine for applications presented in \cite{C:Fischlin05}, is not enough in our case. 
First of all, the property assumes that the protocol has three rounds, with the middle being the challenge from the verifier. That is not the case we consider here. Second, it is not entirely clear how to generalize the property. Should one require that after the first challenge from the verifier the responses are fixed? That could not work since if there are more challenges then they are random. 
Even if we directly consider a protocol transformed by the Fiat--Shamir transform and the verifier challenges are determined by the random oracle it may be the case that the protocol contains some round (obviously, except the first one) where the prover randomises his message. In that case unique-responsiveness can not hold as well.
Last but not least, the protocol we consider here most, \plonk, is not in a standard-model, but utilises CRS. That also complicates things considerably.

We walk around these obstacles by providing two generalized notions of the unique response property, one dubbed \emph{weak} and another \emph{strong}. 
More precisely, we say that a $(2\mu + 1)$-round protocol has \emph{weak unique responses after $i$} and is called a weakly-$\ur{i}$-protocol if 
\begin{definition}[Weakly $\ur{i}$-protocol]
	\label{def:wiur}
	Let $\proofsystem = (\prover, \verifier, \simulator)$ be a standard-model interactive proof system. Denote by $a_0, b_0, \ldots, a_{\mu - 1}, b_{\mu - 1}, a_{\mu}$ the consecutive messages exchanged in the protocol, where messages $a_i$ come from the prover and $b_i$ from the verifier. We say that $\proofsystem$ has \emph{unique responses after $i$} if for any PPT adversary $\adv$ probability
	\[
		\condprob{
		\begin{aligned}
			& \verifier(\REL, \crs, (a_0, \ldots, a_{i + 1}, \ldots, a_{\mu})) = 1 \, \land \\ 
			& \verifier(\REL, \crs, (a_0, \ldots, a'_{i + 1} \ldots, a'_{\mu})) = 1
		\end{aligned}
		}
		{
		\begin{aligned}
			% & \crs \gets \kcrs(\REL), \\
			& (a_0, b_0, \ldots, a'_{i + 1}, b'_{i + 1}, \ldots, a'_{\mu}) \gets \adv(\REL, \crs),\\ 
			& (a_{i + 1}, b_{i + 1}, \ldots, a_{\mu}) \neq (a'_{i + 1}, b'_{i + 1}, \ldots, a'_{\mu})
		\end{aligned}
		}
	\]
	is negligible in $\secpar$.
\end{definition}

\subsection{Simulation extractability from unique responses and witness-extended emulation}
% Unfortunately the result of Faust et al.~is stated for a specific kind of special-sound proofs, i.e.~$\Sigma$-protocols, which compounds of three messages exchanged between the prover and the verifier. Both $\plonk$ and $\sonic$ require more interaction between these parties so that result is not directly applicable. However, we show that it can be generalised to a witness-extended emulatable protocols as well.
In this section we present two proofs for the Fiat--Shamir transform simulation extractability -- one for the standard---weaker---version of the unique response property, one for the stronger.

In the former, we assume that the underlying interactive proof system is in the standard model. More precisely, we require that the only additional power given to the simulator is the ability of producing proof elements in any order it wants. Especially, producing a simulated proof does not require knowledge of some sort of a trapdoor. 
Although we believe that this result may be of independent interest, it is not enough in our case, it is not enough to show simulation extractability of \plonk. 
This is since we show our result by contradiction and build an adversary $\bdv$ that breaks the unique response property using an adversary $\adv$ that breaks simulation extractability. Thus, to make the reduction hold we need to allow $\bdv$ to make simulated proofs for $\adv$.

To make the result useful in the context of CRS-model zkSNARKs like \plonk, we need to rely on a stronger version of the unique response property presented in \cref{def:siur} to allow the unique-response-property adversary to learn the simulated proofs as well.

\begin{theorem}[Simulation extractability of the Fiat--Shamir transform II]
	\label{thm:wit_ext_em_FS}
	Let $\proofsystem = (\prover, \verifier, \simulator_\zkproof)$ be a standard-model interactive $\ur{i}$-protocol for a relation $\REL$. 
	Assume there exists an extractor $\ext$ that extracts the witness from a $(1, \ldots, 1, n_i, \ldots, n_\mu)$-tree of accepting transcripts. 
	Then $\proofsystem_\fs$ is simulation-extractable in the random oracle model if $N =\prod_{j = i}^\mu = \poly$.
	Furthermore the extractor $\ext_\fs$ for $\proofsystem_\fs$ needs to run $(\simulator_\ro, \simulator_\zkproof)$ $N$ times.
\end{theorem}
\begin{proof}
	Let $\adv^{\simulator_{\ro}, \simulator_\zkproof}$ produces for an instance $\inp$ an acceptable proof $\zkproof_\fs = (a_0, \ldots, a_{i + 1}, \ldots, a_\mu)$ that is not in the list $Q$. 
	Because of the $\ur{i}$ property, $(\inp, a_0, b_0, \ldots, a_{i})$ must be a fresh query to the random oracle $\ro$. (Otherwise the rest of the proof is uniquely determined and the proof was already recorded in $Q$.)
	We now consider $\prod_{j = i}^\mu n_j$ runs of the adversary that differ by picking at random random oracle outputs on $a_{i + 1}, \ldots, a_\mu$. That is, the runs differ by the different randomness provided by $\simulator_\crs$. Assume that all such runs produce an acceptable transcript. Probability of such event is non-negligible over the choice of adversary's and simulator $\simulator_\crs$ randomness.
	By \cref{lem:bootle_forking_lemma} there exists an extractor $\ext$ that provided $N$ transcripts extracts witness $\wit$. Thus $\zkproof_\fs$ is simulation extractable.
	\task{8.06}{Write the full reduction for unique responses for PPT adversaries, not strict ur.}
\end{proof}

% 
% Faust et al.~\cite{INDOCRYPT:FKMV12} shown that a special-sound $\Sigma$-protocol that is also $\ur{1}$ 

\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto,additional_bib}

\appendix
\section{$\plonk$ protocol rolled-out}

\section{Old subsections}
\subsection{Interpolation of rational functions}
Let $F(X) = P(X) / Q(X)$ be a rational function defined over $\FF(X)$ such that $\deg P = m_a$ and $\deg Q = m_b$. We call a set $V = \smallset{(x_i, y_i)}_{i \in I}$ a \emph{support set} of $F$ if for all $i \in I$ holds $F(x_i) = y_i$. 
As shown by Minsky et al.~in \cite{TIT:MinTraZip03} if $P$ and $Q$ are monic, then a support set $V$ of size at least $m_a + m_b$ unambiguously determines $F$. 

\begin{lemma}[Rational function interpolation~{\cite[Theorem 4.1]{TIT:MinTraZip03}}]
	\label{lem:rational_function_interpolation}
  Let $F(X) = P(X) / Q(X)$ be a rational function and let $P(X) = X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$. Let $V_F$ be a support set of size $m = m_a + m_b$, then $V_F$ determines $F$ unambiguously.
\end{lemma}

Note that the theorem above assumes that the polynomials determining $F$ are monic and their degrees are known. In general, a rational function is not defined unambiguously and $F(X) = P(X) / Q(X) \in \FF(X)$ represents a whole equivalence class of functions 
\[
	F(X) = \frac{P(X)}{Q(X)} \equiv \frac{P(X) f(X)}{Q(X) f(X)}\,,
\]
for some $P(X), Q(X), f(X) \in \FF[X]$.
However, when the degree of the denominator polynomial $Q(X)$ is known, then the function is determined up to $f(X)$ that are \emph{constant}. Any other polynomial would change the denominator degree). 
Furthermore, if in $Q(X)$ there is at least one coefficient that is already known, then the whole function $F(X)$ is determined uniquely, i.e.~$f(X) \equiv 1$. Other $f$-s would affect the known coefficient $q_i$. 
The following lemma can be formulated:
\begin{lemma}
	\label{lem:rational_function_interpolation_2}
	Let $F(X) = P(X) / Q(X)$ be a rational function for $P(X) = p_0 X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = q_0 X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$ such that $q_0$ is non-zero and at least one of the coefficients $q_i$ is known.
	Let $V_F$ be a support set of size $m = m_a + m_b + 1$, then $V_F$ determines $F$ unambiguously. 
\end{lemma}
\begin{proof}
	The lemma has almost the same proof as \cref{lem:rational_function_interpolation}. Consider two functions $P_0 / Q_0$, $P_1 / Q_1$ that share the same values for each $x_i \in V_F$. That is,
	\[
		\frac{P_0(x_i)}{Q_0(x_i)} = \frac{P_1(x_i)}{Q_1(x_i)}\,.
	\]
	Polynomial $P_0(X) Q_1(X) - P_1(X) Q_0(X)$ has degree at most $(m_a + m_b)$ and zeroes in at least $(m_a + m_b + 1)$ points, thus is identically zero. Thus
	\[
		\frac{P_0(X)}{Q_0(X)} = \frac{P_1(X)}{Q_1(X)}\,
	\]
	and the functions determined by $P_0, Q_0$ and $P_1, Q_1$ are in the same equivalence class (i.e.~are the same function). Considering the observations above, only one function in this class exists if we specify concrete degree of the denominator polynomial and one of its coefficients.
	\qed
\end{proof}

\section{Simulation extractability of \plonk [OLD]}
The main idea behind showing that \plonk{} is simulation extractable relies on the result by Faust et al.~\cite{INDOCRYPT:FKMV12} where the authors show that a public-coin special-sound protocol made non-interactive by the Fiat--Shamir transform is simulation extractable.
Thus showing that \plonk{} is special-sound and public-coin is enough to show its simulation extractability. It is obvious that \plonk{} is public-coin, thus what remains is to show it is also special-sound.

To that end we take one of the polynomials that are computed by the prover and which contains the witness as parts of the coefficients and, by programming the random oracle and rewinding the prover, we evaluate it on many different points. This allows to recreate the coefficients of the function and therefore the witness.  
%
More precisely, the polynomial $Z(X)$ computed by the prover in the second round of the protocol is used. First the polynomial is expressed as a rational function $\Gamma$ of a formal variable $X_\gamma$, which is evaluated as $\gamma$. 
The variable $\gamma$ is given by the random oracle $\ro$ prior to Round 2. 
By programming $\ro$ and rewinding the prover one can evaluate $\Gamma$ in various points one can recreate the coefficients of $\Gamma$ and compute the witness. 

We note that the extraction procedure is not very efficient. Function $\Gamma$ has numerator and denominator polynomials of degrees linear to the size of the statement. Thus a linear number of rewinds is necessary to recreate the witness.
However, we point out that the efficiency of the extractor does not influences the efficiency of a protocol run between the prover and verifier.

\begin{theorem}[Witness-extended emulation in \plonk{}]
  \plonk{} has witness-extended emulation in the random oracle model.
\end{theorem}
\begin{proof}
In the second round of \plonk{} the prover gets from a random oracle $\beta = \ro(0, \tr)$ and $\gamma = \ro(1, \tr)$, where $\tr$ is the transcript of the previous messages exchanged in the protocol. Then he computes a polynomial
\begin{multline*}
  \label{eq:Z}
  Z(X) = (b_7 X^2 + b_8 X + b_9) (X^\instsize - 1) + L_1 (X) + \\
   + \sum_{i = 1}^{\instsize - 1}\brak{L_{i + 1}(X) \prod_{j = 1}^{i} 
  \frac{(\wit_j + \beta \w^{j - 1} + \gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + \gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + \gamma)}
  {(\wit_j + \sigma(j)\beta + \gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + \gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + \gamma)}
  }\,
\end{multline*}
and makes $\gone{Z(\chi)}$ part of his proof. 
Here, $L_i$ are Lagrange basis polynomials, $\smallset{1, \w, \ldots, \w^{\instsize - 1}}$ are roots of unity, $\sigma(j)$ are values determined by the permutation, which defines the circuit (i.e.~which gate is connected to which gate), and $k_1, k_2$ are other \emph{publicly known} values.

Since $\chi$ is fixed, $Z(\chi)$ can be expressed as an evaluation of a rational function $\Gamma(X_\gamma)$ at $\gamma$. We will now focus on interpolating $\Gamma$.
For the sake of readability we denote by $p_i (X_\gamma)$ a polynomial corresponding to the $i$-th product of the numerator of the big fraction in $Z$, that is
\[
  p_i(X_\gamma) = \prod_{j = 1}^{i} L_{i + 1} (\wit_j + \beta \w^{j - 1} + X_\gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + X_\gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + X_\gamma)\,.
\]
Similarly, $q_i (X_\gamma)$ denotes the $i$-th product of the denominator
\[
  q_i(X_\gamma) = \prod_{j = 1}^{i} (\wit_j + \sigma(j)\beta + X_\gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + X_\gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + X_\gamma)\,.
\]

To make the necessary summation all fractions are given a common denominator equal $q_1 (X_\gamma) \cdot \ldots \cdot q_{\instsize - 1} (X_\gamma)$. After this operation, $\Gamma(\gamma)$ can be written as
\begin{multline*}
  \Gamma(\gamma) = (b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi) + \\
   + \brak{\frac{
   p_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma) + q_1(\gamma) p_2(\gamma) q_3(\gamma) \ldots q_{\instsize - 1}(\gamma) + \ldots + q_1(\gamma) \ldots q_{\instsize - 2}(\gamma) p_{\instsize - 1}(\gamma)
   }{
   q_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma)
   }
  }\,.
\end{multline*}
Finally, let 
\[
  \Gamma (X_\gamma) = \frac{N(X_\gamma)}{D(X_\gamma)}\,,
\]
where 
\begin{align*}
  N(X_\gamma) & = \brak{(b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi)} \cdot q_1(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \\
   & + p_1(X_\gamma) q_2(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + q_1(X_\gamma) p_2(X_\gamma) q_3(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \ldots \\
   & + q_1(X_\gamma) \ldots q_{\instsize - 2}(X_\gamma) p_{\instsize - 1}(X_\gamma)\,,\\
  D(X_\gamma) & = q_1(X_\gamma)  \ldots q_{\instsize - 1}(X_\gamma)\,.
\end{align*} 
Both $N(X_\gamma)$ and $D(X_\gamma)$ have degree $\maxdegree = 3 \frac{(\instsize - 1) \instsize}{2}$, since $\deg p_i (X_\gamma) \allowbreak = \deg q_i (X_\gamma) = 3 i$.

Observe that 
\begin{inparaenum}[(i)]
	\item the degree of polynomial $D(X_\gamma)$ is known and 
	\item one of its coefficients is known, more precisely, the coefficient by the highest power, $X_\gamma^{3i}$, is $1$.
\end{inparaenum}
Hence the requirements for \cref{lem:rational_function_interpolation_2} are met.
 
Following \cref{def:wit_ext_em} we can assume that the extractor gets as input the trapdoor corresponding to the CRS and knows $\chi$.
Thus the only unknown values in $Z$ are the values of witness elements $\smallset{\wit_{\instsize + j}}_{j = 1}^{2 \instsize}$ (note that the values $\smallset{\wit_{j}}_{j = 1}^{\instsize}$ are public, i.e.~$\smallset{\wit_{j}}_{j = 1}^{\instsize} = \inp$) and randomisers $b_7, b_8, b_9$ which are picked by the prover at the beginning of the protocol. 
We need to show now that information the extractor has about the coefficients of $\Gamma(X_\gamma)$ is enough to extract the witness, even though some coefficients may depend on
\begin{inparaenum}[(i)]
	\item more than one witness element and\label{it:many_wit}
	\item randomisers $b_7, b_8, b_9$.\label{it:randomisers}
\end{inparaenum}
 %
\task{15.05}{Missing part -- show that we know enough about coefficients of $\Gamma$ to extract the witness even though (1) some coefficients may depend on many witness parts, (2) some coefficients may depend on the blinders $b_i$}
%
Again we focus on the denominator function $D(X_\gamma)$ to tackle \cref{it:many_wit,it:randomisers}.
First, we look at the coefficient by the $X_\gamma^{\maxdegree - 1}$ (i.e.~the second highest power) which is  \hl{continue}
That resolves \cref{it:many_wit}. The other issue that comes with \cref{it:randomisers} is easy since there are no randomisers used in the denominator polynomial.
\qed
\end{proof}

\end{document}