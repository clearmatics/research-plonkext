% !TeX spellcheck = en_GB
\let\accentvec\vec
\documentclass[runningheads]{llncs}
 % \documentclass[runningheads]{amsart}
\let\spvec\vec
\let\vec\accentvec
\usepackage{amssymb,amsmath}
\let\vec\spvec

\usepackage[T1]{fontenc}

\newcommand{\iflipics}[1] {}
\newcommand{\iflncs}[1] {#1}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
	{\mbox{\boldmath$\textstyle#1$}}
	{\mbox{\boldmath$\scriptstyle#1$}}
	{\mbox{\boldmath$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

% lncs size (as printed in books, with small margins):
\usepackage[paperheight=23.5cm,paperwidth=15.5cm,text={13.2cm,20.3cm},centering]{geometry}


\newcommand{\ifamsart}[1] {}
\ifamsart{
	\newtheorem{theorem}{Theorem}%[section]
	\newtheorem{proposition}[theorem]{Proposition}
	\newtheorem{lemma}[theorem]{Lemma}
	\newtheorem{corollary}[theorem]{Corollary}
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definition}
	\newtheorem{example}[theorem]{Example}
}

\usepackage{soulutf8}
\soulregister\cite7
\soulregister\ref7
\soulregister\pageref7
\usepackage{hyperref}
\hypersetup{final}
\usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}
\usepackage[capitalise]{cleveref}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed} 

\include{macros}

\title{On Simulation-Extractability of \textsc{Plonk}}
% \titlerunning{Achieving additional security in LegoSNARK}

\author{Michał Zając}
\iflncs{
  \institute{Clearmatics, London, UK\\ \email{m.p.zajac@gmail.com}}
}

\allowdisplaybreaks

\begin{document}
	\sloppy
	\maketitle

\begin{abstract}
	In this paper we prove that some most-efficient updatable universal zkSNARKs like \plonk{}~\cite{EPRINT:GabWilCio19} and Sonic~\cite{CCS:MBKM19} are (non black-box) simulation extractable. 
	To that end, we generalise the result by Faust et al.~\cite{INDOCRYPT:FKMV12} (INDOCRYPT 2012) and show that any witness-extended emulatable is also simulation-extractable if made non-interactive by the Fiat--Shamir transform. We then explain why \plonk{} is has witness-extended emulation and conclude by showing its simulation-extractability.
	\michals{14.05}{Since Sonic is witness-extended emulation then it should be simulation extractable as well.}
	\task{15.05}{Check Marlin}
\end{abstract}

\section{Introduction}

\section{Preliminaries}
Let PPT denote probabilistic polynomial-time.
Let $\secpar \in \NN$ be the security parameter.
All adversaries will be stateful.
For an algorithm $\adv$, let $\IM (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), let $\RND{\adv}$ denote the random tape of $\adv$ (assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote the random choice of the randomiser $r$ from $\RND{\adv}$.
We denote by $\negl$ an arbitrary negligible function.

Distributions $X$ and $Y$ have \emph{statistical distance} $\SD$ equals $\epsilon$ if $\sum_{a \in \supp{X \cup Y}} \abs{\prob{X = a} - \prob{Y = a}} = \epsilon$.
We write $X \approx_\secpar Y$ if $\SD(X, Y) \leq \negl$, where $\SD$ is the statistical distance between the distributions.
For values $a$ and $b$ we write $a \approx_\secpar b$ if $\abs{a - b} \leq \negl$. 

\paragraph{Bilinear groups.}
A bilinear group generator $\pgen (1^\secpar)$ returns $(p, \GRP_1, \GRP_2, \GRP_T, \pair, \gone{1}, \gtwo{1})$, where $\GRP_1$, $\GRP_2$, and $\GRP_T$ are additive cyclic groups of prime order $p = 2^{\Omega (\secpar)}$, $\gone{1}, \gtwo{1}$ are generators of $\GRP_1$, $\GRP_2$, resp., and $\pair: \GRP_1 \times \GRP_2 \to \GRP_T$ is a non-degenerate PPT-computable bilinear pairing.
We assume the bilinear pairing to be Type-3, i.e., that there is no efficient isomorphism from $\GRP_1$ to $\GRP_2$ or from $\GRP_2$ to $\GRP_1$.
We use the by now standard bracket notation, i.e., we write $\bmap{a}{\gi}$ to denote $a g_{\gi}$ where $g_{\gi}$ is a fixed generator of $\GRP_{\gi}$.
We denote $\pair (\gone{a}, \gtwo{b})$ as $\gone{a} \gtwo{b}$.
Thus, $\gone{a} \gtwo{b} = \gtar{a b}$.
We freely use the bracket notation with matrices, e.g., if $\vec{A} \vec{B} = \vec{C}$ then $\vec{A} \grpgi{\vec{B}} = \grpgi{\vec{C}}$ and $\gone{\vec{A}} \gtwo{\vec{B}} = \gtar{\vec{C}}$.

\subsection{Zero knowledge}
In a zero-knowledge proof or argument system, a prover convinces the verifier of the veracity of a statement without leaking any side information except that the statement is true.
Here, a proof (resp., an argument) system guarantees soundness against an unbounded (resp., a PPT) cheating prover.
The zero-knowledge property is proven by constructing a simulator that can simulate the view of a cheating verifier without knowing the secret information (witness) of the prover.

More precisely, let $\RELGEN(\secparam)$ be an algorithm that outputs an $\npol$ relation $\REL = \smallset{(\inp, \wit)}$. Denote by $\LANG_\REL$ the language determined by $\REL$. 
Let $\prover$ and $\verifier$ be algorithms, the former called \emph{prover} and the latter \emph{verifier}. 
We denote by $\ip{\prover(\REL, \inp, \wit)}{\verifier(\REL, \inp)}$ a transcript of conversation between a $\prover$ with input $(\REL, \inp, \wit)$ and $\verifier$ with input $(\REL, \inp)$. 
We write $\ip{\prover (\REL, \inp, \wit)}{\verifier(\REL, \inp)} = 1$ if in the end of the transcript the verifier $\verifier$ returns $1$ and say that $\verifier$ accepts the transcript.

A proof system $\proofsystem = (\prover, \verifier, \simulator)$ for $\RELGEN$ is required to have three properties: completeness, soundness and zero knowledge, which are defined as follows:
\begin{description}
	\item[Completeness] An interactive proof system $\proofsystem$ is \emph{complete} if an hnest prover always convinces an honest verifier, that is for all $\REL \gets \RELGEN(\secparam)$ and $(\inp, \wit) \in \REL$
	\[
		\prob{\ip{\prover (\inp, \wit)}{\verifier (\inp)} = 1} = 1\,.
	\]
	\item[Soundness] We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no PPT prover $\adv$ can convince an honest verifier $\verifier$ to accept a proof for a false statement, i.e~for $\inp \not\in\LANG$. More precisely, for all $\REL \gets \RELGEN(\secparam)$
	\[
		\condprob{\ip{\adv(\REL, \inp)}{\verifier(\REL, \inp)} = 1}{\inp \gets \adv(\REL); \inp \not\in \LANG_\REL} \leq \negl\,;
	\]
	\item[Zero knowledge] We call an interactive proof system $\proofsystem$ \emph{zero-knowledge} if for any $\REL \gets \RELGEN(\secparam)$ and adversary $\adv$ there exists a $\ppt$ simulator $\simulator$ such that
	\begin{multline*}
	  \left\{\ip{\prover(\REL, \inp, \wit)}{\adv(\REL, \inp, \wit)} \,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\} \approx_\secpar \\
		\left\{\ip{\simulator^{\adv}(\REL, \inp)}{\adv(\REL, \inp, \wit)}\,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\}\,.
	\end{multline*}
	%
	We call zero knowledge \emph{perfect} if the distributions are equal and \emph{computational} if they are indistinguishable for any NUPPT distinguisher.
\end{description}

Many proof systems additionally compounds of a setup algorithm $\kcrs$ that on input $\REL$ outputs a common reference string (CRS) $\crs$. The common reference string comes with a corresponding trapdoor $\td$ that allows the simulator to simulate a 
For the sake of succinctness we denote by $\trans$ a transcript of a conversation between the prover and the verifier extended with verifier's input $(\REL, \inp)$ (or $(\REL, \crs, \inp)$ in case of a proof system with a setup).
Furthermore, a proof system $\proofsystem$ is \emph{public coin} if the messages the verifier sends are chosen uniformly at random and independently of the messages send by the prover or system parameters.

Interactive proofs run in a multiprotcol environment are often required to fulfil a stronger notion of soundness called \emph{witness-extended emulation}~\cite{JC:Lindell03}. The following definition is inspired by  \cite{EC:GroIsh08} as their formulation of the witness-extended emulation considers proof systems that utilises a CRS. However, there are some changes introduced to fit better our purpose. More precisely, contrary to \cite{EC:GroIsh08,EC:BCCGP16} the extractor in \cref{def:witextem} is given the trapdoor $\td$, thus seems to be bit more powerful. 
That means that a protocol that has witness-extended emulation in terms of \cite{EC:GroIsh08} has it also according to the definition below. 

\begin{definition}[Witness-extended emulation]
	\label{def:wit_ext_em}
	We say a public coin proof system $\proofsystem = (\kcrs, \prover, \verifier, \simulator)$ has \emph{witness-extended emulation} if for all $\REL \in \IM(\RELGEN)$, and deterministic adversary $\adv_1$ there exists an expected polynomial time extractor $\ext$ such that for all NUPPT adversaries $\adv_0$ holds
		\begin{multline*}
		\Pr\left[\adv_0 (\trans, \inp, \aux_{\adv_1}) = 1 \,\left|\,
		\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0, \\
				& \trans \gets \ip{\adv_1(\REL, \crs, \inp, \aux_{\adv_1})}{\verifier(\REL, \crs, \inp)}
			\end{aligned}
		\right.
		\right]
		 \approx_\epsilon \\
		 \Pr\left[
			\begin{aligned}
				& \adv_1 (\trans) = 1\ \land \\
				& \text{if $\trans$ is accepting} \\ 
				& \pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}\,\left|\,
			\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0, \\ 
				& (\trans, \wit )\gets \ext^{\ip{\adv_1(\REL, \crs, \inp, \aux_\prover)}{\verifier(\REL, \crs, \inp)}}(\REL, \inp, \td)
			\end{aligned}
			\vphantom{\begin{aligned}
				\adv (\trans) = 1 \land \\
				\text{if $\trans{}$ is accepting} \\ 
				\pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}}\right.
			\right]\,,
\end{multline*}
where the extractor $\ext$ can rewind the conversation between the prover and the verifier to a particular round and run it again with a fresh randomness for the verifier. 
\end{definition} 
Although in the definition above the adversary $\adv_1$ is deterministic it obtains an auxiliary input $\aux_{\adv_1}$ that may be used by $\adv_1$ as a source of randomness. \cite{EC:GroIsh08} notes that since the protocol is public-coin, verifier's randomness is part of the transcript. Thus combining $\inp, \aux_\adv$ and an accepting transcript $\trans$ gives a view of both the prover and the verifier and thus gives a witness.

\begin{definition}[Simulation extractability]
	A proof system $\proofsystem$ is computationally (adaptively) \emph{strongly simulation-extractable for $\RELGEN$}, if for every NUPPT $\adv$, there exists a NUPPT extractor $\ext_\adv$, s.t.
	\[
	\condprob{
  \begin{aligned}
    &(\inp, \wit) \not\in \REL \land (\inp, \zkproof) \not\in Q \\
    & \land \verifier (\REL, \crs_{\verifier}, \inp, \zkproof) = 1
  \end{aligned}
  }
  {
		\begin{aligned}
		& \REL \gets \RELGEN (\secparam),
		(\crs, \td) \gets \kgen (\REL), r \sample \RND{\adv},
		\\ &
		((\inp, \zkproof)  \|  \wit) \gets (\adv^{\oracleo}  \|  \ext_\adv) (\REL, \crs; r)
		\end{aligned}
	} \leq \negl \enspace,
	\]
	where $\oracleo$ on input $\inp'$ returns $\zkproof' \gets \simulator(\REL, \crs, \td, \cdot)$ and writes $(\inp', \zkproof')$ to a list $Q$.
\end{definition}

\subsection{General forking lemma and its generalisation}
\newcommand{\forking}{\pcalgostyle{F}}
\begin{lemma}[General forking lemma,~\cite{INDOCRYPT:FKMV12}]
	\label{lem:faust_forking_lemma}
	Fix $q \in \ZZ$ and a set $H$ of size $h > 2$. Let $\pdv$ be a PPT algorithm that on input $y, h_1, \ldots, h_q$ returns $(i, s)$, where $I \in\range{0}{q}$ and $s$ is called a \emph{side output}. 
	Denote by $\ig$ a randomised instance generator. 
	We denote by $\accProb$ the probability 
	\[
		\condprob{i > 0}{y \gets \ig; h_1, \ldots, h_1 \sample H; (i, s) \gets \pdv(y, h_1, \ldots, h_q)}\,.
	\] 
	Let $\forking_\pdv(y)$ denote the algorithm described in \cref{fig:faust_forking_lemma}, then the probability $\extProb$ defined as 
	$
		\extProb := \condprob{b = 1}{y \gets \ig; (b, s, s') \gets \forking_{\pdv}(y)}
	$
	holds 
	\[
		\extProb \geq \accProb \brak{\frac{\accProb}{q} - \frac{1}{h}}\,.
	\]
	%
	\begin{figure}
		\centering
		\fbox{
		\procedure{$\forking_\pdv (y)$}
		{
			r \sample \RND{\pdv}\\
			h_1, \ldots, h_q \sample H\\
			(i, s) \gets \pdv(y, h_1, \ldots, h_q; r)\\
			\pcif i = 0\ \pcreturn (0, \bot, \bot)\\
			h_{i'}, \ldots, h_{q'} \sample H\\
			(i', s') \gets \pdv(y, h_1, \ldots, h_{i - 1}, h_{i'} h_{q'}; r)\\
			\pcif (i = i') \land (h_{i} \neq h_{i'})\ \pcreturn (1, s, s')\\
			\pcind \pcelse \pcreturn (0, \bot, \bot)
		}}
		\caption{Forking algorithm $\forking_\pdv$}
		\label{fig:faust_forking_lemma}
\end{figure}
\end{lemma}
%
Probabilty $\ext$ can be interpreted as a lower bound for a successful witness extraction from two transcripts. The transcripts have to be \emph{acceptable} (i.e.~$i > 0$) and it should be impossible to tell from $\pdv$'s output whether it got as input $h_1, \ldots, h_q$ or $h_1, \ldots, h_{i - 1}, h_{i'}, \ldots, h_{q'}$.
Although dubbed ''general'', \cref{lem:faust_forking_lemma} is not general enough for our purpose as it useful only for protocols that extract witness from two transcripts.

Fortunately, Bootle et al.~\cite{EC:BCCGP16} shown a more general version of the lemma. More precisely, they proved that each protocol that allows for a witness extraction from a bigger number of accepting transcripts has witness-extended emulation. \cite{EC:BCCGP16} defines a \emph{tree of accepting transcript}. Let $\proofsystem$ be a $(2 \mu + 1)$-move public-coin proof system with $\mu$ challenges $h_1, \ldots, h_\mu$. Let $n_i > 1$, for $i \in \range{1}{\mu}$.
Consider $\prod_{i = 1}^{\mu} n_i$ accepting transfers with challenges as a tree with depth $\mu$ and $\prod_{i = 1}^{\mu} n_i$ leaves.	Each node of depth $i < \mu$ has exactly $n_i$ children, each labelled with a distinct value for the $i$-th challenge $h_i$. We refer to that as a $(n_1, \ldots, n_\mu)$-tree of accepting transcripts.

 \task{15.05}{Use one forking lemma (by Bootle et al) and show that the result from Faust holds for it anyway}
\begin{lemma}[Generalised general forking lemma~\cite{EC:BCCGP16}]
	\label{lem:bootle_forking_lemma}
	Let $\ip{\prover}{\verifier}$ be a $(2\mu + 1)$-move, public coin interactive  protocol. Let $\ext$ be a PPT witness extraction algorithm that always succeeds in extracting a witness from an $(n_1,\ldots, n_\mu)$-tree of accepting transcripts. Assume that $\prod_{i = 1}^{\mu} n_i \leq \poly$. 
	Then $\ip{\prover}{\verifier}$ has witness-extended emulation.
\end{lemma}
As mentioned, any protocol that has witness-extended emulation defined as in \cite{EC:BCCGP16} is equipped with this property also in the light of \cref{def:wit_ext_em}.

\subsection{Interpolation of rational functions}
Let $F(X) = P(X) / Q(X)$ be a rational function defined over $\FF(X)$ such that $\deg P = m_a$ and $\deg Q = m_b$. We call a set $V = \smallset{(x_i, y_i)}_{i \in I}$ a \emph{support set} of $F$ if for all $i \in I$ holds $F(x_i) = y_i$. 
As shown by Minsky et al.~in \cite{TIT:MinTraZip03} if $P$ and $Q$ are monic, then a support set $V$ of size at least $m_a + m_b$ unambiguously determines $F$. 

\begin{lemma}[Rational function interpolation~{\cite[Theorem 4.1]{TIT:MinTraZip03}}]
	\label{lem:rational_function_interpolation}
  Let $F(X) = P(X) / Q(X)$ be a rational function and let $P(X) = X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$. Let $V_F$ be a support set of size $m = m_a + m_b$, then $V_F$ determines $F$ unambiguously.
\end{lemma}

Note that the theorem above assumes that the polynomials determining $F$ are monic and their degrees are known. In general, a rational function is not defined unambiguously and $F(X) = P(X) / Q(X) \in \FF(X)$ represents a whole equivalence class of functions 
\[
	F(X) = \frac{P(X)}{Q(X)} \equiv \frac{P(X) f(X)}{Q(X) f(X)}\,,
\]
for some $P(X), Q(X), f(X) \in \FF[X]$.
However, when the degree of the denominator polynomial $Q(X)$ is known, then the function is determined up to $f(X)$ that are \emph{constant}. Any other polynomial would change the denominator degree). 
Furthermore, if in $Q(X)$ there is at least one coefficient that is already known, then the whole function $F(X)$ is determined uniquely, i.e.~$f(X) \equiv 1$. Other $f$-s would affect the known coefficient $q_i$. 
The following lemma can be formulated:
\begin{lemma}
	\label{lem:rational_function_interpolation_2}
	Let $F(X) = P(X) / Q(X)$ be a rational function for $P(X) = p_0 X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = q_0 X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$ such that $q_0$ is non-zero and at least one of the coefficients $q_i$ is known.
	Let $V_F$ be a support set of size $m = m_a + m_b + 1$, then $V_F$ determines $F$ unambiguously. 
\end{lemma}
\begin{proof}
	The lemma has almost the same proof as \cref{lem:rational_function_interpolation}. Consider two functions $P_0 / Q_0$, $P_1 / Q_1$ that share the same values for each $x_i \in V_F$. That is,
	\[
		\frac{P_0(x_i)}{Q_0(x_i)} = \frac{P_1(x_i)}{Q_1(x_i)}\,.
	\]
	Polynomial $P_0(X) Q_1(X) - P_1(X) Q_0(X)$ has degree at most $(m_a + m_b)$ and zeroes in at least $(m_a + m_b + 1)$ points, thus is identically zero. Thus
	\[
		\frac{P_0(X)}{Q_0(X)} = \frac{P_1(X)}{Q_1(X)}\,
	\]
	and the functions determined by $P_0, Q_0$ and $P_1, Q_1$ are in the same equivalence class (i.e.~are the same function). Considering the observations above, only one function in this class exists if we specify concrete degree of the denominator polynomial and one of its coefficients.
	\qed
\end{proof}

\section{Simulation extractability from witness-extended emulation}
\begin{theorem}[Simulation extractability of the Fiat-Shamir transform \cite{INDOCRYPT:FKMV12}]
	Let $\Sigma = \ip{\prover}{\verifier}$ be a non-trivial $\Sigma$-protocol with unique responses for a language $\LANG \in \npol$. 
	In the random oracle model, the NIZK proof system $\Sigma_{\FS} = \ip{\prover^\ro}{\verifier^{\ro}}$ 	resulting by applying the Fiat--Shamir transform to $\Sigma$ is simulation extractable with extraction error $\eta = q/h$ for the \hl{canonical} simulator $\simulator$. Here, $q$ is the number of random oracle queries and $h$ is the number of elements in the range of $\ro$. Furthermore, the extractor $\ext_\adv$ needs to run $\adv^{\simulator_1}, \adv^{\simulator_2}$ twice.
\end{theorem}
\task{14.05}{Need to make this theorem more general as currently it works only for 3-move $\Sigma$-protocols!}

Unfortunately the result of Faust et al.~is stated for a specific kind of special-sound proofs, i.e.~$\Sigma$-protocols, which compounds of three messages exchanged between the prover and the verifier. Both $\plonk$ and $\sonic$ require more interaction between these parties so that result is not directly applicable. However, we show that it can be generalised to a witness-extended emulatable protocols as well.

\section{$\plonk$ protocol rolled-out}
\section{Simulation extractability of \plonk}
The main idea behind showing that \plonk{} is simulation extractable relies on the result by Faust et al.~\cite{INDOCRYPT:FKMV12} where the authors show that a public-coin special-sound protocol made non-interactive by the Fiat--Shamir transform is simulation extractable.
Thus showing that \plonk{} is special-sound and public-coin is enough to show its simulation extractability. It is obvious that \plonk{} is public-coin, thus what remains is to show it is also special-sound.

To that end we take one of the polynomials that are computed by the prover and which contains the witness as parts of the coefficients and, by programming the random oracle and rewinding the prover, we evaluate it on many different points. This allows to recreate the coefficients of the function and therefore the witness.  
%
More precisely, the polynomial $Z(X)$ computed by the prover in the second round of the protocol is used. First the polynomial is expressed as a rational function $\Gamma$ of a formal variable $X_\gamma$, which is evaluated as $\gamma$. 
The variable $\gamma$ is given by the random oracle $\ro$ prior to Round 2. 
By programming $\ro$ and rewinding the prover one can evaluate $\Gamma$ in various points one can recreate the coefficients of $\Gamma$ and compute the witness. 

We note that the extraction procedure is not very efficient. Function $\Gamma$ has numerator and denominator polynomials of degrees linear to the size of the statement. Thus a linear number of rewinds is necessary to recreate the witness.
However, we point out that the efficiency of the extractor does not influences the efficiency of a protocol run between the prover and verifier.

\begin{theorem}[Witness-extended emulation in \plonk{}]
  \plonk{} has witness-extended emulation in the random oracle model.
\end{theorem}
\begin{proof}
In the second round of \plonk{} the prover gets from a random oracle $\beta = \ro(0, \tr)$ and $\gamma = \ro(1, \tr)$, where $\tr$ is the transcript of the previous messages exchanged in the protocol. Then he computes a polynomial
\begin{multline*}
  \label{eq:Z}
  Z(X) = (b_7 X^2 + b_8 X + b_9) (X^\instsize - 1) + L_1 (X) + \\
   + \sum_{i = 1}^{\instsize - 1}\brak{L_{i + 1}(X) \prod_{j = 1}^{i} 
  \frac{(\wit_j + \beta \w^{j - 1} + \gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + \gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + \gamma)}
  {(\wit_j + \sigma(j)\beta + \gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + \gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + \gamma)}
  }\,
\end{multline*}
and makes $\gone{Z(\chi)}$ part of his proof. 
Here, $L_i$ are Lagrange basis polynomials, $\smallset{1, \w, \ldots, \w^{\instsize - 1}}$ are roots of unity, $\sigma(j)$ are values determined by the permutation, which defines the circuit (i.e.~which gate is connected to which gate), and $k_1, k_2$ are other \emph{publicly known} values.

Since $\chi$ is fixed, $Z(\chi)$ can be expressed as an evaluation of a rational function $\Gamma(X_\gamma)$ at $\gamma$. We will now focus on interpolating $\Gamma$.
For the sake of readability we denote by $p_i (X_\gamma)$ a polynomial corresponding to the $i$-th product of the numerator of the big fraction in $Z$, that is
\[
  p_i(X_\gamma) = \prod_{j = 1}^{i} L_{i + 1} (\wit_j + \beta \w^{j - 1} + X_\gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + X_\gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + X_\gamma)\,.
\]
Similarly, $q_i (X_\gamma)$ denotes the $i$-th product of the denominator
\[
  q_i(X_\gamma) = \prod_{j = 1}^{i} (\wit_j + \sigma(j)\beta + X_\gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + X_\gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + X_\gamma)\,.
\]

To make the necessary summation all fractions are given a common denominator equal $q_1 (X_\gamma) \cdot \ldots \cdot q_{\instsize - 1} (X_\gamma)$. After this operation, $\Gamma(\gamma)$ can be written as
\begin{multline*}
  \Gamma(\gamma) = (b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi) + \\
   + \brak{\frac{
   p_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma) + q_1(\gamma) p_2(\gamma) q_3(\gamma) \ldots q_{\instsize - 1}(\gamma) + \ldots + q_1(\gamma) \ldots q_{\instsize - 2}(\gamma) p_{\instsize - 1}(\gamma)
   }{
   q_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma)
   }
  }\,.
\end{multline*}
Finally, let 
\[
  \Gamma (X_\gamma) = \frac{N(X_\gamma)}{D(X_\gamma)}\,,
\]
where 
\begin{align*}
  N(X_\gamma) & = \brak{(b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi)} \cdot q_1(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \\
   & + p_1(X_\gamma) q_2(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + q_1(X_\gamma) p_2(X_\gamma) q_3(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \ldots \\
   & + q_1(X_\gamma) \ldots q_{\instsize - 2}(X_\gamma) p_{\instsize - 1}(X_\gamma)\,,\\
  D(X_\gamma) & = q_1(X_\gamma)  \ldots q_{\instsize - 1}(X_\gamma)\,.
\end{align*} 
Both $N(X_\gamma)$ and $D(X_\gamma)$ have degree $3 \frac{(\instsize - 1) \instsize}{2}$, since $\deg p_i (X_\gamma) \allowbreak = \deg q_i (X_\gamma) = 3 i$.

Observe that 
\begin{inparaenum}[(i)]
	\item the degree of polynomial $D(X_\gamma)$ is known and 
	\item one of its coefficients is known, more precisely, the coefficient by the highest power, $X_\gamma^{3i}$, is $1$.
\end{inparaenum}
Hence the requirements for \cref{lem:rational_function_interpolation_2} are met.
 
Following \cref{def:wit_ext_em} we can assume that the extractor gets as input the trapdoor corresponding to the CRS and it knows $\chi$.
Thus the only unknown values in $Z$ are the values of witness elements $\smallset{\wit_{\instsize + j}}_{j = 1}^{2 \cdot \instsize}$ (note that the values $\smallset{\wit_{j}}_{j = 1}^{\instsize}$ are public, i.e.~$\smallset{\wit_{j}}_{j = 1}^{\instsize} = \inp$) and randomisers $b_7, b_8, b_9$ which are picked by the prover at the beginning of the protocol. 
 
\task{15.05}{Missing part -- show that we know enough about coefficients of $\Gamma$ to extract the witness even though (1) some coefficients may depend on many witness parts, (2) some coefficients may depend on the blinders $b_i$}

\qed
\end{proof}

\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto,additional_bib}

\end{document}