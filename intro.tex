

% \chaya{notes: begin}
% There exist several approaches to make current zkSNARKs adequate for real-life deployment among which are \emph{simulation extractability} (SE) and \emph{updatability}.
% There are zkSNARKs that are SE and zkSNARKs that are updatable universal. The question of zkSNARKs that enjoy both of these properties was recently tackled by Kohlweiss and Zajac~\cite{KZ21}
% where they consider SE for \emph{universal srs} SNARKs. However, their definition does not capture the updatability property. Intuitively, the updatability of the srs allows an adversarial prover to contribute to updating, and see proofs with respect to different updated srs'es before attempting to provide a proof for a false statement (potentially output a proof wrt a srs that is different from the srs'es corresponding to all the simulated proofs seen). This capability of the adversary is not modeled in the definition of~\cite{KZ21}. In this work, we capture this by extending the definition of SE for updatable SNARKs and investigate whether existing zkSNARK constructions satisfy the new definition.
%
%
% Points to mention:
% \begin{itemize}
%     \item cite Abdolmaleki et
% al.~\cite{CCS:AbdRamSla20}:
%     \begin{itemize}
%         \item the most relevant related work
%         \item was published at CCS20 (so gives credibility to our result)
%         \item they show a generic compiler/lifting techniques for
% non-black-box simulation extractability
%         \item they also preserve succinctness of the
% argument.
%     \end{itemize}
%     \item non-malleability is usually handeled by binding signatures e.g. Zerocash, Zcash, Orchard.
%     \item Working on improving the security definitions to capture real-world scenarios and powerful adversaries is an important step and makes SNARKs easier to reason about.
%
%     \item Classical definition of KS is not enough in applications:
%     More generaly, the classical definition of KS seems to be unsatisfactory in applications, as it does not provide sufficient security guarantees for SNARKs in the following sense:
%     The natural belief that seeing a valid proof only tells a verifier that the prover knew a satisfactory witness is simply not true. In the context of malleable SNARKs, seeing other valid proofs allows one to construct related proofs   whithout knowing any witness.
%     \item Allowing for malleability makes it difficult to reason about the security properties of SNARKs. Ignoring the ability of an adversary to see other valid proofs prevents from modeling a realistic definition.
%     \item Generic lifting techniques / compilers have overheads and are unnecessary to be applied to schemes for which we can directly show they satisfy our definitions.
%
% \end{itemize}
%
% \chaya{notes:end}


\section{Introduction}

\chaya{general ZK}

\paragraph{zkSNARKs.}

Zero-knowledge Succinct Non-interactive ARguments of Knowledge (zkSNARKs) are  proof systems that allow a prover to generate
short and efficiently verifiable proofs which do not reveal anything more than the correctness of a statement.  

The research on SNARKs has been very fruitful since their introduction in the 80s, leading to schemes that are now deployed in practice.The seminal work of~\cite{EC:GGPR13} proposed a pairing-based zk-SNARK for general NP statements with constant-size proofs. This built on previous works of~\cite{IKO07,AC:Groth10a,TCC:Lipmaa12} and led to several new schemes~\cite{TCC:BCIOP13,SP:PHGR13,C:BCGTV13,AC:Lipmaa13,USENIX:BCTV14,EC:Groth16} with very short proof sizes and fast verification. 
%This line of work on (pre-processing) zkSNARKs has seen rapid progress with many works proposing significant improvements in efficiency of different parameters of interest like proof size, verifier efficiency, complexity of setup, prover efficiency, among others.

In the last decade, zkSNARKs have been adopted by many real-world applications such as decentralised systems and blockchains to improve scalability and privacy. 
Commonly, in such systems zkSNARKs are broadcast in a peer-to-peer network and redundantly stored at every network node in the blockchain.
A series of works focused on constructing and implementing zkSNARKs for blockchain use-cases, such as cryptocurrencies. Zerocash~\cite{SP:BCGGMT14}showed how to use zk-SNARKs in distributed ledgers to achieve privacy-preserving digital payment systems. 
  
Some examples of practival use of zkSNARKs are in the context of Zcash or in Ethereum system\footnote{Zcash \url{https://z.cash/}, Ethereum \url{https://ethereum.org}} for boosting the privacy and scalability of smart contracts. 
A different important SNARK application in blockchain is the Filecoin System\footnote{Filecoin,  \url{https://filecoin.io}} that implements a decentralized storage solution by means of Proof of Space via SNARKs. 

Remark that in all these usages, proofs are posted on the public chain so that any user 
can check that a statement is true (e.g.,validity of a transaction, claims of storage etc.), while idealy expending few resources.

Despite their massive adoption in practice,  zkSNARKs schemes used today are still not well adapted or defined accordingly for the needs of such applications. 
More concretely,  the security definitions are based on unrealistic trust requirements or are formalised without taking into consideration real-world scenarios. 
Most SNARK schemes require the generation of trusted setups which are hard to consider in practice.  Another concern is that classical soundness  definitions for SNARKs are not adapted to the descentralised scenarios, so there is still the need to handle additional security requirements, e.g. non-malleability of proofs
%Zcash protocol
 is achieved by composing SNARKs with additional signature schemes.  
This introduces another concern: composing SNARKs with other cryptographic primitives had been shown not always to be secure \cite{STOC:BCPR14,TCC:FioNit16}.
When using SNARKs in larger cryptographic protocols in real-world scenarios, 
adversarial provers
may get additional information which can contribute to the generation of cheating proofs. To address this problem,  stronger, and more useful, definitions
of proof of knowledge were defined in the literature, but they also introduces other
subtleties.
% as discussed in worls like \cite{C:HadTan98,CCS:AbdRamSla20}.

  
\noindent \emph{Trusted Setup Ceremony.} All the  constant-size zk-SNARK schemes have a common major disadvantage in practice:
they rely on some public parameters, the structured reference string (SRS), that are generated by a trusted setup. In theory, this setup is run by a trusted-third party, while in practice, such a string can be generated by a so called "ceremony", a multi-party
computation between participants who are believed not to collude as shown in \cite{AFRICACRYPT:ABLSZ19,EPRINT:BowGabMie17,SP:BCGTV15}.
Generating such trusted setup is a cumbersome task. 
These ceremonies are expensive in terms of resources, they must follow specific rules and are generally hard to organise: hundreds of participants with powerful machines need to join efforts to perform a multi-party computation over multiple months. 



\paragraph{Simulation extractability.}
Most zkSNARKs are shown to satisfy a standard knowledge soundness property. 
Intuitively, this guarantees that
a prover that creates a valid proof knew a satisfactory witness.  
This definition ignores the ability of an adversary to see other valid proofs that may occur in real-world applications. 
Moreover, in the context of malleable SNARKs, seeing other valid proofs allows one to construct related proofs to new statements whithout knowing the witness. 

Therefore, it is necessary for a zero-knowledge proof system to be \emph{simulation-extractable}, that is, resilient against adversaries that additionally get to see proofs generated by different parties before trying to forge.
This captures the more general scenario where an adversary against the zkSNARK has access to proofs provided by other parties as it is the case in applications of
zkSNARKs in privacy-preserving blockchains,  where proofs are posted on the chain for all
participants in the network to check them. 

\paragraph{zkSNARKs in the updatable setting.}
One of the downsides of efficient zkSNARKs like~\cite{AC:Groth10a,TCC:Lipmaa12,EC:GGPR13,SP:PHGR13,AC:Lipmaa13,AC:DFGK14,EC:Groth16} is that they rely on a \textit{trusted setup}, where there is a structured reference string (SRS) that is assumed to be generated by a trusted party. In practice, however, this assumption is not well founded; if the party that generates the SRS is not honest, then they can produce proofs of false statement. That is, if the trusted setup assumption does not hold, knowledge soundness breaks down.
Groth et al~\cite{C:GKMMM18} propose a setting to tackle this challenge which allows parties -- provers and verifiers -- to \emph{update} the SRS, that is, take a current SRS and contribute to it randomness in a verifiable way to obtain a new SRS. The guarantee in this \textit{updatable setting} is that knowledge soundness holds as long as one of the parties who updates the SRS is honest. The SRS is also \emph{universal}, in that it does not depend on the relation to be proved but only an upper bound on the size of the statements.
Although inefficient, as the SRS length is quadratic to the size of the statement,~\cite{C:GKMMM18} set a new
paradigm of universal updatable setting for designing zkSNARKs.

The first universal zkSNARK with updatable and linear size SRS was
$\sonic$ proposed by Maller et al.~in \cite{CCS:MBKM19}. Subsequently, Gabizon et
al.~designed $\plonk$~\cite{EPRINT:GabWilCio19} which currently is the
most efficient updatable universal zkSNARK. Independently, Chiesa et
al.~\cite{EC:CHMMVW20} proposed $\textsf{Marlin}$ with comparable efficiency to
$\plonk$.

\paragraph{The challenge of SE in the updatable SRS setting.}

The notion of simulation-extractability for zkSNARKs which is well motivated in practice has not been studied in this updatable setting. As it turns out, defining SE for updatable SRS zkSNARKs requires some care. Since the SRS is being continually updated, there are proofs with respect to \textit{different} SRS'es available for the adversary to see before attempting to forge a proof with respect to a current SRS. 
That is, each SRS in the update chain spawns a simulation oracle. Intuitively, the updatability of the SRS allows an adversarial prover to contribute to updating, and see proofs with respect to different updated SRS'es before attempting to provide a proof for a false statement (potentially output a proof wrt a SRS that is different from the SRS'es corresponding to all the simulated proofs seen). A definition of SE in the updatable setting should take into account this additional power of the adversary, which is not captured by existing definitions of SE.

While the generic lifting techniques/compilers of~\cite{EPRINT:KZMQCP15,CCS:AbdRamSla20} can be applied to updatable SRS SNARKs to obtain SE, not only do they inevitably incur overheads and lead to efficiency loss, we contend that the standard definition of SE does not suffice in the updatable setting.


\paragraph{Fiat--Shamir.}
The Fiat--Shamir (FS) transform takes a public-coin interactive protocol and
makes it interactive by hashing the current protocol transcript to compute the
verifier's public coins. While in principle justifiable in the random oracle
model (ROM)~\cite{CCS:BelRog93}, it is theoretically
unsound~\cite{FOCS:GolKal03} and so only a heuristic that should be used with
care.
%
The FS transform is a now popular design tool in constructing
zkSNARKs. In the updatable universal SRS setting, works like \sonic{}~\cite{CCS:MBKM19}
\plonk{}~\cite{EPRINT:GabWilCio19}, and \marlin~\cite{EC:CHMMVW20} are designed
and proven secure as multi-round interactive protocols. Security is then only
\emph{conjectured} for their non-interactive variants by employing the FS
transform.

We investigate the non-malleability properties of a class of zkSNARK protocols obtained by FS-compiling multi-round protocols in the updatable SRS setting and give a modular approach to analyze non-malleablilty of zkSNARKs.

\subsection{Our Contributions}
\begin{itemize}
\item 
\emph{Updatable simulation extractability (USE)}. 
We propose a definition of simulation extractability in the updatable SRS setting that captures the additional power the adversary gets by having access to updating the SRS and seeing proofs with respect to different SRS'es.
    
\item 
\emph{General theorem for USE of FS-compiled interactive protocols.}
We then show that a class of interactive proofs of knowledge that are honest-verifier zero-knowledge,
have a unique response property, and satify a property we define called forking soundness \emph{are USE out-of-the box} in the random oracle model when the Fiat--Shamir transformation is applied to them. 
Informally, our notion of forking soundness is a variant of special soundness where the transcripts provided to the extractor are
obtained through interaction with an honest verifier, and the extraction guarantee is computational instead of unconditional. 
Our extractor only needs oracle access to the adversary, it does not depend on the adversary’s code, nor rely on knowledge
assumptions.
    
\item
\emph{USE for concrete zkSNARKs.}
We then prove that the most efficient updatable SRS SNARKS -- Plonk/Sonic/Marlin -- satisfy the notions necessary to invoke our general theorem, thus showing that these zkSNARKs are updatable simulation extractable.
Proving that these protocols satisfy the required properties is done in the algebraic group model (AGM).
	
%\item
%We make several technical contributions along the way. Our generalized forking lemma is of independent interest.
\end{itemize}



\subsection{Technical Overview}
%unique response, forking soundness. general theorem without additional assumptions. to apply the theorem to concrete schemes like plonk, we show it satisfies unique response, forking soundness, in AGM.

The proof of our general theorem for USE is, at a high level, along the lines of the proof of SE for FS-compiled sigma protocol
from~\cite{INDOCRYPT:FKMV12}. However, we need new and stronger notions as we consider proof systems that are
richer than simple sigma protocols. We discuss some of the technical challenges below.

\plonk~\cite{EPRINT:GabWilCio19} and \sonic~\cite{CCS:MBKM19} were originally presented
as interactive proofs of knowledge that are made non-interactive by the Fiat--Shamir transform. In the following,
we denote the underlying interactive protocols by $\plonkprot$ (for $\plonk$)
and $\sonicprot$ (for $\sonic$) and the resulting non-interactive proof systems by
$\plonkprotfs$ and $\sonicprotfs$, respectively.

\oursubsub{Forking soundness.} 
Following~\cite{INDOCRYPT:FKMV12}, one would have to show that for the protocols we consider, a witness can be extracted from sufficiently many valid transcripts with a common prefix. However, many protocols
do not meet the standard definition of special soundness for sigma protocols, that requires extraction of a witness from any two transcripts, with the same first message. We put forth a notion analogous to special soundness, that is more general and applicable to a wider class of protocols -- protocols that are more than three rounds, and rely on an SRS. For $\plonkprot$ and
$\sonicprot$ that are not three move protocols, the definition needs to be adapted. Furthermore, the number of transcripts
required for extraction is more than two. Concretely, $(3 \noofc + 1)$---where $\noofc$ is the
number of constraints in the proven circuit---for $\plonkprot$ and
$(\multconstr + \linconstr + 1)$---where $\multconstr$ and $\linconstr$ are the
numbers of multiplicative and linear constraints---for $\sonicprot$. Hence, we
do not have a pair of transcripts, but a \emph{tree of transcripts}.

In protocols that rely on SRS that come with a
trapdoors, an adversary in posession of the trapdoor can produce multiple
valid proof transcripts without knowing the witness and potentially for false
statements. This is true even in the updatable setting, where there exists a trapdoor for any updated SRS.
Recall that the standard special soundness definition requires
witness extraction from \emph{any} tree of acceptable transcripts that share a
common root. This means that there are no such trees for false
statements. We define a different, forking lemma-related, version
of soundness that we call \emph{forking soundness}. Forking soundness guarantees that it is
possible to extract a witness from all (but negligibly many) trees of accepting
transcripts produced by probabilistic polynomial time (PPT) adversaries, given
that the trees are generated as interactions between a (possibly malicious)
prover and an honest verifier. That is, if extraction from such a tree fails, then we break an
underlying computational assumption.

\oursubsub{Unique response property.} 
Another property required to show USE is the unique response property~\cite{C:Fischlin05} which
says that for $3$-messages sigma
protocols, all but the first message sent by the prover are
deterministic (intuitively, the prover can only employ fresh randomness in the
first message of the protocol). We cannot use this definition as is since the protocols we consider have other rounds where the prover messages are randomized. In $\plonkprotfs$, both the first and the second prover's messages are randomized. Although $\sonicprot$ prover is deterministic
after it picks its first message, the protocol has more than $3$ rounds. We propose a generalisation of the
definition which states that a protocol is $\ur{i}$ if the prover is
deterministic starting from its $(i + 1)$-th message. For our proof it is
sufficient that this property is met by $\plonkprot$ for $i = 2$. Since
\sonic{}'s prover is deterministic from the second message on, it is $\ur{1}$.


\oursubsub{HVZK.}
In order to invoke our main theorem on $\plonkprotfs$ and
$\sonicprotfs$ to conclude USE, we also need to show that (interactive) $\plonkprot$ and
$\sonicprot$ are HVZK in the standard model. Although both $\sonic$ and $\plonk$ are
zero-knowledge, their simulators utilize trapdoors. However, for our reduction,
we need simulators that rely only on
reordering the messages and picking suitable verifier challenges, without knowing the SRS trapdoor.
That is, any
PPT party should be able to produce a simulated proof by its own in a trapdoor-less wat. (Note that
this property does not necessary break soundness of the protocol as the
simulator is required only to produce a transcript and is not involved in a real
conversation with a real verifier). We show simulators
for $\plonkprotfs$ and $\sonicprotfs$ that rely only on the programmability of
the RO, where programmability is only needed from some round $i$ onwards.
\chaya{revisit this. is HVZK for the interactive protocol? then why programming?}

\oursubsub{Generalisation of the general forking lemma.} 
Consider an interactive $3$-message special-sound protocol $\ps$ and its
non-interactive version $\ps_\fs$ obtained by the Fiat--Shamir transform. The
general forking lemma provides an instrumental lower bound for the probability
of extracting a witness from an adversary who provides two proofs for the same
statement that share the first message. Since $\plonkprot$ and $\sonicprot$ have
more than $3$ messages and are not special-sound, the forking lemma of Bellare
and Neven~\cite{CCS:BelNev06}, cannot be used directly. We propose a
generalization that covers multi-message protocols where witness extraction
requires more transcripts than merely two.  Unfortunately, we also observe that
the security gap grows with the number of transcripts and the probability that
the extractor succeeds diminishes significantly; the security loss, albeit big, is polynomial.

Most modern zkSNARKs~\cite{SP:BBBPWM18,CCS:MBKM19} heavily
rely on the Fiat--Shamir transform and thus potentially the forking lemma. First, an interactive
protocol is proposed and its security and forking soundness analysed. Second,
one uses an argument that the Fiat--Shamir transform can be used to get a
protocol that is non-interactive and shares the same security properties.

We see our generalized forking lemma as contributing to a critical assessment of
this approach. The analysis of the interactive protocol is not enough and one
has to consider the security loss implied by the Fiat-Shamir transform for the target security notion. Thus one has to either rely on our generalisation of the forking
lemma or disclose a transformation that does not suffer this loss. We note that
the security loss may also apply when knowledge soundness is proven. That is the
case for the original $\sonic$ paper, whose security proof relies on so-called witness-extended
emulation. The authors of $\plonk$ and recent work on $\sonic$~\cite{cryptoeprint:2020:1351} work around this problem by proving
knowledge soundness directly in the AGM.



\subsection{Related Work}
%-- notes 
% In contrast to Faust et
% al.~\cite{INDOCRYPT:FKMV12} who focused on special-sound $3$-message sigma
% protocols, our result can be applied to a wider class of protocols and is
% applicable to zkSNARKs.
%
%
% GT20: also about security loss incurred by FS transformation for KS from WEE. put forth a notion of state restoration. analysis in AGM.
% Here: not just KS, but SE. we minimize AGM, rely on rewinding. directly capture the ``state restoration" capability of the prover in the forking lemma.
% no online extraction. new technical challenges arise.

\ourpar{Simulation extractability.}
There are many results on simulation extractability for
non-interactive zero-knowledge proofs (NIZKs). First, Groth \cite{AC:Groth07}
noticed that a (black-box) SE NIZK is
universally-composable (UC) 
\cite{EPRINT:Canetti00}. Then Dodis et al.~\cite{AC:DHLW10} introduced a
notion of (black-box) \emph{true simulation extractability} and showed that no
NIZK can be UC-secure if it does not have this property. 

In the context of zkSNARKs, the first
SE zkSNARK was proposed by Groth and Maller~\cite{C:GroMal17} and SE
zkSNARK for QAP by Lipmaa~\cite{EPRINT:Lipmaa19a}. 
Kosba's et
al.~\cite{EPRINT:KZMQCP15} give a general transformation from a NIZK to a
black-box SE NIZK. Although their transformation works for zkSNARKs as well,
succinctness of the proof system is not preserved by the transformation.
Recently, Abdolmaleki et al.~\cite{CCS:AbdRamSla20} showed another transformation that
obtains non-black-box simulation extractability but also preserves
succinctness of the argument. 
The zkSNARK of~\cite{EC:Groth16} has been shown to be SE by introducing minor modifications to the construction and making
stronger assumptions \cite{EPRINT:BowGab18,EPRINT:AtaBag19}. Recently,~\cite{EPRINT:BKSV20} showed that the
original Groth's proof system from~\cite{EC:Groth16} is weakly SE and
randomizable. None of these results are for zkSNARKs in the updatable SRS setting.

\ourpar{Forking lemma generalizations.}
There are several task specific variants, e.g.,~\cite{INDOCRYPT:HerSae03,CCS:BagCheJar08,AC:BelDaiLi19}, of the general forking lemma~\cite{JC:PoiSte00,CCS:BelNev06} for analyzing the forking behavior of random-oracle based executions.
In~\cite{EC:BCCGP16}, Bootle et al.~proposed a novel inner-product argument which
security relies on, so-called, witness-extended emulation. To show that
property, the authors proposed a new version of forking lemma, which gives a
lower bound on probability that a tree finding algorithm is able to produce a 
tree of acceptable transcripts by rewinding a conversation between a
(potentially malicious) prover and verifier.

Although the result in that paper is dubbed a ``forking lemma'' it
differs from forking lemmas known from e.g.~\cite{JC:PoiSte00,CCS:BelNev06}.
First of all, the forking lemmas in these papers analyse the probability of building
a tree of acceptable transcripts for Fiat--Shamir based non-interactive proof
systems, while the protocol presented by Bootle et al.~is intended to work for
interactive proof systems.

Importantly, it is not obvious how the result of Bootle et al.~can be used to
show security of non-interactive protocols as it relies on interactive provers
whose proving strategies are more limited than proving strategies of
non-interactive provers. For example, if a challenge given by the verifier does not
suit an interactive prover, it can only try to finish a proof with it or
abort. On the other hand, a non-interactive prover has far wider scope of
possible actions--when the protocol is non-interactive the prover may
adapt its strategy based on the random oracle outputs. 
This is reminiscent of \emph{state restoration} security~\cite{TCC:BenChiSpo16,EPRINT:Holmgren19} which is also about the security loss incurred by FS transformation for knowledge soundness from witness extended emulation.

Here, we directly capture the state restoration capability of the prover in the forking lemma instead of defining an interactive game where the prover can rewind the verifier to an earlier state as is done in~\cite{C:GhoTes21}. 
The work of~\cite{C:GhoTes21} further shows that state restoration security gives tight security guarantees for the
non-interactive versions of Bulletproof~\cite{SP:BBBPWM18} and \sonic~. 
Our work differs from~\cite{C:GhoTes21} in the following ways. First, they
focus on showing security of concrete proof systems, while we show
a general theorem about the security of a wide class of protocols. 
Second, they only consider knowledge soundness, while we focus on the stronger notion of simulation extractability. Third, the proof of~\cite{C:GhoTes21} is in the AGM which allows for online extraction, whereas we aim to minimize our reliance on the AGM. In partiular, our main theorem does not rely on AGM and we tackle technical challenges arising from extraction by rewinding. 
However, note that we show that concrete protocols satisfy the preconditions of our main theorem in the AGM.



