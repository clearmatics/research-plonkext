% !TeX spellcheck = en_GB
\let\accentvec\vec
\documentclass[runningheads]{llncs}
 % \documentclass[runningheads]{amsart}
\let\spvec\vec
\let\vec\accentvec
\usepackage{amssymb,amsmath}
\let\vec\spvec

\usepackage[T1]{fontenc}

\newcommand{\iflipics}[1] {}
\newcommand{\iflncs}[1] {#1}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
	{\mbox{\boldmath$\textstyle#1$}}
	{\mbox{\boldmath$\scriptstyle#1$}}
	{\mbox{\boldmath$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

% lncs size (as printed in books, with small margins):
\usepackage[paperheight=23.5cm,paperwidth=15.5cm,text={13.2cm,20.3cm},centering]{geometry}


\newcommand{\ifamsart}[1] {}
\ifamsart{
	\newtheorem{theorem}{Theorem}%[section]
	\newtheorem{proposition}[theorem]{Proposition}
	\newtheorem{lemma}[theorem]{Lemma}
	\newtheorem{corollary}[theorem]{Corollary}
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definition}
	\newtheorem{example}[theorem]{Example}
}

\usepackage{soulutf8}
\soulregister\cite7
\soulregister\ref7
\soulregister\pageref7
\usepackage{hyperref}
\hypersetup{final}
\usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}
\usepackage[capitalise]{cleveref}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed} 

\include{macros}

\title{On Simulation-Extractability of \textsc{Plonk}}
% \titlerunning{Achieving additional security in LegoSNARK}

\author{Michał Zając}
\iflncs{
  \institute{Clearmatics, London, UK\\ \email{m.p.zajac@gmail.com}}
}

\allowdisplaybreaks

\begin{document}
	\sloppy
	\maketitle

\begin{abstract}
	In this paper we show that \plonk{}~\cite{EPRINT:GabWilCio19} is (non black-box) simulation extractable.
\end{abstract}

\section{Introduction}

\section{Preliminaries}
Let PPT denote probabilistic polynomial-time.
Let $\secpar \in \NN$ be the security parameter.
All adversaries will be stateful.
For an algorithm $\adv$, let $\IM (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), let $\RND{\adv}$ denote the random tape of $\adv$ (assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote the random choice of the randomiser $r$ from $\RND{\adv}$.
We denote by $\negl$ an arbitrary negligible function.

Distributions $X$ and $Y$ have \emph{statistical distance} $\SD$ equals $\epsilon$ if $\sum_{a \in \supp{X \cup Y}} \abs{\prob{X = a} - \prob{Y = a}} = \epsilon$.
We write $X \approx_\secpar Y$ if $\SD(X, Y) \leq \negl$, where $\SD$ is the statistical distance between the distributions.
For values $a$ and $b$ we write $a \approx_\secpar b$ if $\abs{a - b} \leq \negl$. 

\paragraph{Bilinear groups.}
A bilinear group generator $\pgen (1^\secpar)$ returns $(p, \GRP_1, \GRP_2, \GRP_T, \pair, \gone{1}, \gtwo{1})$, where $\GRP_1$, $\GRP_2$, and $\GRP_T$ are additive cyclic groups of prime order $p = 2^{\Omega (\secpar)}$, $\gone{1}, \gtwo{1}$ are generators of $\GRP_1$, $\GRP_2$, resp., and $\pair: \GRP_1 \times \GRP_2 \to \GRP_T$ is a non-degenerate PPT-computable bilinear pairing.
We assume the bilinear pairing to be Type-3, i.e., that there is no efficient isomorphism from $\GRP_1$ to $\GRP_2$ or from $\GRP_2$ to $\GRP_1$.
We use the by now standard bracket notation, i.e., we write $\bmap{a}{\gi}$ to denote $a g_{\gi}$ where $g_{\gi}$ is a fixed generator of $\GRP_{\gi}$.
We denote $\pair (\gone{a}, \gtwo{b})$ as $\gone{a} \gtwo{b}$.
Thus, $\gone{a} \gtwo{b} = \gtar{a b}$.
We freely use the bracket notation with matrices, e.g., if $\vec{A} \vec{B} = \vec{C}$ then $\vec{A} \grpgi{\vec{B}} = \grpgi{\vec{C}}$ and $\gone{\vec{A}} \gtwo{\vec{B}} = \gtar{\vec{C}}$.

\subsection{Zero knowledge}
In a zero-knowledge proof or argument system, a prover convinces the verifier of the veracity of a statement without leaking any side information except that the statement is true.
Here, a proof (resp., an argument) system guarantees soundness against an unbounded (resp., a PPT) cheating prover.
The zero-knowledge property is proven by constructing a simulator that can simulate the view of a cheating verifier without knowing the secret information (witness) of the prover.
% A non-interactive zero-knowledge proof or argument system~\cite{STOC:BluFelMic88} consists of just one message by the prover.

More precisely, let $\prover$ and $\verifier$ be algorithms, the former called \emph{prover} and the latter \emph{verifier}. 
We denote by $\ip{\prover (\inp, \wit)}{\verifier (\inp)}$ a transcript of conversation between $\prover$ with input $(\inp, \wit)$ and $\verifier$ with input $\inp$. We write $\ip{\prover (\inp, \wit)}{\verifier (\inp)} = 1$ if in the end of the transcript the verifier $\verifier$ returns $1$ and say that $\verifier$ accepts the transcript.

Let $\RELGEN(\secparam)$ be an algorithm that outputs an $\npol$ relation $\REL = \smallset{(\inp, \wit)}$. Denote by $\LANG_\REL$ the language determined by $\REL$.
We call an interactive proof system $\proofsystem = (\prover, \verifier, \simulator)$ for $\RELGEN$  \emph{zero-knowledge} if for any $\REL \in \IM(\RELGEN)$ and verifier $\verifier^*$ there exists a $\ppt$ simulator $\simulator$ such that
\[
  \smallset{\ip{\prover (\inp, \wit)}{\verifier^{*}(\inp)}} \approx_\secpar \smallset{\ip{\simulator^{\verifier^{*}} (\inp)}{\verifier^{*}(\inp)}}\enspace,
\]
for any $(\inp, \wit) \in \REL$.

We call zero knowledge \emph{perfect} if the distributions are equal and \emph{computational} if they are indistinguishable for any NUPPT distinguisher.

We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no PPT prover $\prover^*$ can convince an honest verifier $\verifier$ to accept a proof for a false statement, i.e~for $\inp \not\in\LANG$.

Interactive proofs are often required to have the special soundness property which states that if for a given statement $\inp$ and first message $a$ the prover can respond to many verifier's challenges then she knows the witness. Moreover, a PPT algorithm with access to a number of prover--verifier conversations that shares the same first



\begin{definition}[Simulation extractability]
	A proof system $\proofsystem$ is computationally (adaptively) \emph{simulation-extractable for $\RELGEN$}, if for every NUPPT $\adv$, there exists a NUPPT extractor $\ext_\adv$, s.t.
  \[
	\condprob{
  \begin{aligned}
    &(\inp, \wit) \not\in \REL \land \inp\not\in Q \\
    & \land \verifier (\REL, \crs_{\verifier}, \inp, \zkproof) = 1
  \end{aligned}
  }
  {
		\begin{aligned}
		& \REL \gets \RELGEN (\secparam),
		(\crs, \td) \gets \kgen (\REL), r \sample \RND{\adv},
		\\ &
		((\inp, \zkproof)  \|  \wit) \gets (\adv^{\oracleo}  \|  \ext_\adv) (\REL, \crs; r)
		\end{aligned}
	} \leq \negl \enspace,
	\]
	where $\oracleo$ on input $\inp'$ returns $\zkproof' \gets \simulator(\REL, \crs, \td, \cdot)$ and writes $\inp'$ to a list $Q$.
\end{definition}

The definition of simulation extractability as stated above allows the malicious prover to maul proofs output by the simulator. This possibility can be ruled out by requiring a stronger property as defined below.

\begin{definition}[Strong simulation extractability]
	A proof system $\proofsystem$ is computationally (adaptively) \emph{strongly simulation-extractable for $\RELGEN$}, if for every NUPPT $\adv$, there exists a NUPPT extractor $\ext_\adv$, s.t.
	\[
	\condprob{
  \begin{aligned}
    &(\inp, \wit) \not\in \REL \land (\inp, \zkproof) \not\in Q \\
    & \land \verifier (\REL, \crs_{\verifier}, \inp, \zkproof) = 1
  \end{aligned}
  }
  {
		\begin{aligned}
		& \REL \gets \RELGEN (\secparam),
		(\crs, \td) \gets \kgen (\REL), r \sample \RND{\adv},
		\\ &
		((\inp, \zkproof)  \|  \wit) \gets (\adv^{\oracleo}  \|  \ext_\adv) (\REL, \crs; r)
		\end{aligned}
	} \leq \negl \enspace,
	\]
	where $\oracleo$ on input $\inp'$ returns $\zkproof' \gets \simulator(\REL, \crs, \td, \cdot)$ and writes $(\inp', \zkproof')$ to a list $Q$.
\end{definition}

\subsection{Interpolation of rational functions}
Let $F(X) = P(X) / Q(X)$ be a rational function defined over $\FF(X)$ such that $\deg P = m_a$ and $\deg Q = m_b$. We call a set $V = \smallset{(x_i, y_i)}_{i \in I}$ a \emph{support set} of $F$ if for all $i \in I$ holds $F(x_i) = y_i$. 
As shown by Minsky et al.~in \cite{TIT:MinTraZip03} if $P$ and $Q$ are monic, then a support set $V$ of size at least $m_a + m_b$ unambiguously determines $F$. 

\begin{theorem}[Rational function interpolation~\cite{TIT:MinTraZip03}]
  Let $F(X) = P(X) / Q(X)$ be a rational function and let $P(X) = X^{m_a} + p_1 X^{m_a - 1} + \ldots + p_{m_a}$, $Q(X) = X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$. Let $V_F$ be a support set of size $m = m_a + m_b$, then $V_F$ determines $F$ unambiguously.
\end{theorem}

We note that when $P$ and $Q$ are not monic, i.e~$P(X) = p_0 X^{m_a} + p_1 X^{m_a - 1} + \ldots +  p_{m_a}$, $Q(X) = q_0 X^{m_b} + q_1 X^{m_a - 1} + \ldots + q_{m_b}$, for $p_0, q_0$ not equal $0$,  then $F$ can be recreated anyway. 
However, not uniquely but up to the following class of equivalence $\class{F}$. 
We say that $F_0(X) = P_0(X) / Q_0(X)  \equiv_\class{F} F_1(X) = P_1(X) / Q_1(X)$ iff for $b \in \bin$
\[
  F_b(X) = \frac{\alpha_b}{\beta_b} \frac{P'_b (X)}{Q'_b(X)}\,,
\]
for monic $P'_0, Q'_0, P'_1, Q'_1$, and $\frac{\alpha_0}{\beta_0} = \frac{\alpha_1}{\beta_1}$.
\begin{lemma}
  Let $F (X) = P(X) / Q(X)$ be a rational function and $P(X), Q(X)$ polynomials of degrees $m_a$ and $m_b$ resp. Then a support set $V_F$ of size $m_a + m_b + 1$ defines $F$ uniquely up to the class of equivalence $\class{F}$. 
\end{lemma}
\begin{proof}
  Let $P_0(X), Q_0(X), P_1(X), Q_1(X)$ be polynomials such that
  \begin{compactenum}[(i)] 
    \item for $b \in \bin$
      \[
        \frac{P_b(X)}{Q_b(X)} = \frac{\alpha_b}{\beta_b} \frac{P'_b (X)}{Q'_b(X)}\,
      \]
      for monic polynomials $P'_b(X)$, $Q'_b(X)$;
    \item for all $x_i \in V_F$ holds 
    \[
      F(x_i) = \frac{P_0(x_i)}{Q_0(x_i)} = \frac{P_1(x_i)}{Q_1(x_i)}\,.
    \]
    Then for all $x_i \in V_F$ holds $\alpha_0 \beta_1 P'_0(x_i) Q'_1(x_i) - \alpha_1 \beta_0 P'_1(x_i) Q'_0 (x_i) = 0$.
  \end{compactenum}
\end{proof}
\begin{corollary}
  Let $F(X) = P(X) / Q(X)$ for a monic polynomial $Q(X)$, then a support set $V_F$ of size $m_a + m_b + 1$, where $m_a = \deg P$, $m_b = \deg Q$, defines $F$ uniquely.
\end{corollary}
% On the other hand, if $p_0$ and $q_0$ are known the function is determined unambiguously. To show that we define monic $P'(X) = P(X) / p_0$ and $Q'(X) =  Q(X) / q_0$, and recreate $F'(X) = P'(X) / Q'(X) = q_0 /p_0 \cdot F(X)$.


\subsection{Generalised forking lemma}
\subsection{Simulation extractability from special soundness}
\section{$\plonk$ protocol rolled-out}
\section{Simulation extractability of \plonk}
The main idea behind showing that \plonk{} is simulation extractable relies on the result by Faust et al.~\cite{INDOCRYPT:FKMV12} where the authors show that a public-coin special-sound protocol made non-interactive by the Fiat--Shamir transform is simulation extractable.
Thus showing that \plonk{} is special-sound and public-coin is enough to show its simulation extractability. It is obvious that \plonk{} is public-coin, thus what remains is to show it is also special-sound.

To that end we take one of the polynomials that are computed by the prover and which contains the witness as parts of the coefficients and, by programming the random oracle and rewinding the prover, we evaluate it on many different points. This allows to recreate the coefficients of the function and therefore the witness.  
%
More precisely, the polynomial $Z(X)$ computed by the prover in the second round of the protocol is used. First the polynomial is expressed as a rational function $\Gamma$ of a formal variable $X_\gamma$, which is evaluated as $\gamma$. 
The variable $\gamma$ is given by the random oracle $\ro$ prior to Round 2. 
By programming $\ro$ and rewinding the prover one can evaluate $\Gamma$ in various points one can recreate the coefficients of $\Gamma$ and compute the witness. 

We note that the extraction procedure is not very efficient. Function $\Gamma$ has numerator and denominator polynomials of degrees linear to the size of the statement. Thus a linear number of rewinds is necessary to recreate the witness.
However, we point out that the efficiency of the extractor does not influences the efficiency of a protocol run between the prover and verifier.

\begin{lemma}[Special soundness of \plonk{}]
  \plonk{} is special-sound in the random oracle model.
\end{lemma}
\begin{proof}
In the second round of \plonk{} the prover gets $\beta = \ro(0, \trans)$ and $\gamma = \ro(1, \trans)$, where $\trans$ is the transcript of the previous messages exchanged in the protocol, from the random oracle, computes polynomial
%
\begin{multline}
  \label{eq:Z}
  Z(X) = (b_7 X^2 + b_8 X + b_9) (X^\instsize - 1) + L_1 (X) + \\
   + \sum_{i = 1}^{\instsize - 1}\brak{L_{i + 1}(X) \prod_{j = 1}^{i} 
  \frac{(\wit_j + \beta \w^{j - 1} + \gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + \gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + \gamma)}
  {(\wit_j + \sigma(j)\beta + \gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + \gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + \gamma)}
  }\,
\end{multline}
and makes $\gone{Z(\chi)}$ part of his proof. 
Here, $L_i$ are Lagrange basis polynomials, $\smallset{1, \w, \ldots, \w^{\instsize - 1}}$ are roots of unity, $\sigma(j)$ are values determined by the permutation, which defines the circuit (i.e.~which gate is connected to which gate), and $k_1, k_2$ are other \emph{publicly known} values.
Assume that the extractor knows $\chi$, what is justified since the extractor may know the trapdoor corresponding to the CRS. \michals{8.05}{Explain in more details.}
 
The only unknown values in $Z$ are the values of witness elements $\smallset{\wit_{\instsize + j}}_{j = 1}^{2 \cdot \instsize}$ (note that the values $\smallset{\wit_{j}}_{j = 1}^{\instsize}$ are public, i.e.~$\smallset{\wit_{j}}_{j = 1}^{\instsize} = \inp$) and randomisers $b_7, b_8, b_9$ which are picked by the prover at the beginning of the protocol. Later we show that even though the extract cannot know the values of the randomisers it does not prevent him from learning the witness.

Since $\chi$ is fixed, $Z(\chi)$ can be expressed as an evaluation of a rational function $\Gamma(X_\gamma)$ at $\gamma$. We will now focus on interpolating $\Gamma$.
For the sake of readability we denote by $p_i (X_\gamma)$ a polynomial corresponding to the $i$-th product of the numerator of the big fraction in $Z$, that is
\[
  p_i(X_\gamma) = \prod_{j = 1}^{i} L_{i + 1} (\wit_j + \beta \w^{j - 1} + X_\gamma)(\wit_{\instsize + j} + \beta k_1 \w^{j - 1} + X_\gamma) (\wit_{2\instsize + j} + \beta k_2 \w^{j - 1} + X_\gamma)\,.
\]
Similarly, $q_i (X_\gamma)$ denotes the $i$-th product of the denominator
\[
  q_i(X_\gamma) = \prod_{j = 1}^{i} (\wit_j + \sigma(j)\beta + X_\gamma)(\wit_{\instsize + j} + \sigma(\instsize + j)\beta + X_\gamma)(\wit_{2\instsize + j} + \sigma (2\instsize + j) \beta + X_\gamma)\,.
\]

To make the necessary summation all fractions are given a common denominator equal $q_1 (X_\gamma)) \cdot \ldots \cdot q_{\instsize - 1} (X_\gamma)$. After this operation, $\Gamma(\gamma)$ can be written as
\begin{multline}
  \Gamma(\gamma) = (b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi) + \\
   + \brak{\frac{
   p_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma) + q_1(\gamma) p_2(\gamma) q_3(\gamma) \ldots q_{\instsize - 1}(\gamma) + \ldots + q_1(\gamma) \ldots q_{\instsize - 2}(\gamma) p_{\instsize - 1}(\gamma)
   }{
   q_1(\gamma) q_2(\gamma) \ldots q_{\instsize - 1}(\gamma)
   }
  }\,.
\end{multline}
Finally, let 
\[
  \Gamma (X_\gamma) = \frac{N(X_\gamma)}{D(X_\gamma)}\,,
\]
where 
\begin{align*}
  N(X_\gamma) & = \brak{(b_7 \chi^2 + b_8 \chi + b_9) (\chi^\instsize - 1) + L_1 (\chi)} \cdot q_1(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \\
   & + p_1(X_\gamma) q_2(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + q_1(X_\gamma) p_2(X_\gamma) q_3(X_\gamma) \ldots q_{\instsize - 1}(X_\gamma) + \ldots \\
   & + q_1(X_\gamma) \ldots q_{\instsize - 2}(X_\gamma) p_{\instsize - 1}(\gamma)\,,\\
  D(X_\gamma) & = q_1(X_\gamma)  \ldots q_{\instsize - 1}(X_\gamma)\,.
\end{align*} 
Both $N(X_\gamma)$ and $D(X_\gamma)$ have degree $3 \frac{(\instsize - 1) \instsize}{2}$, since $\deg p_i (X_\gamma) \allowbreak = \deg q_i (X_\gamma) = 3 i$.
\qed
\end{proof}

\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto,additional_bib}

\end{document}