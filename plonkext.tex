% !TeX spellcheck = en_GB
\let\accentvec\vec
\documentclass[runningheads,11pt]{llncs}
 % \documentclass[runningheads]{amsart}
\let\spvec\vec
\let\vec\accentvec
\usepackage{amssymb,amsmath}
\let\vec\spvec

\usepackage[T1]{fontenc}

\newcommand{\iflipics}[1] {}
\newcommand{\iflncs}[1] {#1}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
	{\mbox{\boldmath$\textstyle#1$}}
	{\mbox{\boldmath$\scriptstyle#1$}}
	{\mbox{\boldmath$\scriptscriptstyle#1$}}}

\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{<-> mathx10}{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareMathAccent{\widebar}{0}{mathx}{"73}

% lncs size (as printed in books, with small margins):
\usepackage[paperheight=23.5cm,paperwidth=15.5cm,text={13.2cm,20.3cm},centering]{geometry}


\newcommand{\ifamsart}[1] {}
\ifamsart{
	\newtheorem{theorem}{Theorem}%[section]
	\newtheorem{proposition}[theorem]{Proposition}
	\newtheorem{lemma}[theorem]{Lemma}
	\newtheorem{corollary}[theorem]{Corollary}
	\theoremstyle{definition}
	\newtheorem{definition}[theorem]{Definition}
	\newtheorem{example}[theorem]{Example}
}
\usepackage{soul}
\usepackage{soulutf8}
\soulregister\cite7
\soulregister\ref7
\soulregister\pageref7
\usepackage{hyperref}
\usepackage[color=yellow]{todonotes}
\hypersetup{final}
\usepackage{mathrsfs}
\usepackage[advantage,asymptotics,adversary,sets,keys,ff,lambda,primitives,events,operators,probability,logic,mm,complexity]{cryptocode}
\usepackage[capitalise]{cleveref}
\usepackage{cite}
\usepackage{booktabs}
\usepackage{paralist}
\usepackage[innerleftmargin=5pt,innerrightmargin=5pt]{mdframed}

\include{macros}

\title{On Simulation-Extractability of \textsc{Plonk}}
% \titlerunning{Achieving additional security in LegoSNARK}

% \author{Michał Zając}
% \iflncs{
%   \institute{Clearmatics, London, UK\\ \email{m.p.zajac@gmail.com}}
% }

\allowdisplaybreaks

\begin{document}
	\sloppy
	\maketitle

\begin{abstract}
	In this paper we prove that some most-efficient updatable universal zkSNARKs like \plonk{}~\cite{EPRINT:GabWilCio19}  is (non black-box) simulation extractable.
	To that end, we generalise the result by Faust et al.~\cite{INDOCRYPT:FKMV12} (INDOCRYPT 2012) and show that any witness-extended emulatable is also simulation-extractable if made non-interactive by the Fiat--Shamir transform. We then explain why \plonk{} is has witness-extended emulation and conclude by showing its simulation-extractability.
	\michals{14.05.20}{Since Sonic is witness-extended emulation then it may be simulation extractable as well. But does it have the unique response property?}
	\task{15.05}{Check Marlin}
\end{abstract}

\section{Introduction}
\paragraph{The rise of updatable zkSNARKs.}
\cite{C:GKMMM18}
\cite{EC:CHMMVW20}
\cite{CCS:MBKM19}
\cite{EPRINT:GabWilCio19}
\cite{EPRINT:Gabizon19c}
\cite{EPRINT:Lipmaa19a}

\paragraph{On the importance of the simulation extractability.}
\cite{AC:DHLW10}
\cite{AC:Groth07}
\cite{EPRINT:AbdRamSla20}
\cite{EPRINT:KZMQCP15}
\cite{EPRINT:AtaBag19}

\subsection{Our contribution}
First of all, we prove that $\plonk$ is simulation-extractable. Although we change the original protocol only little, we had to solve a number of problems in order to show that. The idea of the proof goes as follows.

\paragraph{Witness-extended emulation of \plonk{}.}
First, we show that $\plonk$ has witness-extended emulation. To that end we show how from a number of accepting transcript a witness can be extracted. Unfortunately, \plonk{} does not to fit well in the standard definitions of witness-extended emulations like by Lindell \cite{JC:Lindell03} or by Groth and Ishai \cite{EC:GroIsh08}. The former does not cover arguments that utilises a CRS; although the latter does, it does not consider giving the CRS trapdoor to the extractor. Thus, we had to modify the definition for the witness-extended emulation.
By this modification we bring the notion of the witness-extended emulation closer to the definition of simulation extractability, where giving the trapdoor to the extractor is a natural thing to do, cf.~\cite{AC:Groth06,AC:DHLW10,PKC:ADKNO13,DCC:DerSla19}.
We believe that our formulation would serve well in showing simulation-extractability of other NIZKs.

\paragraph{From witness-extended emulation to simulation extractability.}
Second, we took the classical result by Faust et al.~\cite{INDOCRYPT:FKMV12} which shows that a special-sound $\Sigma$-protocol that has the unique response property is simulation-extractable if made non-interactive by the Fiat--Shamir transform. This result also could not be used directly, as \plonk{} is not a $3$-round $\Sigma$-protocol, nor has the \emph{strict} unique response property.
To make Faust et al.~result working in our setting we had to prove it fits multi-round protocols and show that \plonk{} in fact has the unique response property.

\paragraph{Interactive zero knowledge vs non-interactive zero knowledge.}
Another issue we tackle with is a question whether NIZK proof systems are in fact zero-knowledge, see e.g.~\cite{C:Pass03}. This problem was raised as one could observe that a NIZK proof system has a property alien to interactive proofs---a verifier who obtains a proof $\zkproof$ for a statement $\inp \in \LANG$ inevitably learns how to prove this statement. More precisely, he can just reuse the obtained proof $\zkproof$. This makes the verifier learn undoubtedly more than simply the veracity of the proven statement. On the other hand, the verifier learns a particular proof $\zkproof$ for a concrete CRS $\crs$ only. However, the CRS generator is considered trusted, thus the proof $\zkproof$ could be considered as a proof for $\inp$ universally, regardless the CRS.

Simulation-extractable updatable NIZKs---and zkSNARKs in particular---tighten the gap between interactive zero knowledge and non-interactive zero knowledge in the CRS model.
First, simulation-extractability assures that no adversary can maul an existing proof and make a fresh one, what limits replay attacks.
Second, updatable NIZKs does not assume that there is a trusted party that
provides a CRS, but rather a sequence of parties (called updaters) that modify
it. The security model is radically different as now one believes in the
veracity of a proof only if she trusts that there is at least one honest party
between the updaters. Hence, the proof is no longer
universal.\markulf{09.07.20}{What does universal mean?}
\michals{09.07.20}{I meant universal here in a broad sense -- i.e. I called a setting  a TTP that is trusted by everyone "universal" to denote that a given proof is believable for everybody. Since "universal" tends to have other meanings in terms of ZK, it should probably be changed.}

We believe that our result may be useful for designing new zkSNARKs, especially those based on a polynomial commitment schemes~\cite{AC:KatZavGol10}, as it shows that a careful protocol design may give it a strong security notion for free.

\section{Preliminaries}
Let PPT denote probabilistic polynomial-time.
Let $\secpar \in \NN$ be the security parameter.
All adversaries will be stateful.
For an algorithm $\adv$, let $\image (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), let $\RND{\adv}$ denote the random tape of $\adv$ (assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote the random choice of the randomiser $r$ from $\RND{\adv}$.
We denote by $\negl$ an arbitrary negligible function.

Distributions $X$ and $Y$ have \emph{statistical distance} $\SD$ equals $\epsilon$ if $\sum_{a \in \supp{X \cup Y}} \abs{\prob{X = a} - \prob{Y = a}} = \epsilon$.
We write $X \approx_\secpar Y$ if $\SD(X, Y) \leq \negl$, where $\SD$ is the statistical distance between the distributions.
For values $a$ and $b$ we write $a \approx_\secpar b$ if $\abs{a - b} \leq \negl$.

Denote by $\RELGEN$ a \emph{relation generator} -- a PPT algorithm that on input $\secparam$ outputs an $\npol$ relation $\REL$. We assume that if $\RELGEN$ provides any auxiliary input to $\REL$, it is benign. Directly from the description of $\REL$ one learns security parameter $\secpar$ and other necessary information like a description of a group $\GRP$, if the relation is a relation of group elements (as it usually is in case of zkSNARKs).

\paragraph{Bilinear groups.}
A bilinear group generator $\pgen (1^\secpar)$ returns $(p, \GRP_1, \GRP_2, \GRP_T, \pair, \gone{1}, \gtwo{1})$, where $\GRP_1$, $\GRP_2$, and $\GRP_T$ are additive cyclic groups of prime order $p = 2^{\Omega (\secpar)}$, $\gone{1}, \gtwo{1}$ are generators of $\GRP_1$, $\GRP_2$, resp., and $\pair: \GRP_1 \times \GRP_2 \to \GRP_T$ is a non-degenerate PPT-computable bilinear pairing.
We assume the bilinear pairing to be Type-3, i.e., that there is no efficient isomorphism from $\GRP_1$ to $\GRP_2$ or from $\GRP_2$ to $\GRP_1$.
We use the by now standard bracket notation, i.e., we write $\bmap{a}{\gi}$ to denote $a g_{\gi}$ where $g_{\gi}$ is a fixed generator of $\GRP_{\gi}$.
We denote $\pair (\gone{a}, \gtwo{b})$ as $\gone{a} \bullet \gtwo{b}$.
Thus, $\gone{a} \bullet \gtwo{b} = \gtar{a b}$.
We freely use the bracket notation with matrices, e.g., if $\vec{A} \vec{B} = \vec{C}$ then $\vec{A} \grpgi{\vec{B}} = \grpgi{\vec{C}}$ and $\gone{\vec{A}}\bullet \gtwo{\vec{B}} = \gtar{\vec{C}}$.

\subsection{Zero knowledge}
In a zero-knowledge proof or argument system, a prover convinces the verifier of the veracity of a statement without leaking any side information except that the statement is true.
Here, a proof (resp., an argument) system guarantees soundness against an unbounded (resp., a PPT) cheating prover.
The zero-knowledge property is proven by constructing a simulator that can simulate the view of a cheating verifier without knowing the secret information---witness---of the prover.

More precisely, let $\RELGEN(\secparam)$ be a relation generator that outputs an $\npol$ relation $\REL = \smallset{(\inp, \wit)}$. \markulf{09.07.20}{Not too fond of relation
  generators, but guess this is more general
  than family of relations.} Denote by $\LANG_\REL$ the language determined by $\REL$.
Let $\prover$ and $\verifier$ be algorithms, the former called \emph{prover} and the latter \emph{verifier}.
We denote by $\ip{\prover(\REL, \inp, \wit)}{\verifier(\REL, \inp)}$ a transcript of conversation between a $\prover$ with input $(\REL, \inp, \wit)$ and $\verifier$ with input $(\REL, \inp)$.
We write $\ip{\prover (\REL, \inp, \wit)}{\verifier(\REL, \inp)} = 1$ if in the end of the transcript the verifier $\verifier$ returns $1$ and say that $\verifier$ accepts the transcript.

\markulf{09.07.20}{Could also all quantify for Soundness and Zero knowledge?}
\michals{09.07.20}{I am not sure what you meant here. You want to have for all $\inp, \wit \in \REL$ or you doubt these properties make sense for all $\REL \gets \RELGEN$?}
A proof system $\proofsystem = (\prover, \verifier, \simulator)$ for $\RELGEN$ is required to have three properties: completeness, soundness and zero knowledge, which are defined as follows:
\begin{description}
	\item[Completeness] An interactive proof system $\proofsystem$ is \emph{complete} if an honest prover always convinces an honest verifier, that is for all $\REL \gets \RELGEN(\secparam)$ and $(\inp, \wit) \in \REL$
	\[
		\prob{\ip{\prover (\REL, \inp, \wit)}{\verifier (\REL, \inp)} = 1} = 1\,.
	\]
	\item[Soundness] We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no PPT prover $\adv$ can convince an honest verifier $\verifier$ to accept a proof for a false statement, i.e~for $\inp \not\in\LANG$. More precisely, for all $\REL \gets \RELGEN(\secparam)$
	\[
		\condprob{\ip{\adv(\REL, \inp)}{\verifier(\REL, \inp)} = 1}{\inp \gets \adv(\REL); \inp \not\in \LANG_\REL} \leq \negl\,;
	\]
	\item[Zero knowledge] We call an interactive proof system $\proofsystem$ \emph{zero-knowledge} if for any $\REL \gets \RELGEN(\secparam)$ and adversary $\adv$ there exists a $\ppt$ simulator $\simulator$ such that
	\begin{multline*}
	  \left\{\ip{\prover(\REL, \inp, \wit)}{\adv(\REL, \inp, \wit)} \,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\} \approx_\secpar
		\\
		\left\{\simulator^{\adv}(\REL, \inp)\,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\}\,.
	\end{multline*}
	%
	We call zero knowledge \emph{perfect} if the distributions are equal and \emph{computational} if they are indistinguishable for any NUPPT distinguisher.
\end{description}

\paragraph{NIZKs in the Random Oracle Model.}
In NIZKs in the Random Oracle Model we distinguish, for the sake of clarity, two simulators, one denoted by $\simulator_\zkproof$ that is responsible for providing simulated proofs and $\simulator_\ro$ that picks a random oracle instantiation and takes care of all parties' queries to $\ro$.
% \michals{9.06}{Should we distinguish two simulators or just pack everything into a single one?}
For the sake of consistency (with random oracle-free NIZKs) we use $\simulator$
to denote the pair of state-shareing simulators $\simulator_\zkproof,
\simulator_\ro$.\markulf{09.07.20}{These simulators also share state.}
\michals{09.07}{Done.}
% % \paragraph{Fiat--Shamir transformation.}
% Denote by $\rof{A}{B}$ the family of all functions mapping set $A$ to $B$ and let $\ro$ be a randomly picked function from $\rof{A}{B}$.
% In the Random Oracle Model all algorithms are given oracle access to $\ro$
% The Fiat--Shamir transforms

\paragraph{Sigma protocols.}
A sigma protocol $\sigmaprot = (\prover, \verifier, \simulator)$  for a relation
$\REL \gets \RELGEN(\secparam)$  is a special case of an interactive proof which transcript compounds of three messages $(a, b, z)$, the middle being a challenge provided by the verifier.
Sigma protocols are specially-sound. That is, there exists an extractor $\ext$ which from two accepting transcripts $(a, b, z)$, $(a, b', z')$ for a statement $\inp$ can recreate the corresponding witness if $b \neq b'$. Formally,
\begin{description}
	\item[Special soundness] A sigma protocol $\sigmaprot$ is \emph{specially-sound} if for any adversary $\adv$ the probability
	\[
		\Pr\left[
		\begin{aligned}
				& \wit \gets \ext(\REL, \inp, (a, b, z), (a, b', z')),\\
				& \REL(\inp, \wit) = 0
		\end{aligned}
		\,\left|\,
		\begin{aligned}
			& (\inp, (a, b, z), (a, b', z')) \gets \adv(\REL), \\
			& \verifier(\REL, \inp, (a, b, z)) = \\
			& \qquad = \verifier(\REL, \inp, (a, b', z')) = 1, \\
		\end{aligned}
		\right.\right]
	\]
	is negligible in $\secpar$.
\end{description}

Furthermore sigma protocols are \emph{honest verifier zero-knowledge} (HVZK). That is the zero-knowledge property holds only for honest verifiers, what is formalized as follows:
\begin{description}
	\item[Honest verifier zero knowledge] A sigma protocol $\sigmaprot$ is \emph{honest verifier zero-knowledge} if for all adversaries $\adv$ holds
	\begin{multline*}
		\left\{\ip{\prover(\REL, \inp, \wit)}{\verifier(\REL, \inp)} \,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator_\zkproof^\adv}\right.\right\} \approx_\secpar
		\left\{\simulator_\zkproof^{\verifier}(\REL, \inp)\,\left|\, (\inp, \wit) \gets \adv(\REL)\vphantom{\simulator^\adv}\right.\right\}\,.
	\end{multline*}
\end{description}
Although this notion is weaker than a standard zero knowledge it is often sufficient. Furthermore, a HVZK interactive proof system transformed by the Fiat--Shamir transformation is zero-knowledge.

Another property that sigma protocols sometimes have is, introduced by Fischlin \cite{C:Fischlin05}, a unique response property which states that no PPT adversary  can produce two accepting transcripts that differ only on the last element.
More precisely,
\begin{description}
	\item[Unique response property] Let $\sigmaprot = (\prover, \verifier, \simulator)$ be a standard-model sigma-protocol for relation $\REL \gets \RELGEN(\secparam)$ which proofs compound of three messages $(\alpha, \beta, \gamma)$. We say that $\sigmaprot$ is has a unique response property if for all PPT algorithms $\adv$ holds
	\[
	\condprob{\verifier (\alpha, \beta, \gamma) = \verifier (\alpha, \beta, \gamma')  = 1}{(\alpha, \beta, \gamma, \gamma') \gets \adv(\REL)} \leq \negl\,.
	\]
\end{description}
(If the unique response property holds even against unbounded adversaries, we call it \emph{strict}, cf.~\cite{INDOCRYPT:FKMV12}.)
Later on we often call protocols that follows this notion ur-protocols.
For the sake of completeness we note that many sigma-protocols, like e.g.~Schnorr's protocol \cite{C:Schnorr89}, fulfil this requirement.

\paragraph{Zero knowledge proof system in the CRS model.}
Many proof systems additionally compounds of a setup algorithm $\kcrs$ that on input $\REL$ outputs a common reference string (CRS) $\crs$. The common reference string comes with a corresponding trapdoor $\td$ that allows the simulator to simulate a proof.

\paragraph{Witness-extended emulation.}
Interactive proofs run in a multi-protocol environment are often required to fulfil a stronger notion of soundness called \emph{witness-extended emulation}~\cite{JC:Lindell03}.
The following definition is inspired by  \cite{EC:GroIsh08} as their formulation
of the witness-extended emulation considers proof systems that utilises a CRS.
However, there are some changes introduced to make it fit better our purpose.
More precisely, contrary to \cite{EC:GroIsh08,EC:BCCGP16} the extractor in
\cref{def:wit_ext_em} is given the trapdoor $\td$, thus seems to be bit more
powerful.\markulf{09.07.20}{This is the simulation trapdoor. There are no
  extraction trapdoors in our setting.}
	\michals{09.07.20}{In my first idea for extraction I wanted to extract from polynomial $\p{z}$ that is computed by the prover in Round 2. To do that the extract had to know the simulation trapdoor and no extractability definitions I saw equipped the extractor with it. Anyway, the idea now is to extract the witness from much simpler polynomials evaluated by the prover in Round 4: $\p{a}, \p{b}, \p{c}$. In that case the extractor doesn't need to know the trapdoor.}
This means that a protocol that has witness-extended emulation in terms of \cite{EC:GroIsh08} has it also according to \cref{def:wit_ext_em} below.
There, for the sake of succinctness, we denote by $\trans$ a transcript of a conversation between the prover and the verifier extended with verifier's input $(\REL, \inp)$ (or $(\REL, \crs, \inp)$ in case of a proof system with a setup).
Furthermore, a proof system $\proofsystem$ is \emph{public coin} if the messages the verifier sends are chosen uniformly at random and independently of the messages send by the prover or system parameters.

\begin{definition}[Witness-extended emulation]
	\label{def:wit_ext_em}
	We say a public coin proof system $\proofsystem = (\kcrs, \prover, \verifier,
  \simulator)$ has \emph{witness-extended emulation} if for all $\REL \in
  \image(\RELGEN)$, and deterministic adversary $\adv_1$ there exists an
  expected polynomial time extractor $\ext$ \markulf{09.07.20}{Do we want
    expected PPT, how crucial is the non-uniformity?}
		\michals{09.07}{We need NUPPT extractor to cover NUPPT adversaries, no?} such that for all NUPPT adversaries $\adv_0$ holds
		\begin{multline*}
		\Pr\left[\adv_0 (\trans, \inp, \aux_{\adv_1}) = 1 \,\left|\,
		\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_1}) \gets \adv_0, \\
				& \trans \gets \ip{\adv_1(\REL, \crs, \inp, \aux_{\adv_1})}{\verifier(\REL, \crs, \inp)}
			\end{aligned}
		\right.
		\right]
		 \approx_\secpar \\
		 \Pr\left[
			\begin{aligned}
				& \adv_1 (\trans) = 1\ , \\
				& \text{if $\trans$ is accepting} \\
				& \pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}\,\left|\,
			\begin{aligned}
				& (\td, \crs) \gets \kcrs(\REL), (\inp, \aux_{\adv_0}) \gets \adv_1(\REL), \\
				& (\trans, \wit )\gets \ext^{\ip{\adv_1(\REL, \crs, \inp, \aux_{\adv_1})}{\verifier(\REL, \crs, \inp)}}(\REL, \inp, \td)
			\end{aligned}
			\vphantom{\begin{aligned}
				\adv (\trans) = 1, \\
				\text{if $\trans{}$ is accepting} \\
				\pcind \text{then $\REL(\inp, \wit)$}
			\end{aligned}}\right.
			\right]\,,
\end{multline*}
\markulf{09.07.20}{fix left of $|$}
\michals{09.07}{what do you mean?}
where the extractor $\ext$ can rewind the conversation between the prover and the verifier to a particular round and run it again with a fresh randomness for the verifier.
\end{definition}
Although in the definition above the adversary $\adv_1$ is deterministic it obtains an auxiliary input $\aux_{\adv_1}$ that may be used by $\adv_1$ as a source of randomness. Groth and Ishai~\cite{EC:GroIsh08} note that since the protocol is public-coin, verifier's randomness is part of the transcript. Thus combining $\inp, \aux_\adv$ and an accepting transcript $\trans$ gives a view of both the prover and the verifier and thus gives a witness.

\subsection{Simulation extractable NIZKs from sigma protocols}
Real life applications often require from a NIZK proof system to be non-malleable. That is, no adversary seeing a proof $\zkproof$ for a statement $\inp$ should be able to provide a new proof $\zkproof'$ related to $\zkproof$.
A strong version of non-malleability is formalized by simulation extractability.
This notion states that no adversary can produce valid proof without knowning
the corresponding witness. This must hold even if the adversary is allowed to see polynomially many simulated proofs for any statements she wishes.

\begin{definition}[Simulation extractability]
	A proof system $\proofsystem$ is computationally (adaptively) \emph{strongly simulation-extractable for $\RELGEN$}, if for every NUPPT $\adv$, there exists a NUPPT extractor $\ext_\adv$, s.t.
	\[
	\condprob{
  \begin{aligned}
    &(\inp, \wit) \not\in \REL,\\
		&(\inp, \zkproof) \not\in Q, \\
    & \verifier (\REL, \crs, \inp, \zkproof) = 1
  \end{aligned}
  }
  {
		\begin{aligned}
		& \REL \gets \RELGEN (\secparam),
		(\crs, \td) \gets \kgen (\REL), r \sample \RND{\adv},
		\\ &
		((\inp, \zkproof)  \|  \wit) \gets (\adv^{\oracleo}  \|  \ext_\adv) (\REL, \crs; r)
		\end{aligned}
	} \leq \negl \enspace,
	\]
	where $\oracleo$ on input $\inp'$ returns $\zkproof' \gets \simulator(\REL, \crs, \td, \cdot)$ and writes $(\inp', \zkproof')$ to a list $Q$.
\end{definition}

% Faust et al.~\cite{INDOCRYPT:FKMV12} show every
Consider a sigma protocol $\sigmaprot = (\prover, \verifier, \simulator)$ that
is specially sound and has a unique response property. Let $\sigmaprot_\fs = (\prover_\fs, \verifier_\fs, \simulator_\fs)$ be a NIZK obtained by applying the Fiat--Shamir transform to $\sigmaprot$.
Faust et al.~\cite{INDOCRYPT:FKMV12} show that every such $\sigmaprot_\fs$ is simulation-extractable.

\begin{theorem}[Simulation extractability of the Fiat--Shamir transform \cite{INDOCRYPT:FKMV12}]
	Let $\sigmaprot = (\prover, \verifier, \simulator_\zkproof)$ be a non-trivial sigma protocol with unique responses for a language $\LANG \in \npol$.
	In the random oracle model, the NIZK proof system $\sigmaprot_\fs = (\prover_\fs, \verifier_\fs, \simulator_{\fs})$ resulting by applying the Fiat--Shamir transform to $\sigmaprot$ is simulation extractable with extraction error $\eta = q/h$ for the simulator $\simulator$. Here, $q$ is the number of random oracle queries and $h$ is the number of elements in the range of $\ro$.
	% Furthermore, the extractor $\ext_\adv$ needs to run $\adv^{\simulator_{\fs, \ro}}, \adv^{\simulator_{\fs, \zkproof}}$ twice.
\end{theorem}

The theorem relies on the following classical lemma, called \emph{General forking lemma} \cite{JC:PoiSte00}.

\begin{lemma}[General forking lemma, cf.~\cite{INDOCRYPT:FKMV12}]
	\label{lem:forking_lemma}
	Fix $q \in \ZZ$ and a set $H$ of size $h > 2$. Let $\adv$ be a PPT algorithm that on input $y, h_1, \ldots, h_q$ returns $(i, s)$, where $i \in\range{0}{q}$ and $s$ is called a \emph{side output}.
	Denote by $\ig$ a randomised instance generator.
	We denote by $\accProb$ the probability
	\[
		\condprob{i > 0}{y \gets \ig; h_1, \ldots, h_q \sample H; (i, s) \gets \adv(y, h_1, \ldots, h_q)}\,.
	\]
	Let $\forking_\adv(y)$ denote the algorithm described in \cref{fig:forking_lemma}, then the probability $\extProb$ defined as
	$
		\extProb := \condprob{b = 1}{y \gets \ig; (b, s, s') \gets \forking_{\adv}(y)}
	$
	holds
	\[
		\extProb \geq \accProb \brak{\frac{\accProb}{q} - \frac{1}{h}}\,.
	\]
	%
	\begin{figure}
		\centering
		\fbox{
		\procedure{$\forking_\adv (y)$}
		{
			r \sample \RND{\adv}\\
			h_1, \ldots, h_q \sample H\\
			(i, s) \gets \adv(y, h_1, \ldots, h_q; r)\\
			\pcif i = 0\ \pcreturn (0, \bot, \bot)\\
			h'_{i}, \ldots, h'_{q} \sample H\\
			(i', s') \gets \adv(y, h_1, \ldots, h_{i - 1}, h'_{i} h'_{q}; r)\\
			\pcif (i = i') \land (h_{i} \neq h'_{i})\ \pcreturn (1, s, s')\\
			\pcind \pcelse \pcreturn (0, \bot, \bot)
		}}
		\caption{Forking algorithm $\forking_\adv$}
		\label{fig:forking_lemma}
\end{figure}
\end{lemma}
%
In case of a sigma protocol, the probability $\extProb$ can be interpreted as a lower bound for a successful witness extraction from two transcripts.
Let $\tr_1 = (\inp, a, z, \gamma)$ and $\tr_2 = (\inp, a, z', \gamma')$ be the transcripts.
Both $\tr_1$ and $\tr_2$ have to be \emph{acceptable}, i.e.~$i > 0$ and the probability that $\adv$ makes an acceptable transcript is denoted by $\accProb$. 
Index $i$ can be interpreted as an index of $h_i$ which was sent as a challenge for $(\inp, a)$, this index has to be guessed by the security reduction. 
For the sake of extractability, both transcripts have to have the same index $i$, i.e.~the same instance $\inp$ and the first message $a$, but the actual challenges $z = h_i$ and $z' = h'_{i}$ have to differ.

\subsection{Simulation extractability for multi-round protocols}
Unfortunately, Faust et al.'s result cannot be directly applied in our case since the protocols we consider have more than three rounds of interaction.

\paragraph{Generalised forking lemma.}
First of all, although dubbed ``general'', \cref{lem:forking_lemma} is not general enough for our purpose as it useful only for protocols that extract witness from two transcripts.

Here we propose a generalisation of the general forking lemma that given probability $\accProb$ gives a lower bound on the probability of generating a \emph{tree of accepting transcripts}, which could be used to extract a witness. Note that the transcripts now indeed make a tree which branches with every challenge. 

\begin{proposition}[Generalised general forking lemma]
	% Let $\proofsystem$ be a $(2 \mu + 1)$-round protocol and $\proofsystem_\fs$ its $\fs$-transformed version.
	Fix $q \in \ZZ$ and set $H$ of size $h > \cdots$. 
	Let $\adv$ be a PPT algorithm that on input $y, h_1, \ldots, h_q$ returns $(\vec{k}, s)$ where $\vec{k} \in \range{0,q}^\mu$ and $s$ is called a side output. 
	Denote by $\ig$ a randomised instance generator. We denote by $\accProb$ the probability
	\[
		\condprob{\vec{k}_i \neq 0,\text{ for } i \in \range{1}{\mu}}{ y \gets \ig;\ h_1, \ldots, h_q \sample H;\ (\vec{k}, s) \gets \adv(y, h_1, \ldots, h_q)}\,.
	\]
	Let $\genforking_\adv$ denote the algorithm described in \cref{fig:genforking_lemma} then the probability $\extProb := \condprob{b = 1}{y \gets \ig;\ (b, \vec{s}) \gets \genforking_\adv(y)}$ is at least
	\[
		\cdots
	\]
	
	\begin{figure}
		\centering
		\fbox{
		\procedure{$\genforking_\adv (y)$}
		{
			r \sample \RND{\adv}\\
			h_1, \ldots, h_q \sample H\\
			\vdots
			% (i, s) \gets \adv(y, h_1, \ldots, h_q; r)\\
			% \pcif i = 0\ \pcreturn (0, \bot, \bot)\\
			% h_{i'}, \ldots, h_{q'} \sample H\\
			% (i', s') \gets \adv(y, h_1, \ldots, h_{i - 1}, h_{i'} h_{q'}; r)\\
			% \pcif (i = i') \land (h_{i} \neq h_{i'})\ \pcreturn (1, s, s')\\
			% \pcind \pcelse \pcreturn (0, \bot, \bot)
		}}
		\caption{Generalised forking algorithm $\genforking_\adv$}
		\label{fig:genforking_lemma}
\end{figure}
\end{proposition}

% 
% \begin{figure}
% 	\centering
% 	\fbox{
% 	\procedure{$\treebuild_{\adv_\se} (i)$}
% 	{
% 		\pcif i = \mu + 1 \pcthen\\
% 			\pcind \trans \gets \ip{\prover^*}{\verifier}\\
% 			\pcind b \gets \verifier(\trans)\\
% 			\pcind \pcif b = 0 \pcthen \pcreturn (\trans, \bot)\\
% 			\pcind \pcif b = 1 \pcthen \\
% 			\pcind \pcind \tree \gets \smallset{\trans}\  \pcreturn (\trans, \tree)	\\
% 		\text{Run $\ip{\prover^*}{\verifier}$ up to and including move $2 i + 1$}\\
% 		(\trans, \tree) \gets \treebuild_{\adv_\se}(i + 1)\\
% 		\pcif \tree = \bot \pcthen \pcreturn (\trans, \bot)\\
% 		\counter \gets 1\\
% 		\pcwhile \counter \leq n_i \pcthen\\
% 		\pcind \text{Rewind $\ip{\prover^*}{\verifier}$ back until just before move $2 i$}\\
% 		\pcind (\trans', \tree') \gets \treebuild(i + 1)\\
% 		\pcind \pcif \tree' \neq \bot \pcthen\\
% 		\pcind \pcind \tree \gets \tree \cup \smallset{\trans'} \\
% 		\pcind \pcind \counter \gets \counter + 1\\
% 		\pcreturn \trans, \tree
% 	}}
% 	\caption{Rewinding strategy for $\adv_\se$ -- getting a tree of accepting transcripts.}
% 	\label{fig:rewinding_prover}
% \end{figure}

\paragraph{Unique-response protocols.}
Another problem comes with another assumption required by Faust et al. That is, the unique response property of the transformed sigma protocol.
Fischlin's formulation, although perfectly fine for applications presented in \cite{C:Fischlin05}, is not enough in our case.
First of all, the property assumes that the protocol has three rounds, with the middle being the challenge from the verifier. That is not the case we consider here. Second, it is not entirely clear how to generalize the property. Should one require that after the first challenge from the verifier the responses are fixed? That could not work since if there is more challenges then they are random.
Another problem rises when the protocol contains some round---obviously, except the first one---where the prover randomises his message. In that case unique-responsiveness can not hold as well.
Last but not least, the protocol we consider here most, \plonk, is not in a standard-model, but utilises CRS. That also complicates things considerably.

We walk around these obstacles by providing a generalized notion of the unique response property.
More precisely, we say that a $(2\mu + 1)$-round protocol has \emph{unique responses after $i$} and is called a $\ur{i}$-protocol if
\begin{definition}[$\ur{i}$-protocol]
	\label{def:wiur}
	Let $\proofsystem$ be a multi-round proof system.
	Denote by $a_0, b_0, \ldots, a_{\mu - 1}, b_{\mu - 1}, a_{\mu}$ the consecutive messages exchanged in the protocol, where messages $a_i$ come from the prover and $b_i$ from the verifier.
	We say that $\proofsystem$ has \emph{unique responses after $i$}
	if after submitting his $i$-th message the prover is a deterministic function. That is, it does not use his randomness tape and deterministically answers verifier's challenges.
\end{definition}
\begin{example}
	The Schnorr protocol is $\ur{1}$. That is, after submitting his first message $a$, the prover is a deterministic function of the instance, $a$, and the verifier's challenge.
\end{example}

We note that the definition above is independent on whether the proof system $\proofsystem$ utilises CRS (and compounds of the CRS-generating $\kgen$ algorithm) or not.
% Furthermore it is also blind whether $\proofsystem$ is interactive or not.
\michals{08.07.20}{Should we change it to "deterministic prover property"?}

% \paragraph{Unique responses and extractability.}
% The key observations that will be used in our simulation-extractability proof is following: if a $\mu$-round protocol $\proofsystem$ has deterministic prover from the $i$-th round on and it has witness-extended emulation from a $(n_1, \ldots, n_\mu)$-tree of accepting transcripts, where $n_1 = \ldots = n_{i - 1} = 1$ and $\prod_{i = 1}^\mu n_\mu \leq \poly$, then the $\fs$-transformed version of the protocol $\proofsystem_\fs$ is simulation-extractable.
%
% Furthermore, if $\proofsystem$ has a deterministic prover from round $i$ on, but not in round $i - 1$, and it has witness-extended emulation only from $(n_1, \ldots, n_{i - 1}, \ldots, n_\mu)$-trees of accepting transcripts such that $n_{i - 1} \neq 1$, then $\proofsystem_\fs$ is not simulation-extractable.
%
% The argument behind that goes as follows. To obtain a tree which allows for witness extraction one must rewind the protocol back to round $i - 1$.
% \michals{08.07}{Continue}

\paragraph{Simulatability of proofs.}
% \michals{08.07.20}{Actually, I am not sure that this property is required anymore}
We note that in the standard model protocols the simulator does not require any additional power like knowledge of a CRS trapdoor or programmability of the random oracle. This implies that every adversary can produce a simulated proof by its own.
On the other hand, we have CRS-based zk-proofs where knowledge of trapdoor is required to make an simulated proof.

Given a multi-round Fiat--Shamir-transformed protocol which simulation utilises
trapdoor we can ask another question---how many rounds, from the beginning of
the protocol, can be simulated by the adversary unless the trapdoor is required?
\markulf{}{interesting}\michals{09.07}{I am not sure this property is needed, but the question seems interesting. It came from the following -- in the case of a standard model protocol $\proofsystem$, as in your Indocrypt paper, one can easy make a reduction from breaking a simulation extractability of $\proofsystem_\fs$ to breaking a soundness of $\proofsystem$ (or breaking the unique resp. prop of $\proofsystem$ but that's not the case we consider here). This comes since the reduction can easily simulate proofs of $\proofsystem$ for the se adversary $\adv$.
This reduction is not that easy if $\proofsystem$ uses a CRS -- now the reduction does not know the trapdoor and cannot provide simulated proofs.}
% \michals{09.07.20}{Also, it is not clear for me that in a multiround protocol we can simply use the following argument from your Indocrypt paper -- let $\inp, \vec{a}$ be a partially proof provided by the adversary, then it is a fresh query to the random oracle, otherwise }
% \michals{09.07}{There is also another question -- in Plonk's round 4 the simulator outputs some randomised message. }
% Note that to answer this question we shall quantify over all possible simulators. That would not be a problem though in the setting we consider.

\begin{definition}[$k$-out-of-$n$ simulatable proof system]
	Let $\proofsystem = (\kgen, \prover, \verifier, \simulator)$ for $\RELGEN$ be
  a $n$-round \markulf{09.07.20}{2n-1 round}\michals{09.07}{To be precised. I generally wanted to denote the round by a pair of challenge--response. But can change that if that is not standard.} interactive proof. Let $(\inp, a_0, b_0, \ldots, b_{n - 2}, a_{n - 1})$ be a proof for a statement $\inp$ where $a_i$-s, $i \in \range{0}{n - 1}$ are messages send by the prover and $b_i$-s, $i \in \range{0}{n - 2}$ by the verifier.
	% Similarly we denote by $(\inp, a^{\simulator}_0, b^{\simulator}_0, \ldots, b^{\simulator}_{n - 2}, a^{\simulator}_{n - 1})$ a proof output by the simulator $\simulator$.
	We say that $\proofsystem$ is \emph{$k$-out-of-$n$ simulatable} if for  $\REL \in \image{\RELGEN(\secparam)}$ there exists a $\ppt$ algorithm $\bdv$ that for every PPT adversary $\adv$ can produce a proof $(\inp, a_0, b_0, \ldots, b_{n - 2}, a_{n - 1})$ such that
	\begin{multline*}
		\left\{(\inp, a_0, b_0, \ldots, b_{k - 1}, a_{k}) \gets \bdv(\REL ,\crs) \,\left\vert\,
		\begin{aligned}
			 & (\crs, \td) \gets \kgen(\REL) \\
			 & \inp \gets \adv(\REL, \crs)
		\end{aligned}
		\right.
		\right\} \approx_\secpar \\
		\left\{(\inp, a_0, b_0, \ldots, b_{k - 1}, a_{k}) \gets \simulator(\REL, \crs, \td) \,\left\vert\,
		\begin{aligned}
			 & (\crs, \td) \gets \kgen(\REL) \\
			 & \inp \gets \adv(\REL, \crs)
		\end{aligned}
		\right.
		\right\}\,.
	\end{multline*}
	\michals{3.07.20}{Note that $\inp$ doesn't need to be in the language!}
\end{definition}

This definition will have consequences later on as in a $k$-out-of-$n$ simulatable proof system learning first $2k - 1$ messages of the simulated proof gives the adversary no additional power as it could compute these messages by its own.
This property will be important later in the simulation-extractability proof.
\michals{03.07}{a proof for that statement would be nice.}

\section
{Simulation extractability from unique responses and witness-extended emulation.}
We can now present two proofs for the Fiat--Shamir transform simulation extractability, one for the standard---weaker---version of the unique response property, one for the stronger.
\michals{08.07.20}{That probably will be changed as we don't have disctinction of weak and strong ur prop.---the weak version that worked for CRS-less protocols has been provisionally removed.}

In the former, we assume that the underlying interactive proof system is in the standard model. More precisely, we require that the only additional power given to the simulator is the ability of producing proof elements in any order it wants. Especially, producing a simulated proof does not require knowledge of some sort of a trapdoor.
Although we believe that this result may be of independent interest, it is not enough in our case, it is not enough to show simulation extractability of \plonk.
This is since we show our result by contradiction and build an adversary $\bdv$ that breaks the unique response property using an adversary $\adv$ that breaks simulation extractability. Thus, to make the reduction hold we need to allow $\bdv$ to make simulated proofs for $\adv$.

To make the result useful in the context of CRS-model zkSNARKs like \plonk, we need to rely on a stronger version of the unique response property presented in \cref{def:wiur} to allow the unique-response-property adversary to learn the simulated proofs as well.

\begin{theorem}[Simulation extractability of the Fiat--Shamir transform III]
	\michals{03.07}{The label of this theorem will probably be changed to II (from III)}
	\label{thm:wit_ext_em_FS_III}
	Let $\proofsystem = (\kgen, \prover, \verifier, \simulator)$ be an interactive $\mu$-round $\ur{i}$ protocol for a relation $\REL$ and $i < \mu$.
	Assume there exists an extractor $\ext$ that extracts the witness from a $(n_1, \ldots, n_\mu)$-tree of accepting transcripts of $\proofsystem$ and $\prod_{j = 1}^\mu n_j \leq \poly$.
	Then $\proofsystem_\fs$ is simulation-extractable in the random oracle model.
\end{theorem}
\begin{proof}
	The proof goes similarly to \cite[Theorem 3]{INDOCRYPT:FKMV12}. For the sake of clarity let divide the simulator algorithm $\simulator_\fs$ of $\proofsystem_\fs$  into two subroutines:
	\begin{description}
		\item[$\simulator_{\fs, \ro}$] that takes care about random oracle queries. Assume that there is an upper bound $Q = \poly$ for the number of queries that may be submitted.
		For a query $x$ simulator $\simulator_{\fs, \ro}$ checks whether a list of queries $L$ already contains a pair $(x, y)$, for some $y$, and, if that is the case, outputs $y$.
		Otherwise, it picks an element $y'$ from the random oracle codomain, outputs it and adds $(x, y')$ to $L$. Importantly $y'$ is picked accordingly to the randomness tape provided to $\simulator_{\fs, \ro}$, i.e.~one may assume that $\simulator_{\fs, \ro}$ gets as input a randomness tape $r$ that provides values $y_1, \ldots, y_Q$.
		When the simulator needs to answer a fresh query $x$ it takes the successive $y_i$ from $r$.
		\item[$\simulator_{\fs, \zkproof}$] that provides simulated proofs. The simulator may also program random oracle queries as it wishes. That is, it may add pair $(x, y)$ to $L$ unless there is a pair that have $x$ on the first position. In that case it aborts.
	\end{description}

	Let $\adv_\se^{\simulator_\fs}$ be a simulation-extractability adversary for $\proofsystem_\fs$, $\inp$ the instance $\adv_\se$ proves and $\zkproof = \vec{a} = (a_0, \ldots, a_\mu)$ the corresponding acceptable proof.
	W.l.o.g.~we may assume that $(\inp, \pi)$ is output after $\adv_\se$ learnt simulated proofs from $\simulator_{\fs, \zkproof}$.

	For each $j > i$, divide the adversary's proof $\zkproof$ into two parts:
	first, $\vec{a}_{[0:j]} = (a_0, \ldots, a_j)$ and second $\vec{a}_{{[j + 1:\mu]}} = (a_{j + 1}, \ldots, a_\mu)$.
	Note that $(\inp, \vec{a}_{[0:j]})$ is a fresh query to the random oracle that is performed by the adversary.
	Otherwise, if the query was made by the simulator $\simulator_{\fs, \zkproof}$ then, since $\proofsystem$ is an $\ur{i}$-protocol and $j > i$, a proof starting with $(\inp, \vec{a}_{[0:j]})$ is already in the list of simulated proofs $Q$ and cannot be used by the simulation-extractability adversary $\adv_\se$.

	The tree of accepting transcripts is generating by rewinding the adversary as depicted on~\cref{fig:rewinding_advse}, which is a version of the tree extraction algorithm from \cref{fig:rewinding_prover} tuned for non-interactive proofs and adversaries that have access to simulated proofs.
	To obtain the full tree of transcripts the extractor runs $\treebuild_{\adv_\se, \simulator_{\fs, \zkproof}, \simulator_{\fs, \ro}}^{\REL, \crs, \inp}(1)$, verifies whether all collected transcripts are acceptable and the tree is valid and, if that is the case, returns the witness.

	\begin{figure}
		\centering
		\fbox{
		\procedure{$\treebuild_{\adv_\se, \simulator_{\fs, \zkproof}, \simulator_{\fs, \ro}}^{\REL, \crs, \inp} (i)$}
		{
			\pcif i = \mu + 1 \pcthen\\
				\pcind \zkproof \gets \adv_\se^{\simulator_{\fs, \zkproof}, \simulator_{\fs, \ro}}(\REL, \crs)\\
				\pcind \pcif (\inp, \zkproof) \in Q \pcthen \pcreturn (\zkproof, \bot) \\
				\pcind \pcind \pccomment{$Q$ is the list of $(\inp, \zkproof)$ pairs that have been submitted to  $\simulator_{\fs, \ro}$.}\\
				\pcind b \gets \verifier(\REL, \crs, \inp, \zkproof)\\
				\pcind \pcif b = 0 \pcthen \pcreturn (\zkproof, \bot)\\
				\pcind \pcif b = 1 \pcthen \\
				\pcind \pcind \tree \gets \smallset{\zkproof}\ \pcreturn (\zkproof, \tree)	\\
			\text{Run $\adv_\se$ up to and including query $(\inp, \vec{a}_{[0 : i]})$ to $\simulator_{\FS, \ro}$}\\
			(\zkproof, \tree) \gets \treebuild(i + 1)\\
			\pcif \tree = \bot \pcthen \pcreturn (\zkproof, \bot)\\
			\counter \gets 1\\
			\pcwhile \counter \leq n_i \pcthen\\
			\pcind \text{Rewind $\adv_\se$ back until just before it gets response to $\simulator_{\fs, \ro}$ query $(\inp, \vec{a}_{[0 : i - 1]})$}\\
			\pcind (\zkproof', \tree') \gets \treebuild(i + 1)\\
			\pcind \pcif \tree' \neq \bot \pcthen\\
			\pcind \pcind \tree \gets \tree \cup \smallset{\zkproof'} \\
			\pcind \pcind \counter \gets \counter + 1\\
			\pcreturn \zkproof, \tree
		}}
		\caption{Rewinding strategy for $\adv_\se$---getting a tree of accepting transcripts. For the sake of clarity parameters of $\treebuild$ algorithm have been omitted in the code. We also assume that $\adv_\se$ separately outputs instance $\inp$ which it plans to prove.}
		\label{fig:rewinding_advse}
\end{figure}
	\qed
\end{proof}

\section{Simulation extractability of $\plonk$}
The only modification that has been made to the original \plonk{} protocol is a cosmetic one---originally the value $\gone{\p{W}_{\chz}(\chi)}$ in Round 5, while here it is computed in Round 4. This does not change the security of the protocol as $\gone{\p{W}_{\chz}(\chi)}$ does not include the challenge $v$ which is provided by the verifier after Round~4.
For the sake of clarity we denote this little modified protocol $\plonkmod$, its description has been provided in \cref{sec:plonk_explained}.

\begin{theorem}
	\plonkmod{} is simulation-extractable.
\end{theorem}
\begin{proof}
	First, we observe that \plonkmod{} compounds of 5 rounds and after Round 4, the remain message from the prover is deterministic\michals{09.08}{Prove}.
	Second, observe that if an adversary $\adv_\se$ provides an acceptable proof $\zkproof$ for an instance $\inp$ then the corresponding witness can be extracted from a $(1, 1, \numberofconstrains + 3, 1)$-tree of accepting transcripts. More precisely, in Round 3 the adversary evaluates polynomials $\p{a}(X), \p{b}(X), \p{c}(X)$ at challenge $\chz$, each of the polynomials has degree $\numberofconstrains + 2$.
	By rewinding the adversary $\numberofconstrains + 2$ times and providing fresh challenges $\chz$---by programming the random oracle---the extractor can retrieve the coefficients of $\p{a}(X), \p{b}(X), \p{c}(X)$ which contain witness elements $\smallset{\wit_i}_{i = 1}^{3 \numberofconstrains}$.
	\qed
\end{proof}

\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev1,cryptobib/crypto,additional_bib}

\appendix
\section{$\plonkmod$'s prover explained}
\label{sec:plonk_explained}

\paragraph{\fbox{\normalfont{$\plonkmod$ prover $\prover(\REL, \crs, \inp, \wit)$}}}


\paragraph{\fbox{\normalfont{$\plonkmod$ verifier $\verifier(\REL, \crs, \inp, \zkproof)$}}}\ \newline
The \plonk{} verifier works as follows
\begin{description}
	\item[Step 1] Validate all obtained group elements.
	\item[Step 2] Validate all obtained field elements.
	\item[Step 3] Validate the instace $\inp = \smallset{\wit_i}_{i = 1}^\instsize$.
	\item[Step 4] Compute challenges $\beta, \gamma, \alpha, \alpha', \chz, v, u$ from the transcript.
	\item[Step 5] Compute zero polynomial evaluation $\p{Z_H} (\chz)  =\chz^\numberofconstrains - 1$.
	\item[Step 6] Compute Lagrange polynomial evaluation $\lag_1 (\chz) = \frac{\chz^\numberofconstrains -1}{\numberofconstrains (\chz - 1)}$.
	\item[Step 7] Compute public input polynomial evaluation $\pubinppoly (\chz) = \sum_{i \in \range{1}{\instsize}} \wit_i \lag_i(\chz)$.
	\item[Step 8] Compute quotient polynomials evaluations
	\begin{multline*}
		\p{t} (\chz)  = \frac{1}{\p{Z_H}(\chz)}
		\Big(
			\p{r} (\chz) + \pubinppoly(\chz) - (\p{a}(\chz) + \beta \p{S_\sigma 1}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_\sigma 2}(\chz) + \gamma) \\
			(\p{c}(\chz) +
			\gamma)\p{z}(\chz \omega) \alpha - \lag_1 (\chz) \alpha^2
		\Big) \,.
	\end{multline*}
	\item[Step 9] Compute batched polynomial commitment
	$\gone{D} = v \gone{r} + u \gone {z}$ that is
	\begin{align*}
		\gone{D} & = v
		\left(
		\begin{aligned}
			& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}  \gone{\selright} + \p{c}  \gone{\seloutput} + \\
			& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
			% &   \\
			& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha  \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)})
		\end{aligned}
		\right) + \\
		& + u \gone{\p{z}(\chi)}\,.
	\end{align*}
	\item[Step 10] Computes full batched polynomial commitment $\gone{F}$:
	Next it computes $\gone{F}$:
	\begin{align*}
		\gone{F} & = \left(\gone{\p{t_{lo}}(\chi)} + \chz^\numberofconstrains \gone{\p{t_{mid}}(\chi)} + \chz^{2 \numberofconstrains} \gone{\p{t_{hi}}(\chi)}\right) + u \gone{\p{z}(\chi)} + \\
		& + v
		\left(
		\begin{aligned}
			& \p{a}(\chz)\p{b}(\chz) \cdot \gone{\selmulti} + \p{a}(\chz)  \gone{\selleft} + \p{b}  \gone{\selright} + \p{c}  \gone{\seloutput} + \\
			& + (	(\p{a}(\chz) + \beta \chz + \gamma) (\p{b}(\chz) + \beta k_1 \chz + \gamma) (\p{c} + \beta k_2 \chz + \gamma) \alpha  + \lag_1(\chz) \alpha^2)  + \\
			% &   \\
			& - (\p{a}(\chz) + \beta \p{S_{\sigma 1}}(\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}}(\chz) + \gamma) \alpha  \beta \p{z}(\chz \omega) \gone{\p{S_{\sigma 3}}(\chi)})
		\end{aligned}
		\right) \\
		& + v^2 \gone{\p{a}(\chi)} + v^3 \gone{\p{b}(\chi)} + v^4 \gone{\p{c}(\chi)} + v^5 \gone{\p{S_{\sigma 1}(\chi)}} + v^6 \gone{\p{S_{\sigma 2}}(\chi)}\,.
	\end{align*}
	\item[Step 11] Compute group-encoded batch evaluation $\gone{E}$
	\begin{align*}
		\gone{E}  = \frac{1}{\p{Z_H}(\chz)} & \gone{
		\begin{aligned}
			& \p{r}(\chz) + \pubinppoly(\chz) +  \alpha^2  \lag_1 (\chz) + \\
			& - \alpha \left( (\p{a}(\chz) + \beta \p{S_{\sigma 1}} (\chz) + \gamma) (\p{b}(\chz) + \beta \p{S_{\sigma 2}} (\chz) + \gamma) (\p{c}(\chz) + \gamma) \p{z}(\chz \omega) \right)
		\end{aligned}
		}\\
		 + & \gone{v \p{r}(\chz) + v^2 \p{a}(\chz) + v^3 \p{b}(\chz) + v^4 \p{c}(\chz) + v^5 \p{S_{\sigma 1}}(\chz) + v^6 \p{S_{\sigma 2}}(\chz) + u \p{z}(\chz \omega) }\,.
	\end{align*}
	\item[Step 12] Check whether the verification equation holds
	\begin{multline}
		\label{eq:ver_eq}
		\left(
		\gone{\p{W_{\chz}}(\chi)} + u \cdot \gone{\p{W_{\chz \omega}}(\chi)}
		\right) \bullet
		\gtwo{\chi} = \\
		\left(
			\chz \cdot \gone{\p{W_{\chz}}(\chi)} + u \chz \omega \cdot \gone{\p{W_{\chz \omega}}(\chi)} + \gone{F} - \gone{E}
		\right) \bullet
		\gtwo{1}\,.
	\end{multline}
The verification equation is a batched version of the verification equation from \cite{AC:KatZavGol10} which allows the verifier to check openings of multiple polynomials in two points (instead of checking an opening of a single polynomial at one point).
\end{description}

Since the original paper \cite{EPRINT:GabWilCio19} lacks of explanation how the simulator of \plonk{} works, it is presented here.
\paragraph{\fbox{\normalfont{$\plonkmod$ simulator $\simulator(\REL, \crs, \td, \inp)$}}}
% \paragraph{Simulation in \plonk.}
% The simulator $\simulator$ in $\plonk$ proceeds according to the following steps:
\begin{description}
	\item[Round 1]
	Since the simulator does not know a witness $\wit$ for the proven statement $\inp$, $\simulator$ cannot compute the output of this round accordingly to the protocol. Instead, it picks randomly both the "blinders" $b_1, \ldots, b_6$ and evaluations of polynomials $\p{a}, \p{b}, \p{c}$ by picking their coefficents randomly and outputting $\gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi)}$.
	To ensure deterministic nature of the simulation from now on, the simulator also picks value $w$ which later will be output as $\p{W}_\chz(\chi)$ and determine the value of $\p{W}_{\chz \omega}(\chi)$.
	\item[Round 2]
	Although the simulator controls fully the random oracle, it takes its permutation argument challenges $\beta, \gamma$.
	Similarly as in the previous round, the simulator cannot evaluate the requested polynomial $\p{z}$ honestly as it does not know the witness, picks its coefficients randomly and outputs $\gone{\p{z}(\chi)}$.
	\item[Round 3 and 4]
	In these rounds $\simulator$ proceeds as an honest prover would using its knowledge of coefficents of polynomials $\p{a}, \p{b}, \p{c}, \p{z}$.
	More concretely, in Round 3, the simulator outputs an evaluation of the quotient polynomial $\p{t}$: $\gone{\p{t}_{lo}(\chi), \p{t}_{mid}(\chi), \p{t}_{hi}(\chi)}$ and in
	Round 4 it computes the challenge $\chz$ and outputs $\p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{z}(\chz \omega), \p{t}(\chz)$ along with evaluations of permutation-related polynomials $\p{S_{\sigma 1}(\chz)}, \p{S_{\sigma 2}(\chz)}$.
	The last output value is a polynomial commitment opening $\gone{\p{W}_{\chz}(\chi)}$ which is set to a random group element (which discrete log is known to the simulator).
	\item[Round 5]
	In this round the prover is asked to output value $\gone{\p{W}_{\chz \omega}(\chi)}$ assuring that required polynomials' evaluations are computed correctly. The simulator proceeds similarly, however it uses its knowledge of the simulation trapdoor $\chi$ since the evaluations were computed without use of the witness.
\end{description}
	The only things where the simulator deviates from the behaviour of an honest prover are in Rounds 4 and 5 when it is asked to compute $\gone{\p{W}_{\chz}(\chi)}$ and $\gone{\p{W}_{\chz \omega}(\chi)}$.

	Recall that an honest prover in Round 4 computes $\gone{\p{W}_{\chz}(\chi)}$ as
	\begin{align}
		\p{W}_{\chz \omega}(X) =  \frac{\p{z}(X) - \p{z}(\chz \omega)}{X - \chz \omega}\,,
	\end{align}
	and in Round 5 it gets a challenge $v$ and computes $\gone{\p{W}_{\chz \omega}(\chi)}$ as
	\begin{align}
		& \p{W}_{\chz}(X) = \frac{1} {X - \chz} \left(
			\begin{aligned}
				& (\p{t}_{lo}(X) + \chz^\numberofconstrains \p{t}_{mid}(X) + \chz^{2\numberofconstrains} \p{t}_{hi}(X)) \\
				+ & v (\p{r}(X) - \p{r}(\chz)) \\
				+ & v^2 (\p{a}(X) - \p{a}(\chz)) \\
				+ & v^3 (\p{b}(X) - \p{b}(\chz)) \\
				+ & v^4 (\p{c}(X) - \p{c}(\chz)) \\
				+ & v^5 (\p{S_{\sigma 1}}(X) - \p{S_{\sigma 1}}(\chz)) \\
				+ & v^6 (\p{S_{\sigma 2}}(X) - \p{S_{\sigma 2}}(\chz))
			\end{aligned}
		\right)\,.
	\end{align}
	The simulator computes $\gone{\p{W}_{\chz}(\chi), \p{W}_{\chz \omega}(\chi)}$ such that the verification equation holds,
	\task{09.08}{Explain how the simulator computes $\gone{\p{W}_{\chz}(\chi)}$} outputs the proof
	\[
	\zkproof = \left(
		\begin{aligned}
			& \gone{\p{a}(\chi), \p{b}(\chi), \p{c}(\chi), \p{z}(\chi), \p{t_{lo}}(\chi), \p{t_{mid}}(\chi), \p{t_{hi}}(\chi), \p{W_\chz}(\chi), \p{W_{\chz \omega}}(\chi)}\\
			& \p{a}(\chz), \p{b}(\chz), \p{c}(\chz), \p{S_{\sigma 1}}(\chz), \p{S_{\sigma 2}}(\chz), \p{r}(\chz), \p{z}(\chz \omega)\,.
		\end{aligned}
	\right)
	\]
	and gets $u$ as a final challenge (which it does not reply to).\michals{15.06}{It may be better to just say that $u$ is a random picked by the verifier and not put it as an additional challenge.}
\end{document}
