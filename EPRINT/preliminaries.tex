% !TEX root = main.tex
% !TEX spellcheck = en-US
\section{Preliminaries}
\label{sec:preliminaries}

\markulf{22.04}{Consider if we actually need these notions and notations, if we only need them in one place, move the definition there.}

\paragraph{Notation.} Let $\ppt$ denote probabilistic polynomial-time and $\secpar \in \NN$ be the
security parameter. %All adversaries are stateful. 
For an algorithm $\adv$, 
%let
%$\image (\adv)$ be the image of $\adv$ (the set of valid outputs of $\adv$), 
let
$\RND{\adv}$ denote the set of random tapes of correct length for $\adv$
(assuming the given value of $\secpar$), and let $r \sample \RND{\adv}$ denote
the random choice of the randomiser $r$ from $\RND{\adv}$. We denote by $\negl$
($\poly$) an arbitrary negligible (resp.~polynomial) function.
%
%For probability ensembles $X = \smallset{X_\secpar}_\secpar$ and
%$Y = \smallset{Y_\secpar}_\secpar$, with distributions $X_\secpar, Y_\secpar$ that have
%\emph{statistical distance} $\SD(X_\secpar, Y_\secpar) = \epsilon(\secpar)$ 
%if
%$\sum_{a \in \supp{X_\secpar \cup Y_\secpar}} \abs{\prob{X_\secpar = a} -
%  \prob{Y_\secpar = a}} = \epsilon(\secpar)$. 
%we write $X \approx_\secpar Y$ if
%$\SD(X_\secpar, Y_\secpar) \leq \negl$. 
For functions $a(\secpar)$, $b(\secpar)$ and probability ensembles $X = \smallset{X_\secpar}_\secpar$,
$Y = \smallset{Y_\secpar}_\secpar$ we
write $a(\secpar) \approx_\secpar b(\secpar)$ if
$\abs{a(\secpar) - b(\secpar)} \leq \negl$ and $X \approx_\secpar Y$ if they have \emph{statistical distance} $\SD(X_\secpar, Y_\secpar) \leq \negl )$, respectively.  





\markulf{22.04}{A lot of stuff we only need after Section 4, and likely not in that detail. If it is closer to where it is actually used, it also becomes more obvious whether it actually helps the reader.}



% For a probability space
% $(\samplespace, \eventspace, \probfunction)$ and event $\event{E} \in \eventspace$ we
% denote by $\nevent{E}$ an event that is complementary to $\event{E}$,
% i.e.~$\nevent{E} = \samplespace \setminus \event{E}$.

% \begin{lemma}[Difference lemma,~{\cite[Lemma 1]{EPRINT:Shoup04}}]
% 	\label{lem:difference_lemma}
% 	Let $\event{A}, \event{B}, \event{F}$ be events defined in some probability
% 	space, and suppose that $\event{A} \land \nevent{F} \iff \event{B}
% 		\land \nevent{F}$.  Then 
% 	$
% 		\abs{\prob{\event{A}} - \prob{\event{B}}} \leq \prob{\event{F}}\,.
% 	$
% \end{lemma}




  

\subsection{Zero-Knowledge Proof Systems}\label{prelim:nizk}
In a zero-knowledge proof system, a prover convinces the verifier of the veracity of a statement
without leaking any other information. The zero-knowledge property is proven by constructing a
simulator that can simulate the view of a cheating verifier without knowing the secret
information -- witness -- of the prover. A proof system has to be sound as well, i.e.~for a
malicious prover it should be infeasible to convince a verifier of a false statement. Here, we
focus on proof systems, so-called arguments, that guarantee soundness against $\ppt$ malicious provers. 
\markulf{24.04}{Nice text, but maybe too basic? Also we don't really have views, but really reconstruct the non-interactive proof.}
Typically, a stronger notion of soundness is required -- besides requiring that the
verifier rejects proofs of statements outside the language, we request from the
prover to know a witness corresponding to the proven statement. This property is
called \emph{knowledge soundness}. In this work we investigate an even stronger notion of soundness, \emph{simulation extractability} for non-interactive protocols obtained from interactive arguments via the \emph{Fiat--Shamir heuristic} via random oracles in a setting with an \emph{updatable common reference string.} 

We now introduce these concepts.

\subsection{Updatable SRS schemes}\label{def:upd-scheme}

Let $\prover$ and $\verifier$ be $\ppt$ algorithms, the former called \emph{prover}
and the latter \emph{verifier}. We allow our proof system to have a setup, i.e.~there is a
$\kgen$ algorithm that takes as input the relation description $\REL$ and outputs a common
reference string $\srs$.

We recall the definition of an updatable SRS scheme from~\cite{C:GKMMM18} which consists of the following algorithms.
\vspace{-8pt}
\begin{itemize} 
	\item
	$(\srs,\rho) \gets \kgen(\REL)$ is a PPT algorithm that takes a relation $\REL$ and outputs a SRS $\srs$, and correctness proof $\rho$.
	\item
	$ (\srs',\rho') \gets \upd(\srs, \{\rho_j \}_{j=1}^n)$ is a PPT algorithm that takes a SRS $\srs$, a list of update proofs and outputs an updated SRS together with a proof of correct update. 
	\item
	$b \gets \verifyCRS(\srs, \{\rho_j \}_{j=1}^n)$ is a DPT algorithm that takes a SRS $\srs$, a list of update proofs, and outputs a bit indicating acceptance or not.
\end{itemize}

	In all our protocols, we deal with a structured reference string that is updatable. We give the $\kgen$, $\upd$ and $\verifyCRS$ algorithms in~\cref{fig:upd-scheme}.
	


\begin{figure}[t!]
	\centering
	\fbox{
		\begin{minipage}[t]{0.76\linewidth}
			\procedure{$\kgen(\REL)$}{
				\chi \sample \FF_p \\ [\myskip]
				\srs := 
				\left( \gone{\smallset{\chi^i}_{i = 0}^{\dconst}},
				\gtwo{\chi} \right); 
				\rho =  \left(\gone{\chi, \chi}, \gtwo{\chi}\right) \\ [\myskip]
				\pcreturn (\srs, \rho) \\ [\myskip]
			}
		%
		\\
		%
		\procedure{$\verifyCRS(\srs, \{\rho_j \}_{j=1}^n)$}{
			\text{Parse }  \srs \text{ as } \left( \gone{\smallset{A_i}_{i = 0}^{\dconst}},
			\gtwo{B} \right) \text{and } \{\rho_j \}_{j=1}^n \text{ as } \left\{\left( P_j, \bP_j, \hP_j \right)\right\}_{j=1}^n \\ [\myskip]
			\text{Verify Update proofs: } \\ [\myskip]
			\t \bP_1 = P_1 \\ [\myskip]
			\t P_j \bullet \gtwo{1} = P_{j-1} \bullet \hP_j \quad \forall j \geq 2 \\ [\myskip]
			\t \bP_n \bullet \gtwo{1} = \gone{1} \bullet \hP_n \\ [\myskip]
			\text{Verify SRS structure: } \\ [\myskip]
			\t \gone{A_i} \bullet \gtwo{1} = \gone{A_{i-1}} \bullet \gtwo{B} \text{ for all } 0 < i \leq \dconst \\ [\myskip]
		}
		%
		\\
		%
		\procedure{$\upd(\srs, \{\rho_j \}_{j=1}^n)$}{
			\text{Parse } \srs \text{ as } \left( \gone{\smallset{A_i}_{i = 0}^{\dconst}},
			\gtwo{B} \right) \\ [\myskip]
			\chi' \sample \FF_p  \\ [\myskip]
			\srs' := 
			\left( \gone{\smallset{{\chi'}^i A_i}_{i = 0}^{\dconst}},
			\gtwo{\chi' B} \right); 
			\rho' =	\left( \gone{\chi' A_1, \chi'}, \gtwo{\chi'}\right) \\ [\myskip]
			\pcreturn (\srs', \rho')
		}
		\end{minipage}}
	\caption{Updatable SRS scheme} 
	\label{fig:upd-scheme}
\end{figure}

In the next section, we define security notions in the updatable setting. To this
end, we define an SRS update oracle $\initU$ in~\cref{fig:upd} by which the adversary
updates the SRS.

\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}% 

\begin{figure}[t!]
	\centering
	\fbox{
		\begin{minipage}[t]{0.60\linewidth}
			\procedure{$\initU(\intent, \srs_n,\{\rho_j \}_{j=1}^n)$}{
				\pcif \srs \neq \bot: \pcreturn \bot \\
				\pcif (\intent = \setup): \\
				\t (\srs',\rho') \leftarrow \kgen(\REL)\\
				\t Q_\srs \gets Q_\srs \cup \{(\srs',\rho')\}\\
				\t \pcreturn (\srs',\rho')\\
				%
				\pcif (\intent = \update): \\
				\t b \gets \verifyCRS(\srs_n, \{\rho_j \}_{j=1}^{n})\\
				\t \pcif (b=0): \pcreturn \bot \\
				\t (\srs',\rho') \leftarrow \upd (\srs_n,\{\rho_j \}_{j=1}^n)\\
				\t Q_\srs \gets Q_\srs \cup \{(\srs',\rho')\}\\
		 	\pccomment{$Q_\srs = (Q^{(1)}_\srs, Q^{(2)}_\srs) \text{ s.t. }   Q^{(2)}_\srs \text{ contains the update proofs in } Q_\srs$ } \\
				\t \pcreturn (\srs',\rho')\\
				%
				\pcif (\intent = \final): \\
				\t b \gets \verifyCRS(\srs_n,\{\rho_j \}_{j=1}^{n})\\
				\t \pcif (b=0) \vee Q^{(2)}_\srs \cap \{ \rho_j \}_i = \emptyset: \pcreturn \bot \\
				\t 
				\t \srs \gets \srs_n, \pcreturn \srs \\
				%
				\pcelse \pcreturn \bot
			}
		\end{minipage}
	}
	\caption{The oracle defines the notion of updatable SRS setup.} 
		\label{fig:upd}
\end{figure}

\chb{\begin{remark}[Single adversarial updates after an honest setup.]\label{rem:upd}
	One can consider a slightly different model of setup, wherein the adversary is given an initial (honestly-generated) SRS and then is allowed to maliciously update that in a one-shot fashion.
	As shown by Groth
	et al. in~\cite{C:GKMMM18}, the two definitions are equivalent for the class of SNARKs in this work and thus we use this simpler definition to show our security proofs in the updatable setting.
\end{remark}}

\ourpar{On trusted setup.} We note that a trusted setup can be expressed by the updatable setup definition above simply by restricting the algorithm that is given access to $\initU$ to call the oracle only on $\intent = \setup$ and $\intent = \final$.

\ourpar{Updatability and zero knowledge.}
Groth et al.~\cite{C:GKMMM18} shown that if a proof system is zero-knowledge against adversaries who picks the SRS, then it is updatable zero-knowledge. We call such systems \emph{subvertible zero knowledge}, cf.~\cite{AC:BelFucSca16,AC:ABLZ17}. It was shown that Plonk, Sonic, Marlin and virtually any proof system with a SRS consisting of monomials are subvertible zero-knowledge.

\markulf{24.04}{Tighten the discussion of universality, one paragraph is enough!}
\ourpar{Remark on universality of the SRS.} The proof systems we consider in this work are universal. This means the reference string $\srs$ allows to prove arithmetic constraint defined over a particular field up to some size bound. Thus $\REL$ is universal and the public instance $\inp$ must determine the constraints. We elide public preprocessing of constraint specific proving and verification keys. While important for performance, this modeling is not critical for security.

More precisely, let $\RELGEN(\secparam) = \smallset{\REL}$ be a family of universal 
relations. 
We assume that if
$\REL$ comes with any auxiliary input, the latter is benign. Directly from the
description of $\REL$ one learns security parameter $\secpar$ and the order of a
group $\GRP$, if the relation is a relation on field elements (as usually the case for zkSNARKs). 
We assume that the $\srs$ defines the relation, and for universal proof
systems, such as Plonk and Sonic, we treat both the reference string and the relation as
universal.
 

\subsection{From interactive to non-interactive---the Fiat--Shamir transform}
Consider a $(2\mu + 1)$-message, public-coin, honest verifier zero-knowledge
interactive proof system
$\proofsystem = (\kgen, \prover, \verifier, \simulator)$ for
$\REL \in \RELGEN(\secparam)$.  Let $\zkproof$ be a proof performed by the
prover $\prover$ and verifier $\verifier$ compound of messages
$(a_1, b_1, \ldots, a_{\mu}, b_{\mu}, a_{\mu + 1})$, where $a_i$ comes from
$\prover$ and $b_i$ comes from $\verifier$.  Denote by $\ro$ a random oracle.
Let $\proofsystem_\fs = (\kgen_\fs, \prover_\fs, \verifier_\fs, \simulator_\fs)$
be a proof system such that
\begin{compactitem}
  \item $\kgen_\fs$ behaves as $\kgen$.
  \item $\prover_\fs$ behaves as $\prover$ except after sending message
    $a_i$, $i \in \range{1}{\mu}$, the prover does not wait for
    the message from the verifier but computes it locally setting $b_i
    = \ro(\zkproof[0..i])$, where $\zkproof[0..j] = (\inp, a_1, b_1, \ldots,
    a_{j - 1}, b_{j - 1}, a_j)$. (Importantly, $\zkproof[0..\mu + 1] =
    (\inp, \zkproof)$).\footnote{For Fiat--Shamir based SoK the message signed $m$ is added to $\inp$ before hashing.}
  \item $\verifier_\fs$ behaves as $\verifier$ but does not provide
    challenges to the prover's proof. Instead it computes the
    challenges locally as $\prover_\fs$ does. Then it verifies the
    resulting transcript $\zkproof$ as the verifier $\verifier$ would. 
  \item $\simulator_\fs$ behaves as $\simulator$, except when
    $\simulator$ picks challenge $b_i$ before computing message $\zkproof[0, i]$, $\simulator_\fs$ programs the
    random oracle to output $b_i$ on $\zkproof[0, i]$.
  \end{compactitem}

\noindent
The Fiat--Shamir heuristic states that $\proofsystem_\fs$ is a zero-knowledge
non-interactive proof system for $\REL \in \RELGEN(\secparam)$.


\markulf{24.04}{What do we ned of the below?}

Let $\prover$ and $\verifier$ be $\ppt$ algorithms, the former called \emph{prover}
and the latter \emph{verifier}. 
%We allow our proof system to have a setup, i.e.~there is a
%$\kgen$ algorithm that takes as input the relation description $\REL$ and outputs a common reference string $\srs$.
We denote by $\zkproof$ a proof created by $\prover$ with input
$(\srs, \inp, \wit)$. We say that proof is acceptable if $\verifier (\srs, \inp,
\zkproof)$ accepts it. We focus on proof systems where $\prover$ and
$\verifier$ are given oracle access to a random oracle $\ro$. The simulator
$\simulator$ is not only given access to $\ro$, but it can also \emph{program}
it. That is, it can require that for $(x, y)$ of its choice, $\ro (x) = y$.
% \changedm{This is
% formalized by dividing the simulator into two subroutines $\simulator_1,
% \simulator_2$ that share state. The first subroutine $\simulator_1$ answers random
% oracle queries, while the second one provides simulated proofs.}

A non-interactive  proof system $\proofsystem = (\kgen, \prover, \verifier, \simulator)$ for $\RELGEN$ is
required to have three properties: completeness, soundness and zero knowledge, which are
defined as follows:
%\hamid{10.2}{Should we change the definitions to the updatable setting? In that case, we should move updatable section earlier before this!}
% \begin{description}

	\markulf{22.04}{I don't think we need formal definitions for completeness and soundness}

\ourpar{Completeness.}
%\item[Completeness]
  A non-interactive proof system $\proofsystem$ is
  \emph{complete} if an honest prover always convinces an honest verifier, that
  is for all $\REL \in \RELGEN(\secparam)$ and $(\inp, \wit) \in \REL$
	\[
		\condprob{\verifier^\ro (\srs, \inp, \zkproof) = 1} {\srs \gets \kgen(\REL),
      \zkproof \gets \prover^\ro (\srs, \inp, \wit)}\,.
	\]
    % \item[Soundness]
\ourpar{Soundness.}
    We say that $\proofsystem$ for $\RELGEN$ is \emph{sound} if no
  $\ppt$ prover $\adv$ can convince an honest verifier $\verifier$ to accept a
  proof for a false statement $\inp \not\in\LANG$. More precisely, for
  all $\REL \in \RELGEN(\secparam)$
	\[
    \condprob{ \verifier^\ro (\srs, \inp, \zkproof) = 1 \land \inp \not\in
      \LANG_\REL}{\srs \gets \kgen(\REL), (\inp, \zkproof) \gets \adv^\ro(\srs)} \leq
    \negl.
	\]
%\end{description}



%\subsection{Non-malleability definitions for NIZKs}
%\label{sec:simext_def}
%Real life applications often require a NIZK proof system to be
%non-malleable. That is, no adversary seeing a proof $\zkproof$ for a statement
%$\inp$ should be able to provide a new proof $\zkproof'$ related to $\zkproof$.
%\emph{Simulation extractability} formalizes a strong version of non-malleability
%by requiring that no adversary can produce a valid proof without knowing the
%corresponding witness. This must hold even if the adversary is allowed to see
%polynomially many simulated proofs for any statements it wishes.
%
%%\chaya{remove reference to forking soundness. quantify for $\ext_\se$}
%\begin{definition}[Forking simulation-extractable NIZK, \cite{INDOCRYPT:FKMV12}]
%	\label{def:simext}
%  Let $\ps_\fs = (\kgen_\fs, \prover_\fs, \verifier_\fs, \simulator_\fs)$ be a
%  HVZK proof system\hamid{$\ps_\fs$ is the Fiat-Shamir variant of the underlying proof system. So maybe we mean the underlying proof system is HVZK?}. We say that $\ps_\fs$ is \emph{forking
%    simulation-extractable} with \emph{extraction error} $\nu$ if for any $\ppt$
%  adversary $\adv$ that is given oracle access to a random oracle $\ro$ and
%  simulator $\simulator_\fs$, and produces an accepting transcript of $\ps$ with
%  probability $\accProb$, where
%	\[
%		\accProb = \Pr \left[
%		\begin{aligned}
%			& \verifier_\fs(\srs, \inp_{\advse}, \zkproof_{\advse}) = 1,\\
%			& (\inp_{\advse}, \zkproof_{\advse}) \not\in Q
%		\end{aligned}
%		\, \left| \,
%		\begin{aligned}
%			& \srs \gets \kgen_\fs(\REL), r \sample \RND{\advse}, \\
%			& (\inp_{\advse}, \zkproof_{\advse}) \gets \advse^{\simulator_\fs,
%			\ro} (\srs; r)
%		\end{aligned}
%		\right.\right]\,,
%	\]
%	there exists an extractor $\extse$ such that
%	\[
%		\extProb = \Pr \left[
%		\begin{aligned}
%			& \verifier_\fs(\srs, \inp_{\advse}, \zkproof_{\advse}) = 1,\\
%			& (\inp_{\advse}, \zkproof_{\advse}) \not\in Q,\\
%			& \REL(\inp_{\advse}, \wit_{\advse}) = 1
%		\end{aligned}
%		\, \left| \,
%		\begin{aligned}
%			& \srs \gets \kgen_\fs(\REL), r \sample \RND{\advse},\\
%			& (\inp_{\advse}, \zkproof_{\advse}) \gets \advse^{\simulator_\fs,
%			\ro} (\srs; r) \\
%			& \wit_{\advse} \gets \ext_\se (\srs, \advse, r, \inp_{\advse}, \zkproof_{\advse},
%			Q, Q_\ro) 
%		\end{aligned}
%		\right.\right]
%	\]
%	is at at least 
%	\[
%		\extProb \geq \frac{1}{\poly} (\accProb - \nu)^d - \eps(\secpar)\,,
%	\]
%	for some polynomial $\poly$, constant $d$ and negligible $\eps(\secpar)$ whenever
%  $\accProb \geq \nu$. List $Q$ contains all $(\inp, \zkproof)$ pairs where
%  $\inp$ is an instance provided to the simulator by the adversary and
%  $\zkproof$ is the simulator's answer. List $Q_\ro$ contains all $\advse$'s
%  queries to $\ro$ and $\ro$'s answers.
%\end{definition}






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
